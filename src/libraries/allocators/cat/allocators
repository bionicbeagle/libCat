// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/bit>
#include <cat/span>
#include <cat/tuple>

namespace cat {

template <typename T>
concept memoryHandle = requires(T handle) {
    handle.is_inline_handle;
    handle.is_multi_handle;
    handle.size();
    handle.raw_size();
    handle.is_inline();
};

inline constexpr ssize inline_buffer_size = 256;

// TODO: Handles' `.get()` should be only visible to allocators.
namespace detail {
    // `BaseMemoryHandle` is an opaque memory handle. Allocators are to define
    // and produce a memory handle type which derives from this. These handles
    // contain absolutely arbitrary storage (such as a `T*`, or an `ssize`
    // address offset). Handles must provide a `.get()` method to return
    // whatever that storage is.
    template <typename T>
    struct BaseMemoryHandle {
        static constexpr bool is_inline_handle = false;
        static constexpr bool is_multi_handle = false;
        using Allocation = T;

        // Number of `T`s allocated. This is always 1 if the call is not
        // intercepted by a `MultiMemoryHandle`.
        constexpr auto size() const -> ssize {
            return 1;
        }

        // If `.set_count()` is no-op if it is not intercepted by a
        // `MultiMemoryHandle`.
        void set_count(ssize) {
        }

        // Number of bytes allocated. This is always the size of `T` if the call
        // is not intercepted by a `MultiMemoryHandle`.
        constexpr auto raw_size() const -> ssize {
            return ssizeof<T>();
        }

        // `is_inline()` always holds false if the call is not intercepted by an
        // `InlineMemoryHandle`.
        constexpr auto is_inline() const -> bool {
            return false;
        }
    };

    // A `MultiMemoryHandle` wraps another memory handle for `*_multi`
    // allocations. It effectively overrides `Handle`'s `.size()` and
    // `.raw_size()` methods with the length of an allocated array.
    template <typename Handle>
    struct MultiMemoryHandle {
        static constexpr bool is_inline_handle = Handle::is_inline_handle;
        static constexpr bool is_multi_handle = true;
        using Allocation = typename Handle::Allocation;
        Handle handle;

        // How large this allocation was, in terms of `Allocation`.
        ssize array_length;

        MultiMemoryHandle() = default;

        MultiMemoryHandle(Handle input_handle) : handle(input_handle){};

        // TODO: Variadic emplace.
        void set_inline_storage(Allocation value) {
            this->handle.set_inline_storage(value);
        }

        void set_inlined(bool inlined) {
            this->handle.set_inlined(inlined);
        }

        // Intercept a propagating call to `.set_count()`.
        void set_count(ssize count) {
            this->array_length = count;
        }

        // Intercept a propagating call to `.size()`.
        auto size() const -> ssize {
            return this->array_length;
        }

        // Intercept a propagating call to `.raw_size()`.
        auto raw_size() const -> ssize {
            return this->array_length * ssizeof<Allocation>();
        }

        constexpr auto is_inline() const -> bool {
            return this->handle.is_inline();
        }

        // Get the allocator-specific handle type.
        auto get() & -> decltype(auto) {
            return this->handle.get();
        }

        // Get the allocator-specific handle type.
        auto get() const& -> decltype(auto) {
            return this->handle.get();
        }

        auto get_inline() & -> Allocation& {
            return this->handle.get_inline();
        }

        auto get_inline() const& -> Allocation const& {
            return this->handle.get_inline();
        }
    };

    // An `InlineMemoryHandle` wraps another memory handle for `inline_*`
    // allocations. It extends the storage of this handle to at least 256 bytes,
    // and if the memory allocated is smaller than that, it is stored inside the
    // handle instead of inside an allocator. It effectively overrides the
    // `.is_inline()` method of the handle that it wraps.
    template <typename Handle>
    struct InlineMemoryHandle {
        static constexpr bool is_inline_handle = true;
        static constexpr bool is_multi_handle = Handle::is_multi_handle;
        using Allocation = typename Handle::Allocation;

        union {
            Handle handle;
            Allocation inline_storage;
            // Reserve `inline_buffer_size` bytes to make the size
            // of this handle predictible.
            Byte empty[inline_buffer_size.raw];
        };
        bool is_on_stack;

        // The default constructor must not initialize data.
        // NOLINTNEXTLINE This would be ill-formed if it is `default`ed.
        InlineMemoryHandle(){};

        InlineMemoryHandle(Handle input_handle)
            : handle(input_handle), is_on_stack(handle.is_inline()){};

        ~InlineMemoryHandle() {
            if (this->is_on_stack) {
                this->inline_storage.~Allocation();
            }
        }

        // Intercept a propagating call to `.set_inline_storage()`.
        // TODO: Variadic emplace.
        void set_inline_storage(Allocation value) {
            this->inline_storage = value;
        }

        // Intercept a propagating call to `.set_inlined()`.
        void set_inlined(bool inlined) {
            this->is_on_stack = inlined;
        }

        void set_count(ssize count) {
            this->handle.set_count(count);
        }

        auto size() const -> ssize {
            return handle.size();
        }

        auto raw_size() const -> ssize {
            return handle.raw_size();
        }

        constexpr auto is_inline() const -> bool {
            return this->is_on_stack;
        }

        // Get the allocator-specific handle type.
        auto get() & -> decltype(auto) {
            return this->handle.get();
        }

        // Get the allocator-specific handle type.
        auto get() const& -> decltype(auto) {
            return this->handle.get();
        }

        // Intercept calls to `.get_inline()`.
        auto get_inline() & -> Allocation& {
            return this->inline_storage;
        }

        // Intercept calls to `.get_inline()`.
        auto get_inline() const& -> Allocation const& {
            return this->inline_storage;
        }
    };
}  // namespace detail

template <typename AllocatorT, typename AllocationU = void*>
concept allocator = requires(AllocatorT allocator) {
    // Every allocator has a `.alloc()` method.
    allocator.template alloc<AllocationU>();

    // TODO: It would be nice if these could make the concept more precise:
    // allocator.free(decltype(allocator.template make_handle<AllocationU>(
    //     AllocationU{}, sizeof(AllocationU))){});
    // allocator.get(decltype(allocator.template make_handle<AllocationU>(
    //     AllocationU{}, sizeof(AllocationU))){});
};

namespace detail {
    // `clangd` emits false-positive diagnostics if this constraint is used
    // anonymously without a `concept`.
    template <typename AllocatorT>
    concept StableDerivedAllocator = AllocatorT::has_pointer_stability == true;

    template <typename AllocatorT>
    concept HasAllocate = requires(AllocatorT allocator) {
        allocator.allocate(1_sz);
    };

    template <typename AllocatorT>
    concept HasAlignedAllocate = requires(AllocatorT allocator) {
        allocator.aligned_allocate(1_uz, 1_sz);
    };

    template <typename AllocatorT>
    concept HasAllocationSize = requires(AllocatorT allocator) {
        allocator.allocation_size(1_uz, 1_sz);
    };

    template <typename AllocatorT>
    concept HasAllocateFeedback = requires(AllocatorT allocator) {
        allocator.allocate_feedback(1_sz);
    };

    template <typename AllocatorT>
    concept HasAlignedAllocateFeedback = requires(AllocatorT allocator) {
        allocator.aligned_allocate_feedback(1_uz, 1_sz);
    };
}  // namespace detail

template <typename AllocatorT, typename AllocationU = void*>
concept stableAllocator = requires(AllocatorT it) {
    it.template p_alloc<AllocationU>();
};

template <typename T>
using SizedAllocation = Tuple<T, ssize>;

template <typename T>
using OptionalSizedAllocation = Optional<SizedAllocation<T>>;
/* Optional<Compact<SizedAllocation<T>,
                     [](SizedAllocation<T> tuple) -> bool {
                         return (tuple.second() != 0_sz);
                     },
                     SizedAllocation<T>{T{}, 0_sz}>>;
*/

// TODO: For some reason, this implementation of `salloc()`, this returns an
// `int` in GCC 12. That must be some kind of bug. For now, a less efficient
// implementation is being used.
/*
    template <typename T,  typename... Args>
[[nodiscard]] auto salloc(Args&&... constructor_arguments) {
Optional size = this->nalloc<T>().value();

// GCC 12 fails to deduce the type of template aliases with a lambda in
// an unevaluted context, such as compact optionals, so it must be
// stored in a temporary value `return_val` first.
//
// `[[maybe_unused]]` is required because GCC 12 can mistakenly think
// this is uninitialized.
using Alloc = SizedAllocation<decltype(this->xalloc<T, is_zeroed>())>;

if (size.has_value()) {
    [[maybe_unused]] OptionalSizedAllocation<Alloc> return_val =
        OptionalSizedAllocation<Alloc>{nullopt};
    return return_val;
}

// If `nalloc()` did not fail, this cannot fail.
auto allocation =
    this->xalloc<T, is_zeroed>(forward<Args>(constructor_arguments)...);

[[maybe_unused]] OptionalSizedAllocation<Alloc> return_val =
    OptionalSizedAllocation<Alloc>{Alloc{allocation, 0_sz}};
return return_val;
}
*/

template <typename Derived>
class AllocatorFacade {
  public:
    // Try to allocate a `T`.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto alloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_alloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->unalign_alloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Allocate a `T`.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto xalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_xalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->unalign_xalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_alloc(Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->p_align_alloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->p_unalign_alloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_xalloc(Args&&... constructor_arguments) -> T* {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->p_align_xalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->p_unalign_xalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Try to allocate an array of `T`.
    template <typename T>
    [[nodiscard]] auto alloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_alloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_alloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`.
    template <typename T>
    [[nodiscard]] auto xalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_xalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of `T`,
    // and provide a pointer handle.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_alloc_multi(ssize count) -> OptionalPtr<T> {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->p_align_alloc_multi<T>(alignof(T), count);
        } else {
            return this->p_unalign_alloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`, and
    // provide a pointer handle.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_xalloc_multi(ssize count) -> T* {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->p_align_xalloc_multi<T>(alignof(T), count);
        } else {
            return this->p_unalign_xalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto align_alloc(usize alignment,
                                   Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, true, true, false, false, false, false>(
                alignment, 1, forward<Args>(constructor_arguments)...);
        // TODO: `assert` the alignment is correct.
    }

    // Allocate a `T` with an alignment guarantee.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto align_xalloc(usize alignment,
                                    Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, true, false, false, false, false>(
                alignment, 1, forward<Args>(constructor_arguments)...);
        // TODO: `assert` the alignment is correct.
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_align_alloc(usize alignment,
                                     Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this
            ->meta_alloc<T, false, true, true, false, true, false, false>(
                alignment, 1, forward<Args>(constructor_arguments)...);
        // TODO: `assert` the alignment is correct.
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_align_xalloc(usize alignment,
                                      Args&&... constructor_arguments) -> T* {
        return this
            ->meta_alloc<T, false, false, true, false, true, false, false>(
                alignment, 1, forward<Args>(constructor_arguments)...);
        // TODO: `assert` the alignment is correct.
    }

    // Try to allocate a `T` with no alignment guarantee.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto unalign_alloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, true, false, false, false, false, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a `T` with no alignment guarantee.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto unalign_xalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, false, false, false, false, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_unalign_alloc(Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this
            ->meta_alloc<T, false, true, false, false, true, false, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_unalign_xalloc(Args&&... constructor_arguments) -> T* {
        return this
            ->meta_alloc<T, false, false, false, false, true, false, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate an array of `T` with alignment guarantee.
    template <typename T>
    [[nodiscard]] auto align_alloc_multi(usize alignment, ssize count) {
        return this
            ->meta_alloc<T, false, true, true, true, false, false, false>(
                alignment, count);
        // TODO: `assert` the alignment is correct.
    }

    // Allocate an array of `T` with an alignment guarantee.
    template <typename T>
    [[nodiscard]] auto align_xalloc_multi(usize alignment, ssize count) {
        return this
            ->meta_alloc<T, false, false, true, true, false, false, false>(
                alignment, count);
        // TODO: `assert` the alignment is correct.
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_alloc_multi(usize alignment, ssize count)
        -> OptionalPtr<T> {
        return this->meta_alloc<T, false, true, true, true, true, false, false>(
            alignment, count);
        // TODO: `assert` the alignment is correct.
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_xalloc_multi(usize alignment, ssize count)
        -> T* {
        return this
            ->meta_alloc<T, false, false, true, true, true, false, false>(
                alignment, count);
        // TODO: `assert` the alignment is correct.
    }

    // Try to allocate an array of `T` with no alignment guarantee.
    template <typename T>
    [[nodiscard]] auto unalign_alloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, true, false, true, false, false, false>(
                1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee.
    template <typename T>
    [[nodiscard]] auto unalign_xalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, false, false, false>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_alloc_multi(ssize count) -> OptionalPtr<T> {
        return this
            ->meta_alloc<T, false, true, false, true, true, false, false>(
                1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_xalloc_multi(ssize count) -> T* {
        return this
            ->meta_alloc<T, false, false, false, true, true, false, false>(
                1u, count);
    }

    // Try to allocate a small-size optimized `T`.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_alloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_alloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->inline_unalign_alloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Allocate a small-size optimized `T`.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_xalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_xalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->inline_unalign_xalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`.
    template <typename T>
    [[nodiscard]] auto inline_alloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_alloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_alloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_xalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_xalloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_xalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_align_alloc(usize alignment,
                                          Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, true, true, false, false, false, false>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_align_xalloc(usize alignment,
                                           Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, false, true, false, false, false, false>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_unalign_alloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, true, false, false, false, false, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_unalign_xalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, false, false, false, false, false, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee.
    template <typename T>
    [[nodiscard]] auto inline_align_alloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, true, true, true, true, false, false, false>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee.
    template <typename T>
    [[nodiscard]] auto inline_align_xalloc_multi(usize alignment, ssize count) {
        return this
            ->meta_alloc<T, true, false, true, true, false, false, false>(
                alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee.
    template <typename T>
    [[nodiscard]] auto inline_unalign_alloc_multi(ssize count) {
        return this
            ->meta_alloc<T, true, true, false, true, false, false, false>(
                1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee.
    template <typename T>
    [[nodiscard]] auto inline_unalign_xalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, true, false, false, true, false, false, false>(
                1u, count);
    }

    // Try to get the number of bytes that allocating a `T` would reserve.
    template <typename T>
    [[nodiscard]] auto nalloc() -> OptionalNonZero<ssize> {
        return this->align_nalloc<T>(alignof(T));
    }

    // Get the number of bytes that allocating a `T` would reserve.
    template <typename T>
    [[nodiscard]] auto xnalloc() -> ssize {
        return this->align_xnalloc<T>(alignof(T));
    }

    // Try to get the number of bytes that allocating an array of `T` would
    // reserve.
    template <typename T>
    [[nodiscard]] auto nalloc_multi(ssize count) -> OptionalNonZero<ssize> {
        return this->align_nalloc_multi<T>(alignof(T), count);
    }

    // Get the number of bytes that allocating an array of `T` would
    // reserve.
    template <typename T>
    [[nodiscard]] auto xnalloc_multi(ssize count) -> ssize {
        return this->align_nalloc_multi<T>(alignof(T), count).value();
    }

    // Try to get the number of bytes that allocating a `T` with an alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto align_nalloc(usize alignment) -> OptionalNonZero<ssize> {
        return this->self().allocation_size(alignment, ssizeof<T>());
    }

    // Get the number of bytes that allocating a `T` with an alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto align_xnalloc(usize alignment) -> ssize {
        return this->self().allocation_size(alignment, ssizeof<T>()).value();
    }

    // Try to get the number of bytes that allocating a `T` with no alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto unalign_nalloc() -> OptionalNonZero<ssize> {
        return this->self().allocation_size(1u, ssizeof<T>());
    }

    // Get the number of bytes that allocating a `T` with no alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto unalign_xnalloc() -> ssize {
        return this->self().allocation_size(1u, ssizeof<T>()).value();
    }

    // Try to get the number of bytes that allocating an array of `T` with an
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto align_nalloc_multi(usize alignment, ssize count)
        -> OptionalNonZero<ssize> {
        return this->self().allocation_size(alignment, ssizeof<T>() * count);
    }

    // Get the number of bytes that allocating an array of `T` with an
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto align_xnalloc_multi(usize alignment, ssize count)
        -> ssize {
        return this->self()
            .allocation_size(alignment, ssizeof<T>() * count)
            .value();
    }

    // Try to get the number of bytes that allocating an array of `T` with no
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto unalign_nalloc_multi(ssize count)
        -> OptionalNonZero<ssize> {
        return this->self().allocation_size(1u, ssizeof<T>() * count);
    }

    // Get the number of bytes that allocating an array of `T` with no
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto unalign_xnalloc_multi(ssize count) -> ssize {
        return this->self().allocation_size(1u, ssizeof<T>() * count).value();
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // would reserve.
    template <typename T>
    [[nodiscard]] auto inline_nalloc() -> OptionalNonZero<ssize> {
        return this->inline_align_nalloc<T>(alignof(T));
    }

    // Get the number of bytes that allocating a small-size optimized `T`
    // would reserve.
    template <typename T>
    [[nodiscard]] auto inline_xnalloc() -> ssize {
        return this->inline_align_xnalloc<T>(alignof(T));
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` would reserve.
    template <typename T>
    [[nodiscard]] auto inline_nalloc_multi(ssize count)
        -> OptionalNonZero<ssize> {
        return this->inline_align_nalloc_multi<T>(alignof(T), count);
    }

    // Get the number of bytes that allocating a small-size optimized array of
    // `T` would reserve.
    template <typename T>
    [[nodiscard]] auto inline_xnalloc_multi(ssize count) -> ssize {
        return this->inline_align_xnalloc_multi<T>(alignof(T), count);
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_align_nalloc(usize alignment)
        -> OptionalNonZero<ssize> {
        if constexpr (ssizeof<T>() > inline_buffer_size) {
            return this->self().allocation_size(alignment, ssizeof<T>());
        } else {
            return inline_buffer_size;
        }
    }

    // Get the number of bytes that allocating a small-size optimized `T` with
    // an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_align_xnalloc(usize alignment) -> ssize {
        return this->inline_align_nalloc<T>(alignment).value();
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_unalign_nalloc() -> OptionalNonZero<ssize> {
        return this->inline_align_nalloc<T>(1u);
    }

    // Get the number of bytes that allocating a small-size optimized `T` with
    // no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_unalign_xnalloc() -> ssize {
        return this->inline_align_xnalloc<T>(1u);
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_align_nalloc_multi(usize alignment, ssize count)
        -> OptionalNonZero<ssize> {
        if (ssizeof<T>() * count > inline_buffer_size) {
            return this->self().allocation_size(alignment,
                                                ssizeof<T>() * count);
        }
        return inline_buffer_size;
    }

    // Get the number of bytes that allocating a small-size optimized
    // array of `T` with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_align_xnalloc_multi(usize alignment, ssize count)
        -> ssize {
        return this->inline_align_nalloc_multi<T>(alignment, count).value();
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_unalign_nalloc_multi(ssize count)
        -> OptionalNonZero<ssize> {
        return this->inline_align_nalloc_multi<T>(1u, count);
    }

    // Get the number of bytes that allocating a small-size optimized
    // array of `T` with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_unalign_xnalloc_multi(ssize count) -> ssize {
        return this->inline_align_xnalloc_multi<T>(1u, count);
    }

    // Try to allocate a `T`, and return the number of bytes that were
    // allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto salloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->align_salloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->unalign_salloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Allocate a `T`, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto xsalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->align_xsalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->unalign_xsalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_salloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->p_align_salloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->p_unalign_salloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_xsalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->p_align_xsalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->p_unalign_xsalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Try to allocate an array of `T`, and return the number of bytes that were
    // allocated.
    template <typename T>
    [[nodiscard]] auto salloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_salloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_salloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`, and return the number of bytes that were
    // allocated.
    template <typename T>
    [[nodiscard]] auto xsalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_xsalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xsalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of `T`,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_salloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->p_align_salloc_multi<T>(alignof(T), count);
        } else {
            return this->p_unalign_salloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_xsalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->p_align_xsalloc_multi<T>(alignof(T), count);
        } else {
            return this->p_unalign_xsalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee, and return the number
    // of bytes that were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto align_salloc(usize alignment,
                                    Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, true, true, false, false, false, true>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a `T` with an alignment guarantee, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto align_xsalloc(usize alignment,
                                     Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, true, false, false, false, true>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_align_salloc(usize alignment,
                                      Args&&... constructor_arguments) {
        return this->meta_alloc<T, false, true, true, false, true, false, true>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_align_xsalloc(usize alignment,
                                       Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, true, false, true, false, true>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a `T` with no alignment guarantee, and return the number
    // of bytes that were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto unalign_salloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, true, false, false, false, false, true>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a `T` with no alignment guarantee, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto unalign_xsalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, false, false, false, false, true>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_unalign_salloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, true, false, false, true, false, true>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_unalign_xsalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, false, false, true, false, true>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto align_salloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, false, true, true, true, false, false, true>(
            alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto align_xsalloc_multi(usize alignment, ssize count) {
        return this
            ->meta_alloc<T, false, false, true, true, false, false, true>(
                alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_salloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, false, true, true, true, true, false, true>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with an
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_xsalloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, false, false, true, true, true, false, true>(
            alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto unalign_salloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, true, false, true>(
            1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto unalign_xsalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, false, false, true>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_salloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, true, false, true>(
            1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with no
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_xsalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, true, false, true>(
                1u, count);
    }

    // Try to allocate a small-size optimized `T`, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_salloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_salloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->inline_unalign_salloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Allocate a small-size optimized `T`, and return the number of bytes that
    // were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_xsalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xsalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->inline_unalign_xsalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`, and return the
    // number of bytes that were allocated.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_salloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_salloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_salloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_xsalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xsalloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_xsalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_align_salloc(usize alignment,
                                           Args&&... constructor_arguments) {
        return this->meta_alloc<T, true, true, true, false, false, false, true>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_align_xsalloc(usize alignment,
                                            Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, false, true, false, false, false, true>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_unalign_salloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, true, false, false, false, false, true>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_unalign_xsalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, false, false, false, false, false, true>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto inline_align_salloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, true, true, false, true, false, false, true>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto inline_align_xsalloc_multi(usize alignment,
                                                  ssize count) {
        return this->meta_alloc<T, true, false, true, true, false, false, true>(
            alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto inline_unalign_salloc_multi(ssize count) {
        return this->meta_alloc<T, true, true, false, true, false, false, true>(
            1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto inline_unalign_xsalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, true, false, false, true, false, false, true>(
                1u, count);
    }

    // Try to allocate a `T`.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto calloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->align_calloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->unalign_calloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Allocate a `T`.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto xcalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->align_xcalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->unalign_xcalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_calloc(Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        if constexpr (alignof(T) > 1) {
            return this->p_align_calloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->p_unalign_calloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_xcalloc(Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        if constexpr (alignof(T) > 1) {
            return this->p_align_xcalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->p_unalign_xcalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Try to allocate an array of `T`.
    template <typename T>
    [[nodiscard]] auto calloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_calloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_calloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`.
    template <typename T>
    [[nodiscard]] auto xcalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_xcalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xcalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T`, and provide a pointer handle.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_calloc_multi(ssize count) -> OptionalPtr<T> {
        if constexpr (alignof(T) > 1) {
            return this->p_align_calloc_multi<T>(alignof(T), count);
        } else {
            return this->p_unalign_calloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`, and
    // provide a pointer handle.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_xcalloc_multi(ssize count) -> OptionalPtr<T> {
        if constexpr (alignof(T) > 1) {
            return this->p_align_xcalloc_multi<T>(alignof(T), count);
        } else {
            return this->p_unalign_xcalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto align_calloc(usize alignment,
                                    Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, true, true, false, false, true, false>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a `T` with an alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto align_xcalloc(usize alignment,
                                     Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, true, false, false, true, false>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_align_calloc(usize alignment,
                                      Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this->meta_alloc<T, false, true, true, false, true, true, false>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_align_xcalloc(usize alignment,
                                       Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this
            ->meta_alloc<T, false, false, true, false, true, true, false>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a `T` with no alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto unalign_calloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, true, false, false, false, true, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a `T` with no alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto unalign_xcalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, false, false, false, true, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_unalign_calloc(Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this
            ->meta_alloc<T, false, true, false, false, true, true, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>&&
                     constructibleFrom<T, Args...>)
    [[nodiscard]] auto p_unalign_xcalloc(Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this
            ->meta_alloc<T, false, false, false, false, true, true, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate an array of `T` with alignment guarantee, and zero-out
    // the allocated memory.
    template <typename T>
    [[nodiscard]] auto align_calloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, false, true, true, true, false, true, false>(
            alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] auto align_xcalloc_multi(usize alignment, ssize count) {
        return this
            ->meta_alloc<T, false, false, true, true, false, true, false>(
                alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with an alignment guarantee, and provide a pointer handle, and
    // zero-out the allocated memory.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_calloc_multi(usize alignment, ssize count)
        -> OptionalPtr<T> {
        return this->meta_alloc<T, false, true, true, true, true, true, false>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle, and zero-out
    // the allocated memory.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_xcalloc_multi(usize alignment, ssize count)
        -> T* {
        return this->meta_alloc<T, false, false, true, true, true, true, false>(
            alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee, and zero-out
    // the allocated memory.
    template <typename T>
    [[nodiscard]] auto unalign_calloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, true, true, false>(
            1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] auto unalign_xcalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, true, true, false>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with no alignment guarantee, and provide a pointer handle, and
    // zero-out the allocated memory.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_calloc_multi(ssize count) -> OptionalPtr<T> {
        return this->meta_alloc<T, false, true, false, true, true, true, false>(
            1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle, and zero-out
    // the allocated memory.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_xcalloc_multi(ssize count) -> T* {
        return this
            ->meta_alloc<T, false, false, false, true, true, true, false>(
                1u, count);
    }

    // Try to allocate a small-size optimized `T`, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_calloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_calloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->inline_unalign_calloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Allocate a small-size optimized `T`, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_xcalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xcalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->inline_unalign_xcalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] auto inline_calloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_calloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_calloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] auto inline_xcalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xcalloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_xcalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_align_calloc(usize alignment,
                                           Args&&... constructor_arguments) {
        return this->meta_alloc<T, true, true, true, false, false, true, false>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee, and
    // zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_align_xcalloc(usize alignment,
                                            Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, false, true, false, false, true, false>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_unalign_calloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, true, false, false, false, true, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee, and
    // zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(constructibleFrom<T, Args...>)
    [[nodiscard]] auto inline_unalign_xcalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, false, false, false, false, true, false>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto inline_align_calloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, true, true, true, true, false, true, false>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto inline_align_xcalloc_multi(usize alignment,
                                                  ssize count) {
        return this->meta_alloc<T, true, false, true, true, false, true, false>(
            alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto inline_unalign_calloc_multi(ssize count) {
        return this->meta_alloc<T, true, true, false, true, false, true, false>(
            1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto inline_unalign_xcalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, true, false, false, true, false, true, false>(
                1u, count);
    }

    // Try to allocate a `T`, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto scalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->align_scalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->unalign_scalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Allocate a `T`, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto xscalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->align_xscalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->unalign_xscalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_scalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->p_align_scalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->p_unalign_scalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_xscalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->p_align_xscalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->p_unalign_xscalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Try to allocate an array of `T`, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto scalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_scalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_scalloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto xscalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_xscalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xscalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T`, and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_scalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->p_align_scalloc_multi<T>(alignof(T), count);
        } else {
            return this->p_unalign_scalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`,
    // and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_xscalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->p_align_xscalloc_multi<T>(alignof(T), count);
        } else {
            return this->p_unalign_xscalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee, and return the number
    // of bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto align_scalloc(usize alignment,
                                     Args&&... constructor_arguments) {
        return this->meta_alloc<T, false, true, true, false, false, true, true>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a `T` with an alignment guarantee, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto align_xscalloc(usize alignment,
                                      Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, true, false, false, true, true>(
                alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_scalloc(usize alignment,
                                       Args&&... constructor_arguments) {
        return this->meta_alloc<T, false, true, true, false, true, true, true>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_xscalloc(usize alignment,
                                        Args&&... constructor_arguments) {
        return this->meta_alloc<T, false, false, true, false, true, true, true>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a `T` with no alignment guarantee, and return the number
    // of bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto unalign_scalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, true, false, false, false, true, true>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a `T` with no alignment guarantee, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto unalign_xscalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, false, false, false, true, true>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_scalloc(Args&&... constructor_arguments) {
        return this->meta_alloc<T, false, true, false, false, true, true, true>(
            1u, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_xscalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, false, false, true, true, true>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]] auto align_scalloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, false, true, true, true, false, true, true>(
            alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]] auto align_xscalloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, false, false, true, true, false, true, true>(
            alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with an alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_scalloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, false, true, true, true, true, true, true>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with
    // an alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_xscalloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, false, false, true, true, true, true, true>(
            alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]] auto unalign_scalloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, false, true, true>(
            1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]] auto unalign_xscalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, false, true, true>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with no alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_scalloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, true, true, true>(
            1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with
    // no alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_xscalloc_multi(ssize count) {
        return this->meta_alloc<T, false, false, false, true, true, true, true>(
            1u, count);
    }

    // Try to allocate a small-size optimized `T`, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_scalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_scalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->inline_unalign_scalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Allocate a small-size optimized `T`, and return the number of bytes that
    // were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_xscalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xscalloc<T>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->inline_unalign_xscalloc<T>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`, and return the
    // number of bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_scalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_scalloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_scalloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_xscalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xscalloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_xscalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee,
    // and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_align_scalloc(usize alignment,
                                            Args&&... constructor_arguments) {
        return this->meta_alloc<T, true, true, true, false, false, true, true>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_align_xscalloc(usize alignment,
                                             Args&&... constructor_arguments) {
        return this->meta_alloc<T, true, false, true, false, false, true, true>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee,
    // and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_unalign_scalloc(Args&&... constructor_arguments) {
        return this->meta_alloc<T, true, true, false, false, false, true, true>(
            1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] auto inline_unalign_xscalloc(
        Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, true, false, false, false, false, true, true>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto inline_align_scalloc_multi(usize alignment,
                                                  ssize count) {
        return this->meta_alloc<T, true, true, true, true, false, true, true>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto inline_align_xscalloc_multi(usize alignment,
                                                   ssize count) {
        return this->meta_alloc<T, true, false, true, true, false, true, true>(
            alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto inline_unalign_scalloc_multi(ssize count) {
        return this->meta_alloc<T, true, true, false, true, false, true, true>(
            1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto inline_unalign_xscalloc_multi(ssize count) {
        return this->meta_alloc<T, true, false, false, true, false, true, true>(
            1u, count);
    }

    // Try to move a memory handle from this allocator into another.
    [[nodiscard]] auto realloc_to(allocator auto& allocator,
                                  memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::alloc<T, T>, allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself.
    [[nodiscard]] auto realloc(memoryHandle auto& handle) {
        return this->realloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another.
    template <typename T>
    [[nodiscard]] auto p_realloc_to(allocator auto& allocator, T* p_handle) {
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::p_alloc<T, T>, allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself.
    template <typename T>
    [[nodiscard]] auto p_realloc(T* p_handle) {
        return this->p_realloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another.
    [[nodiscard]] auto xrealloc_to(allocator auto& allocator,
                                   memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::xalloc<T, T>, allocator, handle);
    }

    // Move a memory handle from this allocator into itself.
    [[nodiscard]] auto xrealloc(memoryHandle auto& handle) {
        return this->xrealloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another.
    template <typename T>
    [[nodiscard]] auto p_xrealloc_to(allocator auto& allocator, T* p_handle) {
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::p_xalloc<T, T>, allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself.
    template <typename T>
    [[nodiscard]] auto p_xrealloc(T* p_handle) {
        return this->p_xrealloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee.
    [[nodiscard]] auto align_realloc_to(allocator auto& allocator,
                                        memoryHandle auto& handle,
                                        usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::align_alloc<T, T>, allocator, handle,
            alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee.
    [[nodiscard]] auto align_realloc(memoryHandle auto& handle,
                                     usize alignment) {
        return this->align_realloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee.
    [[nodiscard]] auto align_xrealloc_to(allocator auto& allocator,
                                         memoryHandle auto& handle,
                                         usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::align_xalloc<T, T>, allocator, handle,
            alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee.
    auto align_xrealloc(memoryHandle auto& handle, usize alignment) {
        return this->align_xrealloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee.
    [[nodiscard]] auto unalign_realloc_to(allocator auto& allocator,
                                          memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::unalign_alloc<T, T>, allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee.
    [[nodiscard]] auto unalign_realloc(memoryHandle auto& handle) {
        return this->unalign_realloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee.
    [[nodiscard]] auto unalign_xrealloc_to(allocator auto& allocator,
                                           memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::unalign_xalloc<T, T>, allocator, handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee.
    auto unalign_xrealloc(memoryHandle auto& handle) {
        return this->unalign_xrealloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee.
    [[nodiscard]] auto p_align_realloc_to(allocator auto& allocator,
                                          auto* p_handle, usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::p_align_alloc<T, T>, allocator, p_handle,
            alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee.
    [[nodiscard]] auto p_align_realloc(auto* p_handle, usize alignment) {
        return this->p_align_realloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee.
    [[nodiscard]] auto p_align_xrealloc_to(allocator auto& allocator,
                                           auto* p_handle, usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::p_align_xalloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee.
    auto p_align_xrealloc(auto* p_handle, usize alignment) {
        return this->p_align_xrealloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee.
    [[nodiscard]] auto p_unalign_realloc_to(allocator auto& allocator,
                                            auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::p_unalign_alloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee.
    [[nodiscard]] auto p_unalign_realloc(auto* p_handle) {
        return this->p_unalign_realloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee.
    [[nodiscard]] auto p_unalign_xrealloc_to(allocator auto& allocator,
                                             auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::p_unalign_xalloc<T, T>, allocator,
            p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee.
    auto p_unalign_xrealloc(auto* p_handle) {
        return this->p_unalign_xrealloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another.
    [[nodiscard]] auto realloc_multi_to(allocator auto& allocator,
                                        memoryHandle auto& handle,
                                        ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::alloc_multi<T>, allocator, handle,
            new_count);
    }

    // Try to move an array memory handle from this allocator into itself.
    [[nodiscard]] auto realloc_multi(memoryHandle auto& handle,
                                     ssize new_count) {
        return this->realloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another.
    template <typename T>
    [[nodiscard]] auto p_realloc_multi_to(allocator auto& allocator,
                                          T* p_handle, ssize old_count,
                                          ssize new_count) {
        return this->meta_p_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::p_alloc_multi<T>, allocator, p_handle,
            old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself.
    template <typename T>
    [[nodiscard]] auto p_realloc_multi(T* p_handle, ssize old_count,
                                       ssize new_count) {
        return this->p_realloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another.
    [[nodiscard]] auto xrealloc_multi_to(allocator auto& allocator,
                                         memoryHandle auto& handle,
                                         ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::xalloc_multi<T>, allocator, handle,
            new_count);
    }

    // Move and resize an array memory handle from this allocator into itself.
    [[nodiscard]] auto xrealloc_multi(memoryHandle auto& handle,
                                      ssize new_count) {
        return this->xrealloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another.
    template <typename T>
    [[nodiscard]] auto p_xrealloc_multi_to(allocator auto& allocator,
                                           T* p_handle, ssize old_count,
                                           ssize new_count) {
        return this->meta_p_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::p_xalloc_multi<T>, allocator, p_handle,
            old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself.
    template <typename T>
    [[nodiscard]] auto p_xrealloc_multi(T* p_handle, ssize old_count,
                                        ssize new_count) {
        return this->p_xrealloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another.
    [[nodiscard]] auto align_realloc_multi_to(allocator auto& allocator,
                                              memoryHandle auto& handle,
                                              usize alignment,
                                              ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::align_alloc_multi<T>, allocator, handle,
            new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee.
    [[nodiscard]] auto align_realloc_multi(memoryHandle auto& handle,
                                           usize alignment, ssize new_count) {
        return this->align_realloc_multi_to(*this, handle, alignment,
                                            new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee.
    [[nodiscard]] auto align_xrealloc_multi_to(allocator auto& allocator,
                                               memoryHandle auto& handle,
                                               usize alignment,
                                               ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::align_xalloc_multi<T>, allocator, handle,
            new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee.
    auto align_xrealloc_multi(memoryHandle auto& handle, usize alignment,
                              ssize new_count) {
        return this->align_xrealloc_multi_to(*this, handle, alignment,
                                             new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee.
    [[nodiscard]] auto unalign_realloc_multi_to(allocator auto& allocator,
                                                memoryHandle auto& handle,
                                                ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::unalign_alloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee.
    [[nodiscard]] auto unalign_realloc_multi(memoryHandle auto& handle,
                                             ssize new_count) {
        return this->unalign_realloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee.
    [[nodiscard]] auto unalign_xrealloc_multi_to(allocator auto& allocator,
                                                 memoryHandle auto& handle,
                                                 ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::unalign_xalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee.
    auto unalign_xrealloc_multi(memoryHandle auto& handle, ssize new_count) {
        return this->unalign_xrealloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee.
    [[nodiscard]] auto p_align_realloc_multi_to(allocator auto& allocator,
                                                auto* p_handle, usize alignment,
                                                ssize old_count,
                                                ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::p_align_alloc_multi<T>, allocator,
            p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee.
    [[nodiscard]] auto p_align_realloc_multi(auto* p_handle, usize alignment,
                                             ssize old_count, ssize new_count) {
        return this->p_align_realloc_multi_to(*this, p_handle, alignment,
                                              old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee.
    [[nodiscard]] auto p_align_xrealloc_multi_to(allocator auto& allocator,
                                                 auto* p_handle,
                                                 usize alignment,
                                                 ssize old_count,
                                                 ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::p_align_xalloc_multi<T>, allocator,
            p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee.
    auto p_align_xrealloc_multi(auto* p_handle, usize alignment,
                                ssize old_count, ssize new_count) {
        return this->p_align_xrealloc_multi_to(*this, p_handle, alignment,
                                               old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee.
    [[nodiscard]] auto p_unalign_realloc_multi_to(allocator auto& allocator,
                                                  auto* p_handle,
                                                  ssize old_count,
                                                  ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::p_unalign_alloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee.
    [[nodiscard]] auto p_unalign_realloc_multi(auto* p_handle, ssize old_count,
                                               ssize new_count) {
        return this->p_unalign_realloc_multi_to(*this, p_handle, old_count,
                                                new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee.
    [[nodiscard]] auto p_unalign_xrealloc_multi_to(allocator auto& allocator,
                                                   auto* p_handle,
                                                   ssize old_count,
                                                   ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::p_unalign_xalloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee.
    auto p_unalign_xrealloc_multi(auto* p_handle, ssize old_count,
                                  ssize new_count) {
        return this->p_unalign_xrealloc_multi_to(*this, p_handle, old_count,
                                                 new_count);
    }

    // Try to move a memory handle from this allocator into another, and
    // zero-out the allocated memory.
    [[nodiscard]] auto recalloc_to(allocator auto& allocator,
                                   memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::calloc<T, T>, allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself, and zero-out
    // the allocated memory.
    [[nodiscard]] auto recalloc(memoryHandle auto& handle) {
        return this->recalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto p_recalloc_to(allocator auto& allocator, T* p_handle) {
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::p_calloc<T, T>, allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto p_recalloc(T* p_handle) {
        return this->p_recalloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another, and zero-out the
    // allocated memory.
    [[nodiscard]] auto xrecalloc_to(allocator auto& allocator,
                                    memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::xcalloc<T, T>, allocator, handle);
    }

    // Move a memory handle from this allocator into itself, and zero-out the
    // allocated memory.
    [[nodiscard]] auto xrecalloc(memoryHandle auto& handle) {
        return this->xrecalloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] auto p_xrecalloc_to(allocator auto& allocator, T* p_handle) {
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::p_xcalloc<T, T>, allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] auto p_xrecalloc(T* p_handle) {
        return this->p_xrecalloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto align_recalloc_to(allocator auto& allocator,
                                         memoryHandle auto& handle,
                                         usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::align_calloc<T, T>, allocator, handle,
            alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto align_recalloc(memoryHandle auto& handle,
                                      usize alignment) {
        return this->align_recalloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto align_xrecalloc_to(allocator auto& allocator,
                                          memoryHandle auto& handle,
                                          usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::align_xcalloc<T, T>, allocator, handle,
            alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee, and zero-out the allocated memory.
    auto align_xrecalloc(memoryHandle auto& handle, usize alignment) {
        return this->align_xrecalloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto unalign_recalloc_to(allocator auto& allocator,
                                           memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::unalign_calloc<T, T>, allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto unalign_recalloc(memoryHandle auto& handle) {
        return this->unalign_recalloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto unalign_xrecalloc_to(allocator auto& allocator,
                                            memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::unalign_xcalloc<T, T>, allocator,
            handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee, and zero-out the allocated memory.
    auto unalign_xrecalloc(memoryHandle auto& handle) {
        return this->unalign_xrecalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_align_recalloc_to(allocator auto& allocator,
                                           auto* p_handle, usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::p_align_calloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_align_recalloc(auto* p_handle, usize alignment) {
        return this->p_align_recalloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_align_xrecalloc_to(allocator auto& allocator,
                                            auto* p_handle, usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::p_align_xcalloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee, and zero-out the allocated memory.
    auto p_align_xrecalloc(auto* p_handle, usize alignment) {
        return this->p_align_xrecalloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_unalign_recalloc_to(allocator auto& allocator,
                                             auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::p_unalign_calloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_unalign_recalloc(auto* p_handle) {
        return this->p_unalign_recalloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_unalign_xrecalloc_to(allocator auto& allocator,
                                              auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::p_unalign_xcalloc<T, T>, allocator,
            p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee, and zero-out the allocated memory.
    auto p_unalign_xrecalloc(auto* p_handle) {
        return this->p_unalign_xrecalloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another, and
    // zero-out the allocated memory.
    [[nodiscard]] auto recalloc_multi_to(allocator auto& allocator,
                                         memoryHandle auto& handle,
                                         ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::calloc_multi<T>, allocator, handle,
            new_count);
    }

    // Try to move an array memory handle from this allocator into itself, and
    // zero-out the allocated memory.
    [[nodiscard]] auto recalloc_multi(memoryHandle auto& handle,
                                      ssize new_count) {
        return this->recalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto p_recalloc_multi_to(allocator auto& allocator,
                                           T* p_handle, ssize old_count,
                                           ssize new_count) {
        return this->meta_p_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::p_calloc_multi<T>, allocator, p_handle,
            old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto p_recalloc_multi(T* p_handle, ssize old_count,
                                        ssize new_count) {
        return this->p_recalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and zero-out the allocated memory.
    [[nodiscard]] auto xrecalloc_multi_to(allocator auto& allocator,
                                          memoryHandle auto& handle,
                                          ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::xcalloc_multi<T>, allocator, handle,
            new_count);
    }

    // Move and resize an array memory handle from this allocator into itself,
    // and zero-out the allocated memory.
    [[nodiscard]] auto xrecalloc_multi(memoryHandle auto& handle,
                                       ssize new_count) {
        return this->xrecalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another,
    // and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto p_xrecalloc_multi_to(allocator auto& allocator,
                                            T* p_handle, ssize old_count,
                                            ssize new_count) {
        return this->meta_p_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::p_xcalloc_multi<T>, allocator, p_handle,
            old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself,
    // and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] auto p_xrecalloc_multi(T* p_handle, ssize old_count,
                                         ssize new_count) {
        return this->p_xrecalloc_multi_to(*this, p_handle, old_count,
                                          new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and zero-out the allocated memory.
    [[nodiscard]] auto align_recalloc_multi_to(allocator auto& allocator,
                                               memoryHandle auto& handle,
                                               usize alignment,
                                               ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::align_calloc_multi<T>, allocator, handle,
            new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto align_recalloc_multi(memoryHandle auto& handle,
                                            usize alignment, ssize new_count) {
        return this->align_recalloc_multi_to(*this, handle, alignment,
                                             new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto align_xrecalloc_multi_to(allocator auto& allocator,
                                                memoryHandle auto& handle,
                                                usize alignment,
                                                ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::align_xcalloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee, and zero-out the allocated memory.
    auto align_xrecalloc_multi(memoryHandle auto& handle, usize alignment,
                               ssize new_count) {
        return this->align_xrecalloc_multi_to(*this, handle, alignment,
                                              new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto unalign_recalloc_multi_to(allocator auto& allocator,
                                                 memoryHandle auto& handle,
                                                 ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::unalign_calloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto unalign_recalloc_multi(memoryHandle auto& handle,
                                              ssize new_count) {
        return this->unalign_recalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto unalign_xrecalloc_multi_to(allocator auto& allocator,
                                                  memoryHandle auto& handle,
                                                  ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::unalign_xcalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee, and zero-out the allocated memory.
    auto unalign_xrecalloc_multi(memoryHandle auto& handle, ssize new_count) {
        return this->unalign_xrecalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_align_recalloc_multi_to(allocator auto& allocator,
                                                 auto* p_handle,
                                                 usize alignment,
                                                 ssize old_count,
                                                 ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::p_align_calloc_multi<T>, allocator,
            p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_align_recalloc_multi(auto* p_handle, usize alignment,
                                              ssize old_count,
                                              ssize new_count) {
        return this->p_align_recalloc_multi_to(*this, p_handle, alignment,
                                               old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_align_xrecalloc_multi_to(allocator auto& allocator,
                                                  auto* p_handle,
                                                  usize alignment,
                                                  ssize old_count,
                                                  ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::p_align_xcalloc_multi<T>, allocator,
            p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee, and zero-out the allocated memory.
    auto p_align_xrecalloc_multi(auto* p_handle, usize alignment,
                                 ssize old_count, ssize new_count) {
        return this->p_align_xrecalloc_multi_to(*this, p_handle, alignment,
                                                old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_unalign_recalloc_multi_to(allocator auto& allocator,
                                                   auto* p_handle,
                                                   ssize old_count,
                                                   ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::p_unalign_calloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_unalign_recalloc_multi(auto* p_handle, ssize old_count,
                                                ssize new_count) {
        return this->p_unalign_recalloc_multi_to(*this, p_handle, old_count,
                                                 new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto p_unalign_xrecalloc_multi_to(allocator auto& allocator,
                                                    auto* p_handle,
                                                    ssize old_count,
                                                    ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::p_unalign_xcalloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee, and zero-out the allocated memory.
    auto p_unalign_xrecalloc_multi(auto* p_handle, ssize old_count,
                                   ssize new_count) {
        return this->p_unalign_xrecalloc_multi_to(*this, p_handle, old_count,
                                                  new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another.
    [[nodiscard]] auto inline_realloc_to(allocator auto& allocator,
                                         memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::inline_alloc<T, T>, allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself.
    [[nodiscard]] auto inline_realloc(memoryHandle auto& handle) {
        return this->inline_realloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another.
    [[nodiscard]] auto inline_xrealloc_to(allocator auto& allocator,
                                          memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::inline_xalloc<T, T>, allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself.
    [[nodiscard]] auto inline_xrealloc(memoryHandle auto& handle) {
        return this->inline_xrealloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee.
    [[nodiscard]] auto inline_align_realloc_to(allocator auto& allocator,
                                               memoryHandle auto& handle,
                                               usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::inline_align_alloc<T, T>, allocator,
            handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee.
    [[nodiscard]] auto inline_align_realloc(memoryHandle auto& handle,
                                            usize alignment) {
        return this->inline_align_realloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee.
    [[nodiscard]] auto inline_align_xrealloc_to(allocator auto& allocator,
                                                memoryHandle auto& handle,
                                                usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::inline_align_xalloc<T, T>, allocator,
            handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee.
    auto inline_align_xrealloc(memoryHandle auto& handle, usize alignment) {
        return this->inline_align_xrealloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee.
    [[nodiscard]] auto inline_unalign_realloc_to(allocator auto& allocator,
                                                 memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::inline_unalign_alloc<T, T>, allocator,
            handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee.
    [[nodiscard]] auto inline_unalign_realloc(memoryHandle auto& handle) {
        return this->inline_unalign_realloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee.
    [[nodiscard]] auto inline_unalign_xrealloc_to(allocator auto& allocator,
                                                  memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::inline_unalign_xalloc<T, T>, allocator,
            handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee.
    auto inline_unalign_xrealloc(memoryHandle auto& handle) {
        return this->inline_unalign_xrealloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another.
    [[nodiscard]] auto inline_realloc_multi_to(allocator auto& allocator,
                                               memoryHandle auto& handle,
                                               ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::inline_alloc_multi<T>, allocator, handle,
            new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself.
    [[nodiscard]] auto inline_realloc_multi(memoryHandle auto& handle,
                                            ssize new_count) {
        return this->realloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another.
    [[nodiscard]] auto inline_xrealloc_multi_to(allocator auto& allocator,
                                                memoryHandle auto& handle,
                                                ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::inline_xalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself.
    [[nodiscard]] auto inline_xrealloc_multi(memoryHandle auto& handle,
                                             ssize new_count) {
        return this->inline_xrealloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another.
    [[nodiscard]] auto inline_align_realloc_multi_to(allocator auto& allocator,
                                                     memoryHandle auto& handle,
                                                     usize alignment,
                                                     ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::inline_align_alloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee.
    [[nodiscard]] auto inline_align_realloc_multi(memoryHandle auto& handle,
                                                  usize alignment,
                                                  ssize new_count) {
        return this->inline_align_realloc_multi_to(*this, handle, alignment,
                                                   new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee.
    [[nodiscard]] auto inline_align_xrealloc_multi_to(allocator auto& allocator,
                                                      memoryHandle auto& handle,
                                                      usize alignment,
                                                      ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::inline_align_xalloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee.
    auto inline_align_xrealloc_multi(memoryHandle auto& handle, usize alignment,
                                     ssize new_count) {
        return this->inline_align_xrealloc_multi_to(*this, handle, alignment,
                                                    new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee.
    [[nodiscard]] auto inline_unalign_realloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::inline_unalign_alloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee.
    [[nodiscard]] auto inline_unalign_realloc_multi(memoryHandle auto& handle,
                                                    ssize new_count) {
        return this->inline_unalign_realloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee.
    [[nodiscard]] auto inline_unalign_xrealloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::inline_unalign_xalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee.
    auto inline_unalign_xrealloc_multi(memoryHandle auto& handle,
                                       ssize new_count) {
        return this->inline_unalign_xrealloc_multi_to(*this, handle, new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another, and zero-out the allocated memory.
    [[nodiscard]] auto inline_recalloc_to(allocator auto& allocator,
                                          memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::calloc<T, T>, allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself, and zero-out the allocated memory.
    [[nodiscard]] auto inline_recalloc(memoryHandle auto& handle) {
        return this->inline_recalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another, and
    // zero-out the allocated memory.
    [[nodiscard]] auto inline_xrecalloc_to(allocator auto& allocator,
                                           memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::inline_xcalloc<T, T>, allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself, and
    // zero-out the allocated memory.
    [[nodiscard]] auto inline_xrecalloc(memoryHandle auto& handle) {
        return this->inline_xrecalloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto inline_align_recalloc_to(allocator auto& allocator,
                                                memoryHandle auto& handle,
                                                usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::inline_align_calloc<T, T>, allocator,
            handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto inline_align_recalloc(memoryHandle auto& handle,
                                             usize alignment) {
        return this->inline_align_recalloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto inline_align_xrecalloc_to(allocator auto& allocator,
                                                 memoryHandle auto& handle,
                                                 usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::inline_align_xcalloc<T, T>, allocator,
            handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee, and zero-out the allocated memory.
    auto inline_align_xrecalloc(memoryHandle auto& handle, usize alignment) {
        return this->inline_align_xrecalloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto inline_unalign_recalloc_to(allocator auto& allocator,
                                                  memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &AllocatorFacade<Derived>::inline_unalign_calloc<T, T>, allocator,
            handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto inline_unalign_recalloc(memoryHandle auto& handle) {
        return this->inline_unalign_recalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] auto inline_unalign_xrecalloc_to(allocator auto& allocator,
                                                   memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &AllocatorFacade<Derived>::inline_unalign_xcalloc<T, T>, allocator,
            handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee, and zero-out the allocated memory.
    auto inline_unalign_xrecalloc(memoryHandle auto& handle) {
        return this->inline_unalign_xrecalloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another, and zero-out the allocated memory.
    [[nodiscard]] auto inline_recalloc_multi_to(allocator auto& allocator,
                                                memoryHandle auto& handle,
                                                ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::inline_calloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself, and zero-out the allocated memory.
    [[nodiscard]] auto inline_recalloc_multi(memoryHandle auto& handle,
                                             ssize new_count) {
        return this->inline_recalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and zero-out the allocated memory.
    [[nodiscard]] auto inline_xrecalloc_multi_to(allocator auto& allocator,
                                                 memoryHandle auto& handle,
                                                 ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::inline_xcalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself, and zero-out the allocated memory.
    [[nodiscard]] auto inline_xrecalloc_multi(memoryHandle auto& handle,
                                              ssize new_count) {
        return this->inline_xrecalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and zero-out the allocated memory.
    [[nodiscard]] auto inline_align_recalloc_multi_to(allocator auto& allocator,
                                                      memoryHandle auto& handle,
                                                      usize alignment,
                                                      ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::inline_align_calloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]] auto inline_align_recalloc_multi(memoryHandle auto& handle,
                                                   usize alignment,
                                                   ssize new_count) {
        return this->inline_align_recalloc_multi_to(*this, handle, alignment,
                                                    new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]] auto inline_align_xrecalloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, usize alignment,
        ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::inline_align_xcalloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee, and zero-out the
    // allocated memory.
    auto inline_align_xrecalloc_multi(memoryHandle auto& handle,
                                      usize alignment, ssize new_count) {
        return this->inline_align_xrecalloc_multi_to(*this, handle, alignment,
                                                     new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]] auto inline_unalign_recalloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &AllocatorFacade<Derived>::inline_unalign_calloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]] auto inline_unalign_recalloc_multi(memoryHandle auto& handle,
                                                     ssize new_count) {
        return this->inline_unalign_recalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]] auto inline_unalign_xrecalloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &AllocatorFacade<Derived>::inline_unalign_xcalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee, and zero-out the
    // allocated memory.
    auto inline_unalign_xrecalloc_multi(memoryHandle auto& handle,
                                        ssize new_count) {
        return this->inline_unalign_xrecalloc_multi_to(*this, handle,
                                                       new_count);
    }

    // Try to move a memory handle from this allocator into another, and return
    // the number of bytes that were allocated.
    [[nodiscard]] auto resalloc_to(allocator auto& allocator,
                                   memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::salloc<T, T>, allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself, and return
    // the number of bytes that were allocated.
    [[nodiscard]] auto resalloc(memoryHandle auto& handle) {
        return this->resalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_resalloc_to(allocator auto& allocator, T* p_handle) {
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::p_salloc<T, T>, allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_resalloc(T* p_handle) {
        return this->p_resalloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto xresalloc_to(allocator auto& allocator,
                                    memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::xalloc<T, T>, allocator, handle);
    }

    // Move a memory handle from this allocator into itself, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto xresalloc(memoryHandle auto& handle) {
        return this->xresalloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another, and return the
    // number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_xresalloc_to(allocator auto& allocator, T* p_handle) {
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::p_xalloc<T, T>, allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself, and return the
    // number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_xresalloc(T* p_handle) {
        return this->p_xresalloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto align_resalloc_to(allocator auto& allocator,
                                         memoryHandle auto& handle,
                                         usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::align_salloc<T, T>, allocator, handle,
            alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto align_resalloc(memoryHandle auto& handle,
                                      usize alignment) {
        return this->align_resalloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto align_xresalloc_to(allocator auto& allocator,
                                          memoryHandle auto& handle,
                                          usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::align_xalloc<T, T>, allocator, handle,
            alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee, and return the number of bytes that were allocated.
    auto align_xresalloc(memoryHandle auto& handle, usize alignment) {
        return this->align_xresalloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto unalign_resalloc_to(allocator auto& allocator,
                                           memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::unalign_salloc<T, T>, allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto unalign_resalloc(memoryHandle auto& handle) {
        return this->unalign_resalloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto unalign_xresalloc_to(allocator auto& allocator,
                                            memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::unalign_xalloc<T, T>, allocator, handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee, and return the number of bytes that were allocated.
    auto unalign_xresalloc(memoryHandle auto& handle) {
        return this->unalign_xresalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto p_align_resalloc_to(allocator auto& allocator,
                                           auto* p_handle, usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::p_align_salloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto p_align_resalloc(auto* p_handle, usize alignment) {
        return this->p_align_resalloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto p_align_xresalloc_to(allocator auto& allocator,
                                            auto* p_handle, usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::p_align_xalloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee, and return the number of bytes that were allocated.
    auto p_align_xresalloc(auto* p_handle, usize alignment) {
        return this->p_align_xresalloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto p_unalign_resalloc_to(allocator auto& allocator,
                                             auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::p_unalign_salloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto p_unalign_resalloc(auto* p_handle) {
        return this->p_unalign_resalloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] auto p_unalign_xresalloc_to(allocator auto& allocator,
                                              auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::p_unalign_xalloc<T, T>, allocator,
            p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee, and return the number of bytes that were allocated.
    auto p_unalign_xresalloc(auto* p_handle) {
        return this->p_unalign_xresalloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another, and return
    // the number of bytes that were allocated.
    [[nodiscard]] auto resalloc_multi_to(allocator auto& allocator,
                                         memoryHandle auto& handle,
                                         ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::salloc_multi<T>, allocator, handle,
            new_count);
    }

    // Try to move an array memory handle from this allocator into itself, and
    // return the number of bytes that were allocated.
    [[nodiscard]] auto resalloc_multi(memoryHandle auto& handle,
                                      ssize new_count) {
        return this->resalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_resalloc_multi_to(allocator auto& allocator,
                                           T* p_handle, ssize old_count,
                                           ssize new_count) {
        return this->meta_p_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::p_salloc_multi<T>, allocator, p_handle,
            old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_resalloc_multi(T* p_handle, ssize old_count,
                                        ssize new_count) {
        return this->p_resalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto xresalloc_multi_to(allocator auto& allocator,
                                          memoryHandle auto& handle,
                                          ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::xsalloc_multi<T>, allocator, handle,
            new_count);
    }

    // Move and resize an array memory handle from this allocator into itself,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto xresalloc_multi(memoryHandle auto& handle,
                                       ssize new_count) {
        return this->xresalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another,
    // and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_xresalloc_multi_to(allocator auto& allocator,
                                            T* p_handle, ssize old_count,
                                            ssize new_count) {
        return this->meta_p_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::p_xsalloc_multi<T>, allocator, p_handle,
            old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself,
    // and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_xresalloc_multi(T* p_handle, ssize old_count,
                                         ssize new_count) {
        return this->p_xresalloc_multi_to(*this, p_handle, old_count,
                                          new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto align_resalloc_multi_to(allocator auto& allocator,
                                               memoryHandle auto& handle,
                                               usize alignment,
                                               ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::align_salloc_multi<T>, allocator, handle,
            new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto align_resalloc_multi(memoryHandle auto& handle,
                                            usize alignment, ssize new_count) {
        return this->align_resalloc_multi_to(*this, handle, alignment,
                                             new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto align_xresalloc_multi_to(allocator auto& allocator,
                                                memoryHandle auto& handle,
                                                usize alignment,
                                                ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::align_xsalloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    auto align_xresalloc_multi(memoryHandle auto& handle, usize alignment,
                               ssize new_count) {
        return this->align_xresalloc_multi_to(*this, handle, alignment,
                                              new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto unalign_resalloc_multi_to(allocator auto& allocator,
                                                 memoryHandle auto& handle,
                                                 ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::unalign_salloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto unalign_resalloc_multi(memoryHandle auto& handle,
                                              ssize new_count) {
        return this->unalign_resalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto unalign_xresalloc_multi_to(allocator auto& allocator,
                                                  memoryHandle auto& handle,
                                                  ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::unalign_xsalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    auto unalign_xresalloc_multi(memoryHandle auto& handle, ssize new_count) {
        return this->unalign_xresalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto p_align_resalloc_multi_to(allocator auto& allocator,
                                                 auto* p_handle,
                                                 usize alignment,
                                                 ssize old_count,
                                                 ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::p_align_salloc_multi<T>, allocator,
            p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto p_align_resalloc_multi(auto* p_handle, usize alignment,
                                              ssize old_count,
                                              ssize new_count) {
        return this->p_align_resalloc_multi_to(*this, p_handle, alignment,
                                               old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto p_align_xresalloc_multi_to(allocator auto& allocator,
                                                  auto* p_handle,
                                                  usize alignment,
                                                  ssize old_count,
                                                  ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::p_align_xsalloc_multi<T>, allocator,
            p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    auto p_align_xresalloc_multi(auto* p_handle, usize alignment,
                                 ssize old_count, ssize new_count) {
        return this->p_align_xresalloc_multi_to(*this, p_handle, alignment,
                                                old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto p_unalign_resalloc_multi_to(allocator auto& allocator,
                                                   auto* p_handle,
                                                   ssize old_count,
                                                   ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::p_unalign_salloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto p_unalign_resalloc_multi(auto* p_handle, ssize old_count,
                                                ssize new_count) {
        return this->p_unalign_resalloc_multi_to(*this, p_handle, old_count,
                                                 new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto p_unalign_xresalloc_multi_to(allocator auto& allocator,
                                                    auto* p_handle,
                                                    ssize old_count,
                                                    ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::p_unalign_xsalloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    auto p_unalign_xresalloc_multi(auto* p_handle, ssize old_count,
                                   ssize new_count) {
        return this->p_unalign_xresalloc_multi_to(*this, p_handle, old_count,
                                                  new_count);
    }

    // Try to move a memory handle from this allocator into another, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] auto rescalloc_to(allocator auto& allocator,
                                    memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::scalloc<T, T>, allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] auto rescalloc(memoryHandle auto& handle) {
        return this->rescalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_rescalloc_to(allocator auto& allocator, T* p_handle) {
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::p_scalloc<T, T>, allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_rescalloc(T* p_handle) {
        return this->p_rescalloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] auto xrescalloc_to(allocator auto& allocator,
                                     memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::xscalloc<T, T>, allocator, handle);
    }

    // Move a memory handle from this allocator into itself, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] auto xrescalloc(memoryHandle auto& handle) {
        return this->xrescalloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_xrescalloc_to(allocator auto& allocator, T* p_handle) {
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::p_xscalloc<T, T>, allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_xrescalloc(T* p_handle) {
        return this->p_xrescalloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto align_rescalloc_to(allocator auto& allocator,
                                          memoryHandle auto& handle,
                                          usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::align_scalloc<T, T>, allocator, handle,
            alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto align_rescalloc(memoryHandle auto& handle,
                                       usize alignment) {
        return this->align_rescalloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] auto align_xrescalloc_to(allocator auto& allocator,
                                           memoryHandle auto& handle,
                                           usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::align_xscalloc<T, T>, allocator, handle,
            alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto align_xrescalloc(memoryHandle auto& handle, usize alignment) {
        return this->align_xrescalloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto unalign_rescalloc_to(allocator auto& allocator,
                                            memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::unalign_scalloc<T, T>, allocator,
            handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto unalign_rescalloc(memoryHandle auto& handle) {
        return this->unalign_rescalloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] auto unalign_xrescalloc_to(allocator auto& allocator,
                                             memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::unalign_xscalloc<T, T>, allocator,
            handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto unalign_xrescalloc(memoryHandle auto& handle) {
        return this->unalign_xrescalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto p_align_rescalloc_to(allocator auto& allocator,
                                            auto* p_handle, usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::p_align_scalloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto p_align_rescalloc(auto* p_handle, usize alignment) {
        return this->p_align_rescalloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] auto p_align_xrescalloc_to(allocator auto& allocator,
                                             auto* p_handle, usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::p_align_xscalloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto p_align_xrescalloc(auto* p_handle, usize alignment) {
        return this->p_align_xrescalloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto p_unalign_rescalloc_to(allocator auto& allocator,
                                              auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::p_unalign_scalloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto p_unalign_rescalloc(auto* p_handle) {
        return this->p_unalign_rescalloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] auto p_unalign_xrescalloc_to(allocator auto& allocator,
                                               auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::p_unalign_xscalloc<T, T>, allocator,
            p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto p_unalign_xrescalloc(auto* p_handle) {
        return this->p_unalign_xrescalloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] auto rescalloc_multi_to(allocator auto& allocator,
                                          memoryHandle auto& handle,
                                          ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::scalloc_multi<T>, allocator, handle,
            new_count);
    }

    // Try to move an array memory handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto rescalloc_multi(memoryHandle auto& handle,
                                       ssize new_count) {
        return this->rescalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    template <typename T>
    [[nodiscard]] auto p_rescalloc_multi_to(allocator auto& allocator,
                                            T* p_handle, ssize old_count,
                                            ssize new_count) {
        return this->meta_p_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::p_scalloc_multi<T>, allocator, p_handle,
            old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself, zero-out the allocated memory, and return the number of bytes
    // that were allocated.
    template <typename T>
    [[nodiscard]] auto p_rescalloc_multi(T* p_handle, ssize old_count,
                                         ssize new_count) {
        return this->p_rescalloc_multi_to(*this, p_handle, old_count,
                                          new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto xrescalloc_multi_to(allocator auto& allocator,
                                           memoryHandle auto& handle,
                                           ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::xscalloc_multi<T>, allocator, handle,
            new_count);
    }

    // Move and resize an array memory handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto xrescalloc_multi(memoryHandle auto& handle,
                                        ssize new_count) {
        return this->xrescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    template <typename T>
    [[nodiscard]] auto p_xrescalloc_multi_to(allocator auto& allocator,
                                             T* p_handle, ssize old_count,
                                             ssize new_count) {
        return this->meta_p_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::p_xscalloc_multi<T>, allocator, p_handle,
            old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    template <typename T>
    [[nodiscard]] auto p_xrescalloc_multi(T* p_handle, ssize old_count,
                                          ssize new_count) {
        return this->p_xrescalloc_multi_to(*this, p_handle, old_count,
                                           new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto align_rescalloc_multi_to(allocator auto& allocator,
                                                memoryHandle auto& handle,
                                                usize alignment,
                                                ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::align_scalloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto align_rescalloc_multi(memoryHandle auto& handle,
                                             usize alignment, ssize new_count) {
        return this->align_rescalloc_multi_to(*this, handle, alignment,
                                              new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] auto align_xrescalloc_multi_to(allocator auto& allocator,
                                                 memoryHandle auto& handle,
                                                 usize alignment,
                                                 ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::align_xscalloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto align_xrescalloc_multi(memoryHandle auto& handle, usize alignment,
                                ssize new_count) {
        return this->align_xrescalloc_multi_to(*this, handle, alignment,
                                               new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto unalign_rescalloc_multi_to(allocator auto& allocator,
                                                  memoryHandle auto& handle,
                                                  ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::unalign_scalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto unalign_rescalloc_multi(memoryHandle auto& handle,
                                               ssize new_count) {
        return this->unalign_rescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] auto unalign_xrescalloc_multi_to(allocator auto& allocator,
                                                   memoryHandle auto& handle,
                                                   ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::unalign_xscalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto unalign_xrescalloc_multi(memoryHandle auto& handle, ssize new_count) {
        return this->unalign_xrescalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto p_align_rescalloc_multi_to(allocator auto& allocator,
                                                  auto* p_handle,
                                                  usize alignment,
                                                  ssize old_count,
                                                  ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::p_align_scalloc_multi<T>, allocator,
            p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto p_align_rescalloc_multi(auto* p_handle, usize alignment,
                                               ssize old_count,
                                               ssize new_count) {
        return this->p_align_rescalloc_multi_to(*this, p_handle, alignment,
                                                old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] auto p_align_xrescalloc_multi_to(allocator auto& allocator,
                                                   auto* p_handle,
                                                   usize alignment,
                                                   ssize old_count,
                                                   ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::p_align_xscalloc_multi<T>, allocator,
            p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto p_align_xrescalloc_multi(auto* p_handle, usize alignment,
                                  ssize old_count, ssize new_count) {
        return this->p_align_xrescalloc_multi_to(*this, p_handle, alignment,
                                                 old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto p_unalign_rescalloc_multi_to(allocator auto& allocator,
                                                    auto* p_handle,
                                                    ssize old_count,
                                                    ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::p_unalign_scalloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto p_unalign_rescalloc_multi(auto* p_handle,
                                                 ssize old_count,
                                                 ssize new_count) {
        return this->p_unalign_rescalloc_multi_to(*this, p_handle, old_count,
                                                  new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] auto p_unalign_xrescalloc_multi_to(allocator auto& allocator,
                                                     auto* p_handle,
                                                     ssize old_count,
                                                     ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_p_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::p_unalign_xscalloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto p_unalign_xrescalloc_multi(auto* p_handle, ssize old_count,
                                    ssize new_count) {
        return this->p_unalign_xrescalloc_multi_to(*this, p_handle, old_count,
                                                   new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another, and return the number of bytes that were allocated.
    [[nodiscard]] auto inline_resalloc_to(allocator auto& allocator,
                                          memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::inline_salloc<T, T>, allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself, and return the number of bytes that were allocated.
    [[nodiscard]] auto inline_resalloc(memoryHandle auto& handle) {
        return this->inline_resalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another, and
    // return the number of bytes that were allocated.
    [[nodiscard]] auto inline_xresalloc_to(allocator auto& allocator,
                                           memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::inline_xalloc<T, T>, allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself, and
    // return the number of bytes that were allocated.
    [[nodiscard]] auto inline_xresalloc(memoryHandle auto& handle) {
        return this->inline_xresalloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto inline_align_resalloc_to(allocator auto& allocator,
                                                memoryHandle auto& handle,
                                                usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::inline_align_salloc<T, T>, allocator,
            handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto inline_align_resalloc(memoryHandle auto& handle,
                                             usize alignment) {
        return this->inline_align_resalloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto inline_align_xresalloc_to(allocator auto& allocator,
                                                 memoryHandle auto& handle,
                                                 usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::inline_align_xalloc<T, T>, allocator,
            handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee, and return the number of bytes that were
    // allocated.
    auto inline_align_xresalloc(memoryHandle auto& handle, usize alignment) {
        return this->inline_align_xresalloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] auto inline_unalign_resalloc_to(allocator auto& allocator,
                                                  memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::inline_unalign_salloc<T, T>, allocator,
            handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto inline_unalign_resalloc(memoryHandle auto& handle) {
        return this->inline_unalign_resalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto inline_unalign_xresalloc_to(allocator auto& allocator,
                                                   memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::inline_unalign_xalloc<T, T>, allocator,
            handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee, and return the number of bytes that were
    // allocated.
    auto inline_unalign_xresalloc(memoryHandle auto& handle) {
        return this->inline_unalign_xresalloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another, and return the number of bytes that were allocated.
    [[nodiscard]] auto inline_resalloc_multi_to(allocator auto& allocator,
                                                memoryHandle auto& handle,
                                                ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::inline_salloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto inline_resalloc_multi(memoryHandle auto& handle,
                                             ssize new_count) {
        return this->resalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto inline_xresalloc_multi_to(allocator auto& allocator,
                                                 memoryHandle auto& handle,
                                                 ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::inline_xsalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto inline_xresalloc_multi(memoryHandle auto& handle,
                                              ssize new_count) {
        return this->inline_xresalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto inline_align_resalloc_multi_to(allocator auto& allocator,
                                                      memoryHandle auto& handle,
                                                      usize alignment,
                                                      ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::inline_align_salloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto inline_align_resalloc_multi(memoryHandle auto& handle,
                                                   usize alignment,
                                                   ssize new_count) {
        return this->inline_align_resalloc_multi_to(*this, handle, alignment,
                                                    new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee, and return the number
    // of bytes that were allocated.
    [[nodiscard]] auto inline_align_xresalloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, usize alignment,
        ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::inline_align_xsalloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee, and return the number
    // of bytes that were allocated.
    auto inline_align_xresalloc_multi(memoryHandle auto& handle,
                                      usize alignment, ssize new_count) {
        return this->inline_align_xresalloc_multi_to(*this, handle, alignment,
                                                     new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto inline_unalign_resalloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::inline_unalign_salloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto inline_unalign_resalloc_multi(memoryHandle auto& handle,
                                                     ssize new_count) {
        return this->inline_unalign_resalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee, and return the number
    // of bytes that were allocated.
    [[nodiscard]] auto inline_unalign_xresalloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::inline_unalign_xsalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee, and return the number
    // of bytes that were allocated.
    auto inline_unalign_xresalloc_multi(memoryHandle auto& handle,
                                        ssize new_count) {
        return this->inline_unalign_xresalloc_multi_to(*this, handle,
                                                       new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] auto inline_rescalloc_to(allocator auto& allocator,
                                           memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::scalloc<T, T>, allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself, zero-out the allocated memory, and return the number of bytes
    // that were allocated.
    [[nodiscard]] auto inline_rescalloc(memoryHandle auto& handle) {
        return this->inline_rescalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto inline_xrescalloc_to(allocator auto& allocator,
                                            memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::inline_xscalloc<T, T>, allocator,
            handle);
    }

    // Move a small-size optimized handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that were
    // allocated.
    [[nodiscard]] auto inline_xrescalloc(memoryHandle auto& handle) {
        return this->inline_xrescalloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto inline_align_rescalloc_to(allocator auto& allocator,
                                                 memoryHandle auto& handle,
                                                 usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::inline_align_scalloc<T, T>, allocator,
            handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] auto inline_align_rescalloc(memoryHandle auto& handle,
                                              usize alignment) {
        return this->inline_align_rescalloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto inline_align_xrescalloc_to(allocator auto& allocator,
                                                  memoryHandle auto& handle,
                                                  usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::inline_align_xscalloc<T, T>, allocator,
            handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    auto inline_align_xrescalloc(memoryHandle auto& handle, usize alignment) {
        return this->inline_align_xrescalloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] auto inline_unalign_rescalloc_to(allocator auto& allocator,
                                                   memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &AllocatorFacade<Derived>::inline_unalign_scalloc<T, T>, allocator,
            handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] auto inline_unalign_rescalloc(memoryHandle auto& handle) {
        return this->inline_unalign_rescalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto inline_unalign_xrescalloc_to(allocator auto& allocator,
                                                    memoryHandle auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &AllocatorFacade<Derived>::inline_unalign_xscalloc<T, T>, allocator,
            handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    auto inline_unalign_xrescalloc(memoryHandle auto& handle) {
        return this->inline_unalign_xrescalloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] auto inline_rescalloc_multi_to(allocator auto& allocator,
                                                 memoryHandle auto& handle,
                                                 ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::inline_scalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto inline_rescalloc_multi(memoryHandle auto& handle,
                                              ssize new_count) {
        return this->inline_rescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto inline_xrescalloc_multi_to(allocator auto& allocator,
                                                  memoryHandle auto& handle,
                                                  ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::inline_xscalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto inline_xrescalloc_multi(memoryHandle auto& handle,
                                               ssize new_count) {
        return this->inline_xrescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] auto inline_align_rescalloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, usize alignment,
        ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::inline_align_scalloc_multi<T>, allocator,
            handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] auto inline_align_rescalloc_multi(memoryHandle auto& handle,
                                                    usize alignment,
                                                    ssize new_count) {
        return this->inline_align_rescalloc_multi_to(*this, handle, alignment,
                                                     new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] auto inline_align_xrescalloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, usize alignment,
        ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::inline_align_xscalloc_multi<T>,
            allocator, handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    auto inline_align_xrescalloc_multi(memoryHandle auto& handle,
                                       usize alignment, ssize new_count) {
        return this->inline_align_xrescalloc_multi_to(*this, handle, alignment,
                                                      new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] auto inline_unalign_rescalloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &AllocatorFacade<Derived>::inline_unalign_scalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] auto inline_unalign_rescalloc_multi(memoryHandle auto& handle,
                                                      ssize new_count) {
        return this->inline_unalign_rescalloc_multi_to(*this, handle,
                                                       new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] auto inline_unalign_xrescalloc_multi_to(
        allocator auto& allocator, memoryHandle auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &AllocatorFacade<Derived>::inline_unalign_xscalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    auto inline_unalign_xrescalloc_multi(memoryHandle auto& handle,
                                         ssize new_count) {
        return this->inline_unalign_xrescalloc_multi_to(*this, handle,
                                                        new_count);
    }

    // Invalidate any memory handle, invoking its data's destructor.
    template <memoryHandle T>
    void free(T const& handle) {
        using Allocation = typename T::Allocation const;

        // If this is not a small-size optimized handle:
        if (!handle.is_inline()) {
            Allocation const* p_memory;
            if constexpr (T::is_multi_handle) {
                // Get the pointer from a span produced by the
                // allocator.
                p_memory = this->get(handle).p_data();
            } else {
                // Get the pointer from the allocator.
                p_memory = addressof(this->get(handle));
            }

            // if constexpr (is_destructible<Allocation>) {
            for (ssize i = 0; i < handle.size(); ++i) {
                p_memory[i.raw].~Allocation();
            }
            // }
            this->self().deallocate(static_cast<void const*>(p_memory),
                                    handle.raw_size());
        }
        // If this is not small-size optimized, it will be freed at the
        // end of the stack frame, so this function call is no-op.
    };

    // TODO: This needs unit tests.
    // Invalidate a pointer handle to a `T`, and call its destructor.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    void free(T* p_memory) {
        // if constexpr (is_destructible<T>) {
        p_memory->~T();
        // }
        this->self().deallocate(static_cast<void const*>(p_memory),
                                ssizeof<T>());
    }

    // Invalidate a pointer handle to an array of `T`, and call its
    // destructors.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    void free_multi(T* p_memory, ssize count) {
        // if constexpr (is_destructible<T>) {
        for (ssize i = 0; i < count; ++i) {
            p_memory[i.raw].~T();
        }
        // }
        this->self().deallocate(static_cast<void const*>(p_memory),
                                ssizeof<T>() * count);
    }

    template <memoryHandle T>
    void cfree(T& handle) {
        free(handle);
        zero_memory_explicit(addressof(this->get(handle)), handle.raw_size());
    }

    template <typename T>
    void cfree(T* p_handle) {
        free(p_handle);
        zero_memory_explicit(p_handle, ssizeof<T>());
    }

    template <typename T>
    void cfree_multi(T* p_handle, ssize count) {
        free(p_handle, count);
        zero_memory_explicit(p_handle, count * ssizeof<T>());
    }

    // Get a non-`const` reference to the data in any memory handle.
    template <memoryHandle T>
    [[nodiscard]] auto get(T& handle) & -> decltype(auto) {
        using Allocation = typename T::Allocation;
        if constexpr (T::is_inline_handle) {
            // Get small-size optimized data:
            if (handle.is_inline()) {
                if constexpr (T::is_multi_handle) {
                    return Span<Allocation>{addressof(handle.get_inline()),
                                            handle.size()};
                } else {
                    return handle.get_inline();
                }
            }
        }

        // Get non-small-size optimized data:
        if constexpr (T::is_multi_handle) {
            return Span<Allocation>(
                this->self().template access<Allocation>(handle.get()),
                handle.size());
        } else {
            return *(this->self().template access<Allocation>(handle.get()));
        }
    }

    // Get a `const` reference to the data in any memory handle.
    template <memoryHandle T>
    [[nodiscard]] auto get(T const& memory) & -> decltype(auto) {
        return unconst(this)->get(unconst(memory));
    }

    // Get a non-`const` reference to the data in any pointer handle.
    template <typename T>
    [[nodiscard]] auto get(T* p_handle) & -> T& {
        return *p_handle;
    }

    // Get a `const` reference to the data in any pointer handle.
    template <typename T>
    [[nodiscard]] auto get(T const* p_handle) & -> T& {
        return *p_handle;
    }

    // If the allocator does not over-ride a `.reset()` method, produce a
    // no-op.
    void reset() {
    }

  private:
    constexpr auto self() -> Derived& {
        return static_cast<Derived&>(*this);
    }

    template <typename T, bool is_inline, bool is_fail_safe, bool is_aligned,
              bool is_multiple, bool is_pointer, bool is_zeroed,
              bool has_feedback, typename... Args>
        requires(
            // Inline allocations cannot produce pointers.
            !(is_inline && is_pointer)
            // Multi-allocations must be default-constructed.
            && !(is_multiple && (sizeof...(Args) > 0))
            // TODO: Zeroed-out allocations should not have arguments.
            // Zeroed-out allocations must be trivial.
            && !(is_zeroed && !is_trivial<T>))
    [[gnu::optimize("-fno-tree-loop-distribute-patterns")]] auto meta_alloc(
        usize allocation_alignment, ssize allocation_count,
        Args&&... constructor_arguments) {
        ssize const allocation_size = allocation_count * ssizeof<T>();

        // Produce a basic handle for this memory type.
        using UnderlyingHandle =
            decltype(this->self().template make_handle<T>(declval<T*>()));

        // Get the return value of a user-supplied `.allocate()`. This must be
        // some kind of `Optional`. It holds some data that can pass into a
        // `Handle`'s constructor.
        using MaybeAllocation =
            Conditional<has_feedback, OptionalSizedAllocation<void*>,
                        OptionalPtr<void>>;

        // Produce an appropriate handle type for this allocation.
        using Handle = Conditional<
            is_multiple,
            detail::MultiMemoryHandle<Conditional<
                is_inline,
                // If this an array of small-size optimized `T`:
                detail::InlineMemoryHandle<UnderlyingHandle>,
                // If this is an array of not small-size optimized `T`:
                UnderlyingHandle>>,
            Conditional<is_inline,
                        // If this a small-size optimized `T`:
                        detail::InlineMemoryHandle<UnderlyingHandle>,
                        // If this is not a small-size optimized `T`:
                        UnderlyingHandle>>;

        using ReturnHandle =
            Conditional<is_fail_safe,
                        Conditional<is_pointer,
                                    Conditional<has_feedback,
                                                // Failsafe pointer with size.
                                                OptionalSizedAllocation<T*>,
                                                // Failsafe pointer w/out size.
                                                OptionalPtr<T>>,
                                    // Not a pointer:
                                    Conditional<has_feedback,
                                                // Failsafe opaque handle with
                                                // size.
                                                OptionalSizedAllocation<Handle>,
                                                // Failsafe opaque handle w/out
                                                // size.
                                                Optional<Handle>>>,
                        // Not fail-safe:
                        Conditional<is_pointer,
                                    Conditional<has_feedback,
                                                // Unsafe pointer with size.
                                                SizedAllocation<T*>,
                                                // Unsafe pointer w/out size.
                                                T*>,
                                    Conditional<has_feedback,
                                                // Unsafe opaque handle with
                                                // size.
                                                SizedAllocation<Handle>,
                                                // Unsafe opaque memory handle
                                                // w/out size.
                                                Handle>>>;

        if constexpr (is_inline) {
            if (allocation_size < inline_buffer_size) {
                // Allocate memory on this stack frame.
                Handle stack_handle;
                stack_handle.set_inlined(true);
                stack_handle.set_count(allocation_count);

                if constexpr (is_zeroed) {
                    zero_memory(addressof(stack_handle), inline_buffer_size);
                }

                if constexpr (is_multiple) {
                    for (ssize i = 0; i < allocation_count; ++i) {
                        construct_at(
                            static_cast<T*>(static_cast<void*>(&stack_handle)) +
                            i);
                    }
                } else {
                    stack_handle.set_inline_storage(
                        T{forward<Args>(constructor_arguments)...});
                }

                // Return here to skip error handling, because an on-stack
                // allocation cannot fail.
                if constexpr (has_feedback) {
                    return ReturnHandle{SizedAllocation<Handle>{
                        move(stack_handle), inline_buffer_size}};
                } else {
                    return ReturnHandle{move(stack_handle)};
                }
            }
        }

        // If this allocation is not small-size optimized, or is larger than
        // `inline_buffer_size`:

        // Make an allocation.
        MaybeAllocation maybe_memory;

        if constexpr (is_aligned) {
            if constexpr (has_feedback) {
                if constexpr (detail::HasAlignedAllocateFeedback<Derived>) {
                    // Call `.aligned_allocate_feedback()` function for
                    // optimized size-feedback.
                    maybe_memory = this->self().aligned_allocate_feedback(
                        allocation_alignment, allocation_size);
                } else {
                    if constexpr (detail::HasAllocationSize<Derived>) {
                        // If a `.aligned_allocate_feedback()` is not provided,
                        // use `.allocation_size`().
                        Optional size = this->self().allocation_size(
                            allocation_alignment, allocation_size);
                        if (size.has_value()) {
                            maybe_memory = OptionalSizedAllocation<void*>{
                                this->self()
                                    .aligned_allocate(allocation_alignment,
                                                      allocation_size)
                                    // If `.allocation_size()` succeeded, this
                                    // will not fail.
                                    .value(),
                                size.value()};
                        } else {
                            maybe_memory = nullopt;
                        }
                    } else {
                        // If a `.allocation_size()` is not provided, simply
                        // assume that it allocates `allocation_size`.
                        Optional temp_memory = this->self().aligned_allocate(
                            allocation_alignment, allocation_size);
                        if (temp_memory.has_value()) {
                            maybe_memory = OptionalSizedAllocation<void*>{
                                temp_memory.value(), allocation_size};
                        } else {
                            maybe_memory = nullopt;
                        }
                    };
                }
            } else {
                maybe_memory = this->self().aligned_allocate(
                    allocation_alignment, allocation_size);
            }
        } else {
            if constexpr (has_feedback) {
                if constexpr (detail::HasAllocateFeedback<Derived>) {
                    // Call `.allocate_feedback()` function for optimized
                    // size-feedback.
                    maybe_memory =
                        this->self().allocate_feedback(allocation_size);
                } else {
                    if constexpr (detail::HasAlignedAllocateFeedback<Derived>) {
                        // If `.allocate_feedback()` is not provided, but
                        // `.aligned_allocate_feedback()` is, fall back to that
                        // with alignment of `1u`.
                        maybe_memory = this->self().aligned_allocate_feedback(
                            1u, allocation_size);
                    } else if constexpr (detail::HasAllocationSize<Derived>) {
                        // If a `.aligned_allocate_feedback()` is not provided,
                        // use `.allocation_size`().
                        Optional size =
                            this->self().allocation_size(1u, allocation_size);

                        if (size.has_value()) {
                            maybe_memory = OptionalSizedAllocation<void*>{
                                // If `.allocation_size()` succeeded, this will
                                // not fail.
                                this->self().allocate(allocation_size).value(),
                                size.value()};
                        } else {
                            maybe_memory = nullopt;
                        }
                    } else {
                        // If a `.allocation_size()` is also not provided,
                        // simply assume that it allocates `allocation_size`.
                        auto temp_memory = this->self().aligned_allocate(
                            allocation_alignment, allocation_size);
                        if (temp_memory.has_value()) {
                            maybe_memory = OptionalSizedAllocation<void*>{
                                temp_memory.value(), allocation_size};
                        } else {
                            maybe_memory = nullopt;
                        }
                    };
                }
            } else {
                // Otherwise, make an allocation without size feedback.
                if constexpr (detail::HasAllocate<Derived>) {
                    maybe_memory = this->self().allocate(allocation_size);
                } else {
                    // If `.allocate` is not provided, implement it in terms of
                    // `.aligned_allocate()`.
                    maybe_memory =
                        this->self().allocate_aligned(1u, allocation_size);
                }
            }
        }

        if constexpr (is_fail_safe) {
            if (!maybe_memory.has_value()) {
                // Return an empty optional if this failed to allocate.
                return ReturnHandle{nullopt};
            }
        }

        T* p_allocation;
        if constexpr (has_feedback) {
            // The `.first()` element of the `SizedAllocation` tuple is a
            // `void*`.
            p_allocation = static_cast<T*>(maybe_memory.value().first());
        } else {
            p_allocation = static_cast<T*>(maybe_memory.value());
        }

        if constexpr (is_zeroed) {
            zero_memory(p_allocation, allocation_size);
        }

        // Construct the `T`s inside the allocator.
        for (ssize i = 0; i < allocation_count; ++i) {
            construct_at(p_allocation + i,
                         forward<Args>(constructor_arguments)...);
        }

        if constexpr (is_pointer) {
            if constexpr (has_feedback) {
                return ReturnHandle{SizedAllocation<T*>{
                    p_allocation, maybe_memory.value().second()}};
            } else {
                return ReturnHandle{p_allocation};
            }
        } else {
            UnderlyingHandle const raw_handle =
                this->self().template make_handle<T>(p_allocation);
            Handle handle{move(raw_handle)};

            if constexpr (is_inline) {
                handle.set_inlined(false);
            }

            if constexpr (is_multiple) {
                handle.set_count(allocation_count);
            }

            if constexpr (has_feedback) {
                return ReturnHandle(SizedAllocation<Handle>{
                    move(handle), maybe_memory.value().second()});
            } else {
                return ReturnHandle{move(handle)};
            }
        }
    }

    // Take a generic allocation method, invoke it on an allocator with a
    // generic memory handle, and free the original handle if that allocation
    // suceeded.
    template <bool is_fail_safe, bool has_feedback, typename... Args>
    auto meta_realloc(auto function, allocator auto& allocator, auto& handle,
                      Args&&... arguments) {
        using Allocation = decltype((&allocator->*function)(
            forward<Args>(arguments)..., move(this->get(handle))));
        Allocation allocation;
        allocation = (&allocator->*function)(
            // Possible alignment and/or count arguments.
            forward<Args>(arguments)...,
            // Move the data from this handle.
            move(this->get(handle)));

        if constexpr (is_fail_safe) {
            if (!allocation.has_value()) {
                return allocation;
            }
        }

        this->free(handle);
        return allocation;
    }

    // Copy data from `handle` into `allocation`.
    void relocate_handle(memoryHandle auto& handle, auto allocation) {
        if constexpr (is_trivially_relocatable<int>) {
            copy_memory(addressof(this->get(handle)), addressof(allocation),
                        handle.raw_size());
        } else {
            for (ssize i = 0; i < handle.size(); ++i) {
                *(addressof(this->get(allocation)) + i) =
                    move(*(addressof(this->get(handle)) + i));
            }
        }
    }

    // Copy data from `p_handle` into `p_allocation`.
    void relocate_pointer_handle(auto* p_handle, auto* p_allocation,
                                 ssize count) {
        if constexpr (is_trivially_relocatable<decltype(*p_allocation)>) {
            copy_memory(p_handle, p_allocation, count);
        } else {
            for (ssize i = 0; i < count; ++i) {
                *(p_allocation + i) = move(*(p_handle + i));
            }
        }
    }

    template <bool is_fail_safe, bool has_feedback, typename... Args>
    auto meta_realloc_multi(auto function, allocator auto& allocator,
                            auto& handle, ssize count,
                            Args&&... maybe_alignment) {
        using Allocation = decltype((&allocator->*function)(
            forward<Args>(maybe_alignment)..., count));
        Allocation allocation;
        allocation =
            (&allocator->*function)(forward<Args>(maybe_alignment)..., count);
        if constexpr (is_fail_safe) {
            if constexpr (has_feedback) {
                if (!allocation.has_value()) {
                    return allocation;
                }
                this->relocate_handle(handle, allocation.value().first());
            } else {
                if (!allocation.has_value()) {
                    return allocation;
                }
                this->relocate_handle(handle, allocation.value());
            }
        } else {
            if constexpr (has_feedback) {
                this->relocate_handle(handle, allocation.first());
            } else {
                this->relocate_handle(handle, allocation);
            }
        }

        this->free(handle);
        return allocation;
    }

    template <bool is_fail_safe, bool has_feedback, typename... Args>
    auto meta_p_realloc_multi(auto function, allocator auto& allocator,
                              auto& handle, ssize old_count, ssize new_count,
                              Args&&... maybe_alignment) {
        using Allocation = decltype((&allocator->*function)(
            forward<Args>(maybe_alignment)..., new_count));
        Allocation allocation;
        allocation = (&allocator->*function)(forward<Args>(maybe_alignment)...,
                                             new_count);
        if constexpr (is_fail_safe) {
            if constexpr (has_feedback) {
                if (!allocation.has_value()) {
                    return allocation;
                }
                this->relocate_pointer_handle(
                    handle, allocation.value().first(), old_count);
            } else {
                if (!allocation.has_value()) {
                    return allocation;
                }
                this->relocate_pointer_handle(handle, allocation.value(),
                                              old_count);
            }
        } else {
            if constexpr (has_feedback) {
                this->relocate_pointer_handle(handle, allocation.first(),
                                              old_count);
            } else {
                this->relocate_pointer_handle(handle, allocation, old_count);
            }
        }

        this->free(handle);
        return allocation;
    }
};

}  // namespace cat
