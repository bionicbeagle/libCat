// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/collection>
#include <memory>

#include "cat/meta"

namespace cat {

template <typename InputIterator, typename OutputIterator>
auto copy(InputIterator source_begin, InputIterator source_end,
          OutputIterator destination_begin) -> OutputIterator {
    while (source_begin != source_end) {
        *destination_begin = *source_begin;
        ++source_begin;
    }
}

template <typename InputIterator, typename OutputIterator>
auto move(InputIterator source_begin, InputIterator source_end,
          OutputIterator destination_begin) -> OutputIterator {
    while (source_begin != source_end) {
        *destination_begin = move(*source_begin);
        ++source_begin;
    }
}

template <typename InputIterator, typename OutputIterator>
auto relocate(InputIterator source_begin, InputIterator source_end,
              OutputIterator destination_begin) -> OutputIterator {
    using SourceCollection = typename decltype(source_begin)::Collection;
    using SourceElement = decltype(*source_begin);

    using DestinationCollection =
        typename decltype(destination_begin)::Collection;
    using DestinationElement = decltype(*destination_begin);

    // If the source and destination containers are contiguous, and they hold
    // the same element type, and that type is trivially relocatable, copy them
    // fast.
    if constexpr (CollectionTraits<SourceCollection>::is_array_like &&
                  CollectionTraits<DestinationCollection>::is_array_like &&
                  is_same<SourceElement, DestinationElement> &&
                  is_trivially_relocatable<SourceElement>) {
        copy_memory(
            addressof(*source_begin), addressof(*destination_begin),
            (source_end - source_begin) * ssizeof<decltype(*source_begin)>);
    } else {
        while (source_begin != source_end) {
            // Otherwise, if the destination can be moved to, do so.
            if constexpr (is_move_assignable<DestinationElement>) {
                *destination_begin =
                    move(static_cast<DestinationElement>(*source_begin));
            } else {
                // Otherwise, copy to the destination.
                *destination_begin =
                    static_cast<DestinationElement>(*source_begin);
            }

            ++source_begin;
            ++destination_begin;
        }
    }
    return destination_begin;
}

}  // namespace cat
