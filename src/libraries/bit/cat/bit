// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once
#include <cat/meta>

// `__BYTE_ORDER__` and `__ORDER_LITTLE_ENDIAN__` are macros defined by GCC.
inline constexpr bool is_target_little_endian =
    (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__);
inline constexpr bool is_target_big_endian = !is_target_little_endian;

namespace cat {

template <is_unsigned_integral T>
[[nodiscard]]
constexpr auto countl_zero(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);

    if (raw_value == 0) {
        // It is undefined behavior to pass 0 into clz.
        return ssizeof(T) * 8;
    }

    // `clz()` is a portable intrinsic.

    if constexpr (sizeof(raw_value) == 4) {
        return __builtin_clz(raw_value);
    } else if constexpr (sizeof(raw_value) == 8) {
        return __builtin_clzll(raw_value);
    } else {
        while (raw_value >>= 1) {
            ++raw_value;
        }
        return ssizeof(T) - raw_value;
    }
}

template <is_unsigned_integral T>
[[nodiscard]]
constexpr auto countl_one(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);
    return raw_value != limits<T>::max()
               ? countl_zero(static_cast<T>(~(raw_value)))
               : (ssizeof(T) * 8);
}

template <is_unsigned_integral T>
[[nodiscard]]
constexpr auto countr_zero(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);

    if (raw_value == 0) {
        // It is undefined behavior to pass 0 into ctz.
        return ssizeof(T) * 8;
    }

    // `ctz()` is a portable intrinsic.

    if constexpr (sizeof(raw_value) <= 4) {
        return __builtin_ctz(raw_value);
    } else if constexpr (sizeof(raw_value) == 8) {
        return __builtin_ctzll(raw_value);
    }
}

template <is_unsigned_integral T>
[[nodiscard]]
constexpr auto countr_one(T value) -> ssize {
    return value != limits<T>::max() ? countl_one(static_cast<T>(~value))
                                     : (ssizeof(T) * 8);
}

template <is_unsigned_integral T>
[[nodiscard]]
constexpr auto popcount(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);
    if constexpr (__has_builtin(__builtin_popcount)) {
        if constexpr (sizeof(T) <= 4) {
            return __builtin_popcount(raw_value);
        } else {
            return __builtin_popcountll(raw_value);
        }
    } else {
        // This should only be used if there is no intrinsic, otherwise integers
        // promote to `unsigned int` for `__builtin_popcount()`.
        ssize result = 0;
        for (; raw_value; raw_value >>= 1) {
            result += ssize(raw_value & 1u);
        }

        return result;
    }
}

}  // namespace cat

namespace x64 {
// Extracts `length` number of bits out of `from`, ending at the `offset` of the
// right-most bit. Those `length` bits are then the right-most bits of the
// return value.
template <cat::is_unsigned T>
[[nodiscard]]
constexpr auto extract_bits(T from, cat::is_unsigned_integral auto offset,
                            cat::is_unsigned_integral auto length) -> T {
    auto raw_from = cat::to_raw_arithmetic(from);
    auto raw_offset = cat::to_raw_arithmetic(offset);
    auto raw_length = cat::to_raw_arithmetic(length);

    if constexpr (__has_builtin(__builtin_ia32_bextr_u32) && sizeof(T) == 4) {
        return T(
            __builtin_ia32_bextr_u32(raw_from, raw_offset | (raw_length << 8)));
    } else if constexpr (__has_builtin(__builtin_ia32_bextr_u64) &&
                         sizeof(T) == 8) {
        return T(
            __builtin_ia32_bextr_u64(raw_from, raw_offset | (raw_length << 8)));
    }
    constexpr unsigned char bits = sizeof(T) * 8u;
    auto const mask = T((1u << raw_length) * (raw_length < bits) - 1u).raw;
    return T((raw_from >> raw_offset) & (mask * (raw_offset < bits)));
}

// Extract the 1 bits from `value` which are also 1 at the same index in `mask`.
template <cat::is_unsigned_integral T, cat::is_unsigned_integral U>
    requires(sizeof(T) == sizeof(U))
[[nodiscard]]
constexpr auto extract_bits_mask(T value, U mask) -> T {
    T result = T(0u);
    auto raw_value = cat::to_raw_arithmetic(value);
    auto raw_mask = cat::to_raw_arithmetic(mask);

    if constexpr (__has_builtin(_pext_u32) && sizeof(T) == 4) {
        // `_pext_u32()` is a GCC intrinsic.
        return T(_pext_u32(raw_value, raw_mask));
    } else if constexpr (__has_builtin(_pext_u64) && sizeof(T) == 8) {
        // `_pext_u64()` is a GCC intrinsic.
        return T(_pext_u64(raw_value, raw_mask));
    } else {
        cat::to_raw_arithmetic_type<T> count = 0u;
        while (raw_mask != 0u) {
            if (raw_mask & 1) {
                result >>= 1;
                result |= raw_value << T(sizeof(T) * 8u - 1u);
                ++count;
            }
            raw_value >>= 1;
            raw_mask >>= 1;
        }

        result >>= (sizeof(T) * 8u - count) * (count > 0u);
        return result;
    }
}

// Place the bits set by `mask` into the right-most bits in the return value.
template <cat::is_unsigned_integral T, cat::is_unsigned_integral U>
    requires(sizeof(T) == sizeof(U))
[[nodiscard]]
constexpr auto deposit_bits_mask(T value, U mask) -> T {
    T result = T(0u);
    auto raw_value = cat::to_raw_arithmetic(value);
    auto raw_mask = cat::to_raw_arithmetic(mask);

    if constexpr (__has_builtin(_pdep_u32) && sizeof(T) == 4) {
        // `_pdep_u32()` is a GCC intrinsic.
        return T(_pdep_u32(raw_value, raw_mask));
    } else if constexpr (__has_builtin(_pdep_u64) && sizeof(T) == 8) {
        // `_pdep_u64()` is a GCC intrinsic.
        return T(_pdep_u64(raw_value, raw_mask));
    } else {
        T count = T(0u);
        while (raw_mask != 0u) {
            result >>= 1;
            if (raw_mask & 1) {
                result |= raw_value << T(sizeof(T) * 8u - 1u);
                raw_value >>= 1;
            }
            raw_mask >>= 1;
            ++count;
        }

        result >>= T(sizeof(T) * 8u - count) * T(count > 0u);
        return result;
    }
}

template <cat::is_unsigned_integral T>
[[nodiscard]]
constexpr auto zero_high_bits_at(T source, uint4 bit_index) -> T {
    if constexpr (__has_builtin(__builtin_ia32_bzhi_si) && sizeof(T) == 4) {
        return __builtin_ia32_bzhi_si(cat::to_raw_arithmetic(source),
                                      bit_index.raw);
    } else if constexpr (__has_builtin(__builtin_ia32_bzhi_di) &&
                         sizeof(T) == 8) {
        return __builtin_ia32_bzhi_di(cat::to_raw_arithmetic(source),
                                      bit_index.raw);
    } else {
        // TODO: Implement this.
        __builtin_unreachable();
    }
}

}  // namespace x64

namespace cat {

class bit_value;
class bit_ptr;

template <is_unsigned_integral storage_type>
class bit_reference {
  private:
    friend bit_value;

    // This constructor is only used by the static factory functions.
    constexpr bit_reference(storage_type& in_storage, storage_type in_mask)
        : storage(in_storage), bitmask(in_mask){};

  public:
    constexpr bit_reference(bit_reference<storage_type> const& other)
        : storage(other.storage), bitmask(other.bitmask){};

    template <is_integral T>
    static constexpr auto from_offset(storage_type& reference, T offset)
        -> bit_reference {
        return bit_reference(reference,
                             storage_type(1u << make_unsigned(offset)));
    }

    static constexpr auto from_mask(storage_type& reference, storage_type mask)
        -> bit_reference {
        return bit_reference(reference, mask);
    }

    // Assign a true or false value to this bit.
    constexpr auto operator=(bool value) -> bit_reference& {
        this->assign(value);
        return *this;
    }

    // Convert this bit to a true or false value.
    constexpr operator bool() const {
        return this->is_set();
    }

    // Assign a true or false value to this bit.
    constexpr auto assign(bool value) -> bit_reference& {
        return value ? this->set() : this->unset();
    }

    // Assign another bit's value to this bit.
    template <is_unsigned_integral T>
    constexpr auto assign(bit_reference<T> other) -> bit_reference& {
        return this->assign(other.is_set());
    }

    // Flag this bit on.
    constexpr auto set() -> bit_reference& {
        this->storage |= this->bitmask;
        return *this;
    }

    // Flag this bit off.
    constexpr auto unset() -> bit_reference& {
        this->storage &= ~(this->bitmask);
        return *this;
    }

    // Flag this bit as the opposite of its current state.
    constexpr auto flip() -> bit_reference& {
        this->storage ^= this->bitmask;
        return *this;
    }

    [[nodiscard]]
    constexpr auto is_set() const -> bool {
        // These constructors are called explicitly in case `0u` cannot
        // implicitly convert to `storage_type`.
        return storage_type(this->storage & this->bitmask) != storage_type(0u);
    }

    constexpr auto mask() const -> remove_cv<storage_type> {
        return this->bitmask;
        return *this;
    }

  private:
    storage_type& storage;
    remove_cv<storage_type> bitmask;
};

class bit_value {
  public:
    template <is_unsigned_integral>
    friend class bit_reference;

    constexpr bit_value() = default;

    constexpr bit_value(bit_value const& other) = default;

    template <is_unsigned_integral T>
    constexpr bit_value(bit_reference<T> reference)
        : value(reference.is_set()) {
    }

    constexpr bit_value(bool other) : value(other) {
    }

    constexpr auto operator=(bit_value const& other) -> bit_value& = default;

    template <is_unsigned_integral T>
    constexpr auto operator=(bit_reference<T> other) -> bit_value& {
        this->value = other.is_set();
        return *this;
    }

    constexpr auto operator=(bool other) -> bit_value& {
        this->value = other;
        return *this;
    }

    // Implicitly convert to `bool`.
    constexpr operator bool() const {
        return this->value;
    }

    constexpr friend auto operator==(bit_value const& self,
                                     bit_value const& other) -> bool {
        return self.value == other.value;
    }

    constexpr friend auto operator&(bit_value const& self,
                                    bit_value const& other) -> bit_value {
        return static_cast<bool>(static_cast<unsigned char>(self.value) &
                                 static_cast<unsigned char>(other.value));
    }

    constexpr auto operator&=(bit_value const& other) -> bit_value& {
        this->value &= other.value;
        return *this;
    }

    constexpr friend auto operator|(bit_value const& self,
                                    bit_value const& other) -> bit_value {
        return static_cast<bool>(static_cast<unsigned char>(self.value) |
                                 static_cast<unsigned char>(other.value));
    }

    constexpr auto operator|=(bit_value const& other) -> bit_value& {
        this->value |= other.value;
        return *this;
    }

    constexpr friend auto operator^(bit_value const& self,
                                    bit_value const& other) -> bit_value {
        return static_cast<bool>(static_cast<unsigned char>(self.value) ^
                                 static_cast<unsigned char>(other.value));
    }

    constexpr auto operator^=(bit_value const& other) -> bit_value& {
        this->value ^= static_cast<unsigned char>(other.value);
        return *this;
    }

    constexpr auto operator~() const -> bit_value {
        bit_value bit = !this->value;
        return bit;
    }

    constexpr void assign(bit_value const& input) {
        this->value = input.value;
    }

    template <is_unsigned_integral T>
    constexpr void assign(bit_reference<T> input) {
        this->value = input.is_set();
    }

    constexpr void assign(bool input) {
        this->value = input;
    }

    // Flag this bit on.
    constexpr auto set() -> bit_value& {
        this->value = true;
        return *this;
    }

    // Flag this bit off.
    constexpr auto unset() -> bit_value& {
        this->value = false;
        return *this;
    }

    // Flag this bit as the opposite of its current state.
    constexpr auto flip() -> bit_value& {
        this->value = !this->value;
        return *this;
    }

    [[nodiscard]]
    constexpr auto is_set() const -> bool {
        return this->value;
    }

  private:
    bool value;
};

[[nodiscard]]
constexpr auto invert_endianess(is_unsigned_integral auto value) {
    auto raw_value = to_raw_arithmetic(value);

    if constexpr (sizeof(raw_value) == 1) {
        // This does not exist.
        // return __builtin_bswap8(raw_value);

        // TODO: Implement this.
        __builtin_unreachable();
    }
    if constexpr (sizeof(raw_value) == 2) {
        return __builtin_bswap16(raw_value);
    }
    if constexpr (sizeof(raw_value) == 4) {
        return __builtin_bswap32(raw_value);
    }
    if constexpr (sizeof(raw_value) == 8) {
        return __builtin_bswap64(raw_value);
    }
}

// If `value` is a power of two.
template <is_arithmetic T>
[[nodiscard]]
constexpr auto has_single_bit(T value) -> bool {
    return (value & (value - T(1))) == T(0);
}

// `byte` is a strongly-typed `struct` rather than an `enum class` so that it
// has operators.
// TODO: Add some member functions.
struct byte {
    unsigned char value;

    constexpr byte() = default;

    constexpr byte(auto input)
        requires(sizeof(input) == 1)
        : value(input) {
    }

    constexpr byte(auto const& input)
        requires(sizeof(input) == 1)
        : value(input) {
    }

    template <rvalue T>
        requires(sizeof(T) == 1)
    constexpr byte(T&& input) : value(forward<T>(input)) {  // NOLINT
    }

    [[nodiscard]] constexpr operator char() const {
        return static_cast<char>(this->value);
    }

    [[nodiscard]] constexpr operator unsigned char() const {
        return static_cast<unsigned char>(this->value);
    }

    [[nodiscard]] constexpr operator signed char() const {
        return static_cast<signed char>(this->value);
    }

    template <typename T>
    [[nodiscard]] constexpr explicit operator T()
        requires(sizeof(T) == 1)
    {
        return bit_cast<T>(value);
    }

    [[nodiscard]]
    constexpr auto
    operator&(is_integral auto from) -> byte {
        return this->value & from;
    }

    constexpr auto operator&=(is_integral auto from) -> byte& {
        this->value = this->value & from;
        return *this;
    }

    [[nodiscard]]
    constexpr auto
    operator|(is_integral auto from) -> byte {
        return this->value | from;
    }

    constexpr auto operator|=(is_integral auto from) -> byte& {
        this->value = this->value | from;
        return *this;
    }

    [[nodiscard]]
    constexpr auto
    operator<<(is_integral auto from) -> byte {
        return this->value << from;
    }

    constexpr auto operator<<=(is_integral auto from) -> byte& {
        this->value = this->value << from;
        return *this;
    }

    [[nodiscard]]
    constexpr auto
    operator>>(is_integral auto from) -> byte {
        return this->value >> from;
    }

    constexpr auto operator>>=(is_integral auto from) -> byte& {
        this->value = this->value >> from;
        return *this;
    }
};

// TODO: Support `volatile` qualified pointers.
// TODO: Aligned pointer types and alignment casts.
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4201.html

template <typename U>
[[nodiscard]]
constexpr auto is_aligned(U* p_value, usize alignment) -> bool;

template <typename U>
[[nodiscard]]
constexpr auto is_aligned(uintptr<U> p_value, usize alignment) -> bool;

template <typename U>
[[nodiscard]]
constexpr auto align_up(U* p_value, usize alignment) -> U*;
template <typename U>
constexpr auto align_up(uintptr<U> p_value, usize alignment) -> uintptr<U>;

template <typename U>
[[nodiscard]]
constexpr auto align_down(U* p_value, usize alignment) -> U*;

template <typename U>
[[nodiscard]]
constexpr auto align_down(intptr<U> p_value, usize alignment) -> intptr<U>;

template <typename U>
[[nodiscard]]
constexpr auto align_down(uintptr<U> p_value, usize alignment) -> uintptr<U>;

template <is_integral T>
[[nodiscard]]
constexpr auto has_single_bit(T value) -> bool {
    return (value & (value - 1)) == 0;
}

template <typename>
struct enum_flag_trait : false_trait {};

template <typename T>
concept is_enum_flag = enum_flag_trait<T>::value;

}  // namespace cat

template <cat::is_enum_flag T>
[[nodiscard]]
constexpr auto
operator|(T flag_1, T flag_2) -> T {
    using U = cat::underlying_type<T>;
    return static_cast<T>(static_cast<U>(flag_1) | static_cast<U>(flag_2));
}

template <cat::is_enum_flag T>
[[nodiscard]]
constexpr auto
operator|(T flag_1, cat::underlying_type<T> flag_2) -> T {
    using U = cat::underlying_type<T>;
    return static_cast<T>(static_cast<U>(flag_1) | flag_2);
}

template <cat::is_enum_flag T>
[[nodiscard]]
constexpr auto
operator&(T flag_1, T flag_2) -> T {
    using U = cat::underlying_type<T>;
    return static_cast<T>(static_cast<U>(flag_1) & static_cast<U>(flag_2));
}

// TODO: Fix bit flag operators.
// template <EnumFlag T>
//[[nodiscard]] constexpr auto operator&(T flag_1,underlying_type<T>
// flag_2) -> T {
//     using U =underlying_type<T>;
//     return static_cast<T>(static_cast<U>(flag_1) & flag_2);
// }

// TODO: Is `<cat/bit>` the right place for these?
constexpr auto operator""_ki(unsigned long long input) -> ssize {
    return 1024 * static_cast<signed long long>(input);
}

constexpr auto operator""_uki(unsigned long long input) -> usize {
    return 1024u * input;
}

constexpr auto operator""_ki(long double input) -> ssize {
    return static_cast<signed long long>(1024.f * input);
}

constexpr auto operator""_mi(unsigned long long input) -> ssize {
    return 1024ll * 1024ll * static_cast<signed long long>(input);
}

constexpr auto operator""_umi(unsigned long long input) -> usize {
    return 1024ull * 1024ull * input;
}

constexpr auto operator""_mi(long double input) -> ssize {
    return static_cast<signed long long>(1024.f * 1024.f * input);
}

constexpr auto operator""_gi(unsigned long long input) -> ssize {
    return 1024ll * 1024ll * 1024ll * static_cast<signed long long>(input);
}

constexpr auto operator""_ugi(unsigned long long input) -> usize {
    return 1024ull * 1024ull * 1024ull * input;
}

constexpr auto operator""_gi(long double input) -> ssize {
    return static_cast<signed long long>(1024.f * 1024.f * 1024.f * 1024.f *
                                         input);
}

#include "./implementations/align_down.tpp"
#include "./implementations/align_up.tpp"
#include "./implementations/is_aligned.tpp"
