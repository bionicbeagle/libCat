// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once
#include <cat/meta>

// `__BYTE_ORDER__` and `__ORDER_LITTLE_ENDIAN__` are macros defined by GCC.
inline constexpr bool is_target_little_endian =
    (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__);
inline constexpr bool is_target_big_endian = !is_target_little_endian;

namespace cat {

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto countl_zero(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);

    if (raw_value == 0) {
        // It is undefined behavior to pass 0 into clz.
        return ssizeof(T) * 8;
    }

    // `clz()` is a portable intrinsic.

    if constexpr (sizeof(raw_value) == 4) {
        return __builtin_clz(raw_value);
    } else if constexpr (sizeof(raw_value) == 8) {
        return __builtin_clzll(raw_value);
    } else {
        while (raw_value >>= 1) {
            ++raw_value;
        }
        return ssizeof(T) - raw_value;
    }
}

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto countl_one(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);
    return raw_value != limits<T>::max()
               ? countl_zero(static_cast<T>(~(raw_value)))
               : (ssizeof(T) * 8);
}

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto countr_zero(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);

    if (raw_value == 0) {
        // It is undefined behavior to pass 0 into ctz.
        return ssizeof(T) * 8;
    }

    // `ctz()` is a portable intrinsic.

    if constexpr (sizeof(raw_value) <= 4) {
        return __builtin_ctz(raw_value);
    } else if constexpr (sizeof(raw_value) == 8) {
        return __builtin_ctzll(raw_value);
    }
}

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto countr_one(T value) -> ssize {
    return value != limits<T>::max() ? countl_one(static_cast<T>(~value))
                                     : (ssizeof(T) * 8);
}

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto popcount(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);
    if constexpr (__has_builtin(__builtin_popcount)) {
        if constexpr (sizeof(T) <= 4) {
            return __builtin_popcount(raw_value);
        } else {
            return __builtin_popcountll(raw_value);
        }
    } else {
        // This should only be used if there is no intrinsic, otherwise integers
        // promote to `unsigned int` for `__builtin_popcount()`.
        ssize result = 0;
        for (; raw_value; raw_value >>= 1) {
            result += ssize(raw_value & 1u);
        }

        return result;
    }
}

// Extracts `length` number of bits out of `from`, ending at the `offset` of the
// right-most bit. Those `length` bits are then the right-most bits of the
// return value.
template <is_unsigned T>
[[nodiscard]] constexpr auto extract_bits(T from,
                                          is_unsigned_integral auto offset,
                                          is_unsigned_integral auto length)
    -> T {
    auto raw_from = to_raw_arithmetic(from);
    auto raw_offset = to_raw_arithmetic(offset);
    auto raw_length = to_raw_arithmetic(length);

    if (__has_builtin(__builtin_ia32_bextr_u32) && sizeof(T) == 4) {
        return T(
            __builtin_ia32_bextr_u32(raw_from, raw_offset | (raw_length << 8)));
    } else if (__has_builtin(__builtin_ia32_bextr_u64) && sizeof(T) == 8) {
        return T(
            __builtin_ia32_bextr_u64(raw_from, raw_offset | (raw_length << 8)));
    } else {
        constexpr unsigned char bits = sizeof(T) * 8u;
        auto const mask = T((1u << raw_length) * (raw_length < bits) - 1u).raw;
        return T((raw_from >> raw_offset) & (mask * (raw_offset < bits)));
    }
}

// Extract the 1 bits from `value` which are also 1 at the same index in `mask`.
template <is_unsigned_integral T, is_unsigned_integral U>
    requires(sizeof(T) == sizeof(U))
[[nodiscard]] constexpr auto extract_bits_mask(T value, U mask) -> T {
    T result = T(0u);
    auto raw_value = to_raw_arithmetic(value);
    auto raw_mask = to_raw_arithmetic(mask);

    if constexpr (__has_builtin(_pext_u32) && sizeof(T) == 4) {
        // `_pext_u32()` is a GCC intrinsic.
        return T(_pext_u32(raw_value, raw_mask));
    } else if constexpr (__has_builtin(_pext_u64) && sizeof(T) == 8) {
        // `_pext_u64()` is a GCC intrinsic.
        return T(_pext_u64(raw_value, raw_mask));
    } else {
        to_raw_arithmetic_t<T> count = 0u;
        while (raw_mask != 0u) {
            if (raw_mask & 1) {
                result >>= 1;
                result |= raw_value << T(sizeof(T) * 8u - 1u);
                ++count;
            }
            raw_value >>= 1;
            raw_mask >>= 1;
        }

        result >>= (sizeof(T) * 8u - count) * (count > 0u);
        return result;
    }
}

// Place the bits set by `mask` into the right-most bits in the return value.
template <is_unsigned_integral T, is_unsigned_integral U>
    requires(sizeof(T) == sizeof(U))
[[nodiscard]] constexpr auto deposit_bits_mask(T value, U mask) -> T {
    T result = T(0u);
    auto raw_value = to_raw_arithmetic(value);
    auto raw_mask = to_raw_arithmetic(mask);

    if constexpr (__has_builtin(_pdep_u32) && sizeof(T) == 4) {
        // `_pdep_u32()` is a GCC intrinsic.
        return T(_pdep_u32(raw_value, raw_mask));
    } else if constexpr (__has_builtin(_pdep_u64) && sizeof(T) == 8) {
        // `_pdep_u64()` is a GCC intrinsic.
        return T(_pdep_u64(raw_value, raw_mask));
    } else {
        T count = T(0u);
        while (raw_mask != 0u) {
            result >>= 1;
            if (raw_mask & 1) {
                result |= raw_value << T(sizeof(T) * 8u - 1u);
                raw_value >>= 1;
            }
            raw_mask >>= 1;
            ++count;
        }

        result >>= T(sizeof(T) * 8u - count) * T(count > 0u);
        return result;
    }
}

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto zero_high_bits_at(T source, uint4 bit_index) -> T {
    if constexpr (__has_builtin(__builtin_ia32_bzhi_si) && sizeof(T) == 4) {
        return __builtin_ia32_bzhi_si(to_raw_arithmetic(source), bit_index.raw);
    } else if constexpr (__has_builtin(__builtin_ia32_bzhi_di) &&
                         sizeof(T) == 8) {
        return __builtin_ia32_bzhi_di(to_raw_arithmetic(source), bit_index.raw);
    } else {
        // TODO: Implement this.
        __builtin_unreachable();
    }
}

[[nodiscard]] constexpr auto invert_endianess(is_unsigned_integral auto value) {
    auto raw_value = to_raw_arithmetic(value);

    if constexpr (sizeof(raw_value) == 1) {
        // This does not exist.
        // return __builtin_bswap8(raw_value);

        // TODO: Implement this.
        __builtin_unreachable();
    }
    if constexpr (sizeof(raw_value) == 2) {
        return __builtin_bswap16(raw_value);
    }
    if constexpr (sizeof(raw_value) == 4) {
        return __builtin_bswap32(raw_value);
    }
    if constexpr (sizeof(raw_value) == 8) {
        return __builtin_bswap64(raw_value);
    }
}

// If `value` is a power of two.
template <is_arithmetic T>
[[nodiscard]] constexpr auto has_single_bit(T value) -> bool {
    return (value & (value - T(1))) == T(0);
}

// `byte` is a strongly-typed `struct` rather than an `enum class` so that it
// has operators.
// TODO: Add some member functions.
struct byte {
    unsigned char value;

    constexpr byte() = default;

    constexpr byte(auto input) requires(sizeof(input) == 1) {
        this->value = input;
    }

    constexpr byte(auto const& input) requires(sizeof(input) == 1) {
        this->value = input;
    }

    template <typename T>
        requires(sizeof(T) == 1)
    constexpr byte(T&& input) {
        this->value = forward<T>(input);
    }

    [[nodiscard]] constexpr operator char() const {
        return static_cast<char>(this->value);
    }

    [[nodiscard]] constexpr operator unsigned char() const {
        return static_cast<unsigned char>(this->value);
    }

    [[nodiscard]] constexpr operator signed char() const {
        return static_cast<signed char>(this->value);
    }

    template <typename T>
    [[nodiscard]] constexpr explicit operator T() requires(sizeof(T) == 1) {
        return bit_cast<T>(value);
    }

    [[nodiscard]] constexpr auto operator&(is_integral auto from) -> byte {
        return this->value & from;
    }
    constexpr auto operator&=(is_integral auto from) -> byte& {
        this->value = this->value & from;
        return *this;
    }

    [[nodiscard]] constexpr auto operator|(is_integral auto from) -> byte {
        return this->value | from;
    }
    constexpr auto operator|=(is_integral auto from) -> byte& {
        this->value = this->value | from;
        return *this;
    }

    [[nodiscard]] constexpr auto operator<<(is_integral auto from) -> byte {
        return this->value << from;
    }
    constexpr auto operator<<=(is_integral auto from) -> byte& {
        this->value = this->value << from;
        return *this;
    }

    [[nodiscard]] constexpr auto operator>>(is_integral auto from) -> byte {
        return this->value >> from;
    }
    constexpr auto operator>>=(is_integral auto from) -> byte& {
        this->value = this->value >> from;
        return *this;
    }
};

// TODO: Support `volatile` qualified pointers.
// TODO: Aligned pointer types and alignment casts.
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4201.html

template <typename U>
[[nodiscard]] constexpr auto is_aligned(U* p_value, usize alignment) -> bool;

template <typename U>
[[nodiscard]] constexpr auto is_aligned(uintptr<U> p_value, usize alignment)
    -> bool;

template <typename U>
[[nodiscard]] constexpr auto align_up(U* p_value, usize alignment) -> U*;
template <typename U>
constexpr auto align_up(uintptr<U> p_value, usize alignment) -> uintptr<U>;

template <typename U>
[[nodiscard]] constexpr auto align_down(U* p_value, usize alignment) -> U*;

template <typename U>
[[nodiscard]] constexpr auto align_down(intptr<U> p_value, usize alignment)
    -> intptr<U>;

template <typename U>
[[nodiscard]] constexpr auto align_down(uintptr<U> p_value, usize alignment)
    -> uintptr<U>;

template <is_integral T>
[[nodiscard]] constexpr auto has_single_bit(T value) -> bool {
    return (value & (value - 1)) == 0;
}

template <typename>
struct enum_flag_trait : false_trait {};

template <typename T>
concept is_enum_flag = enum_flag_trait<T>::value;

}  // namespace cat

template <cat::is_enum_flag T>
[[nodiscard]] constexpr auto operator|(T flag_1, T flag_2) -> T {
    using U = cat::underlying_type<T>;
    return static_cast<T>(static_cast<U>(flag_1) | static_cast<U>(flag_2));
}

template <cat::is_enum_flag T>
[[nodiscard]] constexpr auto operator|(T flag_1, cat::underlying_type<T> flag_2)
    -> T {
    using U = cat::underlying_type<T>;
    return static_cast<T>(static_cast<U>(flag_1) | flag_2);
}

template <cat::is_enum_flag T>
[[nodiscard]] constexpr auto operator&(T flag_1, T flag_2) -> T {
    using U = cat::underlying_type<T>;
    return static_cast<T>(static_cast<U>(flag_1) & static_cast<U>(flag_2));
}

// TODO: Fix bit flag operators.
// template <EnumFlag T>
//[[nodiscard]] constexpr auto operator&(T flag_1,underlying_type<T>
// flag_2) -> T {
//     using U =underlying_type<T>;
//     return static_cast<T>(static_cast<U>(flag_1) & flag_2);
// }

constexpr auto operator""_ki(unsigned long long input) -> ssize {
    return 1024 * static_cast<signed long long>(input);
}

constexpr auto operator""_uki(unsigned long long input) -> usize {
    return 1024u * input;
}

constexpr auto operator""_ki(long double input) -> ssize {
    return static_cast<signed long long>(1024.f * input);
}

constexpr auto operator""_mi(unsigned long long input) -> ssize {
    return 1024ll * 1024ll * static_cast<signed long long>(input);
}

constexpr auto operator""_umi(unsigned long long input) -> usize {
    return 1024ull * 1024ull * input;
}

constexpr auto operator""_mi(long double input) -> ssize {
    return static_cast<signed long long>(1024.f * 1024.f * input);
}

constexpr auto operator""_gi(unsigned long long input) -> ssize {
    return 1024ll * 1024ll * 1024ll * static_cast<signed long long>(input);
}

constexpr auto operator""_ugi(unsigned long long input) -> usize {
    return 1024ull * 1024ull * 1024ull * input;
}

constexpr auto operator""_gi(long double input) -> ssize {
    return static_cast<signed long long>(1024.f * 1024.f * 1024.f * 1024.f *
                                         input);
}

#include "./implementations/align_down.tpp"
#include "./implementations/align_up.tpp"
#include "./implementations/is_aligned.tpp"
