// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/meta>

// `__BYTE_ORDER__` and `__ORDER_LITTLE_ENDIAN__` are macros defined by GCC.
inline constexpr bool is_little_endian =
    (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__);
inline constexpr bool is_big_endian = !is_little_endian;

namespace cat {

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto countl_zero(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);

    if (raw_value == 0) {
        // It is undefined behavior to pass 0 into clz.
        return ssizeof(T) * 8;
    }

    if constexpr (sizeof(raw_value) == 4) {
        return __builtin_clz(raw_value);
    } else if constexpr (sizeof(raw_value) == 8) {
        return __builtin_clzl(raw_value);
    } else {
        while (raw_value >>= 1) {
            ++raw_value;
        }
        return Limits<T>::digits - raw_value;
    }
}

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto countl_one(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);
    return raw_value != Limits<T>::max()
               ? countl_zero(static_cast<T>(~(raw_value)))
               : (ssizeof(T) * 8);
}

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto countr_zero(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);

    if (raw_value == 0) {
        // It is undefined behavior to pass 0 into ctz.
        return ssizeof(T) * 8;
    }

    if constexpr (sizeof(raw_value) <= 4) {
        return __builtin_ctz(raw_value);
    } else if constexpr (sizeof(raw_value) == 8) {
        return __builtin_ctzl(raw_value);
    }
}

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto countr_one(T value) -> ssize {
    return value != Limits<T>::max() ? countl_one(static_cast<T>(~value))
                                     : (ssizeof(T) * 8);
}

template <is_unsigned_integral T>
[[nodiscard]] constexpr auto popcount(T value) -> ssize {
    auto raw_value = to_raw_arithmetic(value);
    if constexpr (sizeof(value) < 8) {
        return __builtin_popcount(raw_value);
    } else {
        return __builtin_popcountll(raw_value);
    }
}

// Extracts `length` number of bits out of `from`, ending at the `offset` of the
// right-most bit. Those `length` bits are then the right-most bits of the
// return value.
template <is_unsigned T>
[[nodiscard]] constexpr auto extract_bits(T from,
                                          is_unsigned_integral auto offset,
                                          is_unsigned_integral auto length)
    -> T {
    auto raw_from = to_raw_arithmetic(from);
    auto raw_offset = to_raw_arithmetic(offset);
    auto raw_length = to_raw_arithmetic(length);

    if (sizeof(T) == 4) {
        return T(
            __builtin_ia32_bextr_u32(raw_from, raw_offset | (raw_length << 8)));
    } else if (sizeof(T) == 8) {
        return T(
            __builtin_ia32_bextr_u64(raw_from, raw_offset | (raw_length << 8)));
    } else {
        constexpr unsigned char bits = sizeof(T) * 8u;
        auto const mask = T((1u << raw_length) * (raw_length < bits) - 1u).raw;
        return T((raw_from >> raw_offset) & (mask * (raw_offset < bits)));
    }
}

[[gnu::const]] constexpr auto invert_endianess(is_integral auto value) {
    auto raw_value = to_raw_arithmetic(value);
    if constexpr (sizeof(raw_value) == 1) {
        return __builtin_bswap8(raw_value);
    }
    if constexpr (sizeof(raw_value) == 2) {
        return __builtin_bswap16(raw_value);
    }
    if constexpr (sizeof(raw_value) == 4) {
        return __builtin_bswap32(raw_value);
    }
    if constexpr (sizeof(raw_value) == 8) {
        return __builtin_bswap64(raw_value);
    }
}

// `Byte` is a strongly-typed `struct` rather than an `enum class` so that it
// has operators.
// TODO: Add some member functions.
struct Byte {  // NOLINT
    unsigned char value;

    constexpr Byte() = default;

    constexpr Byte(auto input) requires(sizeof(input) == 1) {
        this->value = input;
    }

    constexpr Byte(auto const& input) requires(sizeof(input) == 1) {
        this->value = input;
    }

    template <typename T>
    constexpr Byte(T&& input)  // NOLINT
        requires(sizeof(input) == 1) {
        this->value = forward<T>(input);
    }

    [[nodiscard]] constexpr operator char() const {
        return static_cast<char>(this->value);
    }

    [[nodiscard]] constexpr operator unsigned char() const {
        return static_cast<unsigned char>(this->value);
    }

    [[nodiscard]] constexpr operator signed char() const {
        return static_cast<signed char>(this->value);
    }

    template <typename T>
    [[nodiscard]] constexpr explicit operator T() requires(sizeof(T) == 1) {
        return bit_cast<T>(value);
    }

    [[nodiscard]] constexpr auto operator&(is_integral auto from) -> Byte {
        return this->value & from;
    }
    constexpr auto operator&=(is_integral auto from) -> Byte& {
        this->value = this->value & from;
        return *this;
    }

    [[nodiscard]] constexpr auto operator|(is_integral auto from) -> Byte {
        return this->value | from;
    }
    constexpr auto operator|=(is_integral auto from) -> Byte& {
        this->value = this->value | from;
        return *this;
    }

    [[nodiscard]] constexpr auto operator<<(is_integral auto from) -> Byte {
        return this->value << from;
    }
    constexpr auto operator<<=(is_integral auto from) -> Byte& {
        this->value = this->value << from;
        return *this;
    }

    [[nodiscard]] constexpr auto operator>>(is_integral auto from) -> Byte {
        return this->value >> from;
    }
    constexpr auto operator>>=(is_integral auto from) -> Byte& {
        this->value = this->value >> from;
        return *this;
    }
};

// TODO: Support `volatile` qualified pointers.
// TODO: Aligned pointer types and alignment casts.
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4201.html

template <typename U>
[[nodiscard]] constexpr auto is_aligned(U* p_value, usize alignment) -> bool;

template <typename U>
[[nodiscard]] constexpr auto is_aligned(uintptr<U> p_value, usize alignment)
    -> bool;

template <typename U>
[[nodiscard]] constexpr auto align_up(U* p_value, usize alignment) -> U*;
template <typename U>
constexpr auto align_up(uintptr<U> p_value, usize alignment) -> uintptr<U>;

template <typename U>
[[nodiscard]] constexpr auto align_down(U* p_value, usize alignment) -> U*;

template <typename U>
[[nodiscard]] constexpr auto align_down(intptr<U> p_value, usize alignment)
    -> intptr<U>;

template <typename U>
[[nodiscard]] constexpr auto align_down(uintptr<U> p_value, usize alignment)
    -> uintptr<U>;

template <is_integral T>
[[nodiscard]] constexpr auto has_single_bit(T value) -> bool {
    return (value & (value - 1)) == 0;
}

template <typename>
struct EnumFlagTrait : FalseTypeTrait {};

template <typename T>
concept is_enum_flag = EnumFlagTrait<T>::value;

}  // namespace cat

template <cat::is_enum_flag T>
[[nodiscard]] constexpr auto operator|(T flag_1, T flag_2) -> T {
    using U = cat::UnderlyingType<T>;
    return static_cast<T>(static_cast<U>(flag_1) | static_cast<U>(flag_2));
}

template <cat::is_enum_flag T>
[[nodiscard]] constexpr auto operator|(T flag_1, cat::UnderlyingType<T> flag_2)
    -> T {
    using U = cat::UnderlyingType<T>;
    return static_cast<T>(static_cast<U>(flag_1) | flag_2);
}

template <cat::is_enum_flag T>
[[nodiscard]] constexpr auto operator&(T flag_1, T flag_2) -> T {
    using U = cat::UnderlyingType<T>;
    return static_cast<T>(static_cast<U>(flag_1) & static_cast<U>(flag_2));
}

// TODO: Fix bit flag operators.
// template <EnumFlag T>
//[[nodiscard]] constexpr auto operator&(T flag_1,UnderlyingType<T>
// flag_2) -> T {
//     using U =UnderlyingType<T>;
//     return static_cast<T>(static_cast<U>(flag_1) & flag_2);
// }

constexpr auto operator""_ki(unsigned long long input) -> ssize {
    return 1024 * static_cast<signed long long>(input);
}

constexpr auto operator""_uki(unsigned long long input) -> usize {
    return 1024u * input;
}

constexpr auto operator""_ki(long double input) -> ssize {
    return static_cast<signed long long>(1024.f * input);
}

constexpr auto operator""_mi(unsigned long long input) -> ssize {
    return 1024ll * 1024ll * static_cast<signed long long>(input);
}

constexpr auto operator""_umi(unsigned long long input) -> usize {
    return 1024ull * 1024ull * input;
}

constexpr auto operator""_mi(long double input) -> ssize {
    return static_cast<signed long long>(1024.f * 1024.f * input);
}

constexpr auto operator""_gi(unsigned long long input) -> ssize {
    return 1024ll * 1024ll * 1024ll * static_cast<signed long long>(input);
}

constexpr auto operator""_ugi(unsigned long long input) -> usize {
    return 1024ull * 1024ull * 1024ull * input;
}

constexpr auto operator""_gi(long double input) -> ssize {
    return static_cast<signed long long>(1024.f * 1024.f * 1024.f * 1024.f *
                                         input);
}

#include "./implementations/align_down.tpp"
#include "./implementations/align_up.tpp"
#include "./implementations/is_aligned.tpp"
