// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/array>
#include <cat/bit>
#include <cat/math>
#include <cat/meta>

namespace cat {

template <uword bits_count>
    requires(bits_count > 0u)
class bitset {
  private:
    // public:

    // Store the smallest number of bytes needed for `bits_count`. If that is 8
    // bytes or fewer, use that many bytes. If it is larger, use an array of
    // 8-byte integers. Divide the bits by 8, rounding up.
    static constexpr uword total_bytes = div_ceil(bits_count, 8u);

    using array_type = conditional<
        total_bytes <= 8u,
        // `uint_fixed` will not compile here if it is larger than 8 or it is
        // not a power of 2. This is an `array` of one element to make it
        // iterable.
        array<
            uint_fixed<min(
                // TODO: Signed int `round_to_pow2()`.
                make_signed(round_to_pow2(make_unsigned(total_bytes.raw))), 8)>,
            1u>,
        array<uint8, div_ceil(total_bytes, 8u)>>;

    // private:
    using array_type_element = array_type::value_type;

  public:
    using iterator = bit_iterator<typename array_type::iterator>;
    using const_iterator = bit_iterator<typename array_type::const_iterator>;
    // using reverse_iterator =
    //     bit_iterator<typename value_type::reverse_iterator>;
    // using const_reverse_iterator =
    //     bit_iterator<typename value_type::const_reverse_iterator>;

    static constexpr idx storage_array_size = array_type::size();

    static constexpr idx storage_element_size = idx(sizeof(array_type_element));

    // The number of bits NOT counted in the first 1, 2, or 4 bytes of this
    // bitset.
    static constexpr uword leading_skipped_bits =
        // The number of bits in the entire storage, minus the bits declared for
        // use.
        (total_bytes * 8) - bits_count;

    // The number of bits counted in the first 1, 2, or 4 bytes of this bitset.
    static constexpr uword leading_bytes_bits =
        // Size of this storage, 64 bits or fewer.
        storage_element_size * 8u -
        // Minus the number of unused bits in this bitset.
        leading_skipped_bits;

    constexpr bitset() = default;
    constexpr bitset(bitset const&) = default;
    constexpr bitset(bitset&&) = default;

    template <typename... types>
        requires((is_same<types, array_type_element> ||
                  is_same<types, typename array_type_element::raw_type>) &&
                 ...)
    [[nodiscard]]
    static constexpr auto from(types... values) -> bitset
        requires(sizeof...(types) == array_type::size())
    {
        // `value_type::value_type` is some unsigned integer.
        // TODO: Assert that the input fits in `bits_count`.
        bitset<bits_count> bitset;
        bitset.storage = {values...};
        return bitset;
    }

    constexpr auto operator=(bitset const&) -> bitset& = default;
    constexpr auto operator=(bitset&&) -> bitset& = default;

    [[nodiscard]]
    constexpr auto
    operator==(bitset<bits_count> const&) const -> bool = default;

    // Index into this bit-set from the right-most bit.
    [[nodiscard]]
    constexpr auto
    operator[](uword index_bit) -> bit_reference<array_type_element> {
        if !consteval {
            assert(index_bit < bits_count);
        }

        array_type_element& index_byte =
            this->storage[static_cast<uword>(this->storage.size()) - 1u -
                          ((index_bit + this->leading_skipped_bits) /
                           // TODO: Without `.raw`, this is ambiguous.
                           word_bits.raw)];

        uword bit_offset = index_bit + this->leading_skipped_bits;
        // TODO: `total_bytes` doesn't compile here in Clang 17 if prefixed by
        // `this->`.
        if constexpr (total_bytes > word_bytes) {
            // If the bitset is larger than a word, wrap the bit offset by the
            // size of a word.
            bit_offset &= static_cast<uword>(word_bits) - 1u;
        }

        return bit_reference<array_type_element>::from_offset(index_byte,
                                                              bit_offset);
    }

    [[nodiscard]]
    constexpr auto
    operator[](uword index_bit) const -> bit_reference<array_type_element> {
        return (*unconst(this))[index_bit];
    }

    [[nodiscard]]
    constexpr auto at(uword index) -> maybe<bit_reference<array_type_element>> {
        if (index < bits_count) {
            return (*this)[index];
        }
        return nullopt;
    }

    [[nodiscard]]
    constexpr auto at(uword index) const
        -> maybe<bit_reference<array_type_element>> {
        if (index < bits_count) {
            return (*this)[index];
        }
        return nullopt;
    }

    [[nodiscard]]
    friend constexpr auto
    operator&(bitset<bits_count> lhs, bitset<bits_count> rhs) -> bitset {
        bitset<bits_count> bitset;
        for (uword::raw_type i = 0u; i < lhs.storage_array_size; ++i) {
            bitset.storage[i] = lhs.storage[i] & rhs.storage[i];
        }
        return bitset;
    }

    friend constexpr auto operator&=(bitset<bits_count>& self,
                                     bitset<bits_count> operand) -> bitset& {
        self = self & operand;
        return self;
    }

    [[nodiscard]]
    friend constexpr auto
    operator|(bitset<bits_count> lhs, bitset<bits_count> rhs) -> bitset {
        bitset<bits_count> bitset;
        for (uword::raw_type i = 0u; i < lhs.storage_array_size; ++i) {
            bitset.storage[i] = lhs.storage[i] | rhs.storage[i];
        }
        return bitset;
    }

    friend constexpr auto operator|=(bitset<bits_count>& self,
                                     bitset<bits_count> operand) -> bitset& {
        self = self | operand;
        return self;
    }

    [[nodiscard]]
    friend constexpr auto
    operator^(bitset<bits_count> lhs, bitset<bits_count> rhs) -> bitset {
        bitset<bits_count> bitset;
        for (uword::raw_type i = 0u; i < lhs.storage_array_size; ++i) {
            bitset.storage[i] = lhs.storage[i] ^ rhs.storage[i];
        }
        return bitset;
    }

    friend constexpr auto operator^=(bitset<bits_count>& self,
                                     bitset<bits_count> operand) -> bitset& {
        self = self ^ operand;
        return self;
    }

    friend constexpr auto operator~(bitset<bits_count> self) -> bitset& {
        for (auto& i : self.storage) {
            ~i;
        }
        return self;
    }

    // Evaluate true if every bit in this bitset is 1.
    [[nodiscard]]
    constexpr auto all_of() const -> bool {
        for (uword i = 0u; i < this->storage_array_size; ++i) {
            auto it = this->storage[i];
            using T = decltype(it);

            if (i > 0u || constant_evaluate(has_single_bit(bits_count) ||
                                            !(bits_count & 63u))) {
                if (it != it.max()) {
                    // If at least one bit is 0:
                    return false;
                }
            } else {
                // Leading bits of the leading byte should not be considered
                // part of the bitset, so they are masked off.
                T mask = (T(1) << leading_bytes_bits) - T(1);

                if (it != mask) {
                    return false;
                }
            }
        }
        return true;
    }

    // Evaluate true if at least one bit in this bitset is 1.
    [[nodiscard]]
    constexpr auto any_of() const -> bool {
        for (auto i : this->storage) {
            if (i != 0u) {
                return true;
            }
        }
        return false;
    }

    // Evaluate true if every bit in this bitset is 0.
    [[nodiscard]]
    constexpr auto none_of() const -> bool {
        return !(this->any_of());
    }

    [[nodiscard]]
    constexpr auto countl_zero() const -> idx {
        // TODO: `leading_bytes_bits` doesn't compile here in Clang 17 if
        // prefixed by `this->`.
        constexpr idx skip_bits = static_cast<idx>(
            sizeof(array_type_element) * 8u - leading_bytes_bits);

        idx count = cat::countl_zero(this->storage[0u]);
        if (count != sizeof(array_type_element) * 8u) {
            return count - skip_bits;
        }

        count -= skip_bits;

        for (uword i = 1u; i < this->storage_array_size; ++i) {
            idx next_count = cat::countl_zero(this->storage[i]);
            count += next_count;

            // If any 1s are found, skip remaining bytes.
            if (next_count != sizeof(array_type_element) * 8u) {
                break;
            }
        }
        return count;
    }

    // TODO: `.countl_one()`.

    [[nodiscard]]
    constexpr auto countr_zero() const -> idx {
        idx count =
            cat::countr_zero(this->storage[this->storage_array_size - 1u]);
        if (count != sizeof(array_type_element) * 8u) {
            return count;
        }

        for (uword i = this->storage_array_size - 2u; i >= 0u; --i) {
            idx next_count = cat::countr_zero(this->storage[i]);
            count += next_count;

            // If any 1's are found, skip remaining bytes.
            if (next_count != sizeof(array_type_element) * 8u) {
                break;
            }
        }
        return count;
    }

    // TODO: `.countr_one()`.

    [[nodiscard]]
    constexpr auto begin() {
        return iterator(storage.begin());
    }

    [[nodiscard]]
    constexpr auto end() {
        return iterator(storage.end(), limits<array_type_element>::bits);
    }

    [[nodiscard]]
    constexpr auto begin() const {
        return const_iterator(storage.begin());
    }

    [[nodiscard]]
    constexpr auto end() const {
        return const_iterator(storage.end(), limits<array_type_element>::bits);
    }

    [[nodiscard]]
    constexpr auto cbegin() const {
        return const_iterator(storage.cbegin());
    }

    [[nodiscard]]
    constexpr auto cend() const {
        return const_iterator(storage.cend(), limits<array_type_element>::bits);
    }

    // TODO: Reverse iterators.

  private:
    array_type storage;
};

}  // namespace cat
