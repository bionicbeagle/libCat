// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/array>
#include <cat/bit>
#include <cat/math>
#include <cat/meta>

namespace cat {

template <ssize bits_count>
    requires(bits_count > 0)
class bitset {
  private:

  public:
    // Store the smallest number of bytes needed for `bits_count`. If that is 8
    // bytes or fewer, use that many bytes. If it is larger, use an array of
    // 8-byte integers. Divide the bits by 8, rounding up.
    static constexpr ssize bytes = div_ceil(bits_count, 8);

    using value_type = conditional<
        bytes <= 8,
        // `uint_fixed` will not compile here if it is larger than 8 or it is
        // not a power of 2. This is an `array` of one element to make it
        // iterable.
        array<uint_fixed<min(
                  // TODO: Signed int `round_to_pow2()`.
                  make_signed(round_to_pow2(make_unsigned(bytes.raw))), 8)>,
              1>,
        array<uint8, div_ceil(bytes, 8)>>;

  private:
    using value_type_element = typename value_type::value_type;

  public:
    template <typename T>
    // requires(is_same<decay<T>, bitset<bits_count>>)
    class iterator_type : public iterator_interface<iterator_type<T>> {
      public:
        constexpr iterator_type() = default;

        constexpr iterator_type(ssize in_index, T& in_bitset)
            : current_index(in_index), bitset(in_bitset){};

        constexpr auto dereference()
            requires(!is_const<T>)
        {
            return this->bitset[this->current_index];
        }

        constexpr auto dereference() const
            requires(is_const<T>)
        {
            return this->bitset[this->current_index];
        }

        constexpr void advance(ssize offset) {
            this->current_index += offset;
        }

        constexpr auto distance(iterator_type const& other) const -> ssize {
            return other.current_index - this->current_index;
        }

      private:
        ssize current_index;
        T& bitset;
    };

    static constexpr ssize storage_array_size = value_type::size();

    static constexpr ssize storage_element_size = ssizeof(value_type_element);

    // The number of bits NOT counted in the first 1, 2, or 4 bytes of this
    // bitset.
    static constexpr ssize leading_skipped_bits =
        // The number of bits in the entire storage, minus the bits declared for
        // use.
        (bytes * 8) - bits_count;

    // The number of bits counted in the first 1, 2, or 4 bytes of this bitset.
    static constexpr ssize leading_bytes_bits =
        // Size of this storage, 64 bits or fewer.
        storage_element_size * 8 -
        // Minus the number of unused bits in this bitset.
        leading_skipped_bits;

    constexpr bitset() = default;

    template <typename... types>
        requires((is_same<types, value_type_element> ||
                  is_same<types, typename value_type_element::raw_type>) &&
                 ...)
    [[nodiscard]]
    static constexpr auto from(types... values) -> bitset
        requires(ssizeof_pack<types...>() == value_type::size())
    {
        // `value_type::value_type` is some unsigned integer.
        // TODO: Assert that the input fits in `bits_count`.
        bitset<bits_count> bitset;
        bitset.storage = {values...};
        return bitset;
    }

    [[nodiscard]]
    constexpr auto
    operator==(bitset<bits_count> const&) const -> bool = default;

    [[nodiscard]]
    constexpr auto
    operator[](ssize index) -> bit_reference<value_type_element> {
        if (!__builtin_is_constant_evaluated()) {
            cat::assert(index < bits_count);
        }

        value_type_element& bytes =
            this->storage[(index + this->leading_skipped_bits) / 64];
        // ssize bit_offset = (index - this->leading_skipped_bits) & 63;

        return bit_reference<value_type_element>::from_offset(
            bytes, index - this->leading_skipped_bits);
    }

    [[nodiscard]]
    constexpr auto
    operator[](ssize index) const -> bool {
        if (!__builtin_is_constant_evaluated()) {
            cat::assert(index < bits_count);
        }

        value_type_element mask;
        value_type_element bytes;

        if (index <= this->leading_bytes_bits ||
            (this->storage_array_size == 1)) {
            bytes = this->storage[0];
            mask = limits<value_type_element>::high_bit >>
                   (index + this->leading_skipped_bits);
        } else {
            bytes = this->storage[(index + this->leading_skipped_bits) / 64];
            mask = limits<value_type_element>::high_bit >>
                   ((index - this->leading_skipped_bits) & 63);
        }

        auto result = mask & bytes;
        return static_cast<bool>(result);
    }

    [[nodiscard]]
    constexpr auto at(ssize index) -> maybe<bit_reference<value_type_element>> {
        if (index < bits_count) {
            return (*this)[index];
        }
        return nullopt;
    }

    [[nodiscard]]
    constexpr auto at(ssize index) const -> maybe<bool> {
        if (index < bits_count) {
            return (*this)[index];
        }
        return nullopt;
    }

    [[nodiscard]]
    friend constexpr auto
    operator&(bitset<bits_count> lhs, bitset<bits_count> rhs) -> bitset {
        bitset<bits_count> bitset;
        for (ssize::raw_type i = 0; i < lhs.storage_array_size; ++i) {
            bitset.storage[i] = lhs.storage[i] & rhs.storage[i];
        }
        return bitset;
    }

    friend constexpr auto operator&=(bitset<bits_count>& self,
                                     bitset<bits_count> operand) -> bitset& {
        self = self & operand;
        return self;
    }

    [[nodiscard]]
    friend constexpr auto
    operator|(bitset<bits_count> lhs, bitset<bits_count> rhs) -> bitset {
        bitset<bits_count> bitset;
        for (ssize::raw_type i = 0; i < lhs.storage_array_size; ++i) {
            bitset.storage[i] = lhs.storage[i] | rhs.storage[i];
        }
        return bitset;
    }

    friend constexpr auto operator|=(bitset<bits_count>& self,
                                     bitset<bits_count> operand) -> bitset& {
        self = self | operand;
        return self;
    }

    [[nodiscard]]
    friend constexpr auto
    operator^(bitset<bits_count> lhs, bitset<bits_count> rhs) -> bitset {
        bitset<bits_count> bitset;
        for (ssize::raw_type i = 0; i < lhs.storage_array_size; ++i) {
            bitset.storage[i] = lhs.storage[i] ^ rhs.storage[i];
        }
        return bitset;
    }

    friend constexpr auto operator^=(bitset<bits_count>& self,
                                     bitset<bits_count> operand) -> bitset& {
        self = self ^ operand;
        return self;
    }

    friend constexpr auto operator~(bitset<bits_count> self) -> bitset& {
        for (auto& i : self.storage) {
            ~i;
        }
        return self;
    }

    // Evaluate true if every bit in this bitset is 1.
    [[nodiscard]]
    constexpr auto all_of() const -> bool {
        for (ssize i = 0; i < this->storage_array_size; ++i) {
            auto it = this->storage[i];
            using T = decltype(it);

            // TODO: Clang rejects the `constant_evaluate()` call.
            if (i > 0 ||  // constant_evaluate
                (has_single_bit(bits_count) || !(bits_count & 63))) {
                if (it != it.max()) {
                    // If at least one bit is 0:
                    return false;
                }
            } else {
                // Leading bits of the leading byte should not be considered
                // part of the bitset, so they are masked off.
                T mask = (T(1u) << leading_bytes_bits) - T(1u);

                if (it != mask) {
                    return false;
                }
            }
        }
        return true;
    }

    // Evaluate true if at least one bit in this bitset is 1.
    [[nodiscard]]
    constexpr auto any_of() const -> bool {
        for (auto i : this->storage) {
            if (i != 0u) {
                return true;
            }
        }
        return false;
    }

    // Evaluate true if every bit in this bitset is 0.
    [[nodiscard]]
    constexpr auto none_of() const -> bool {
        return !(this->any_of());
    }

    [[nodiscard]]
    constexpr auto countl_zero() const -> ssize {
        constexpr ssize skip_bits =
            (ssizeof(value_type_element) * 8) - this->leading_bytes_bits;

        ssize count = cat::countl_zero(this->storage[0]);
        if (count != ssizeof(value_type_element) * 8) {
            return count - skip_bits;
        }

        count -= skip_bits;

        for (ssize i = 1; i < this->storage_array_size; ++i) {
            ssize next_count = cat::countl_zero(this->storage[i]);
            count += next_count;

            // If any 1s are found, skip remaining bytes.
            if (next_count != ssizeof(value_type_element) * 8) {
                break;
            }
        }
        return count;
    }

    // TODO: `.countl_one()`.

    [[nodiscard]]
    constexpr auto countr_zero() const -> ssize {
        ssize count =
            cat::countr_zero(this->storage[this->storage_array_size - 1]);
        if (count != ssizeof(value_type_element) * 8) {
            return count;
        }

        for (ssize i = this->storage_array_size - 2; i >= 0; --i) {
            ssize next_count = cat::countr_zero(this->storage[i]);
            count += next_count;

            // If any 1s are found, skip remaining bytes.
            if (next_count != ssizeof(value_type_element) * 8) {
                break;
            }
        }
        return count;
    }

    // TODO: `.countr_one()`.

    [[nodiscard]]
    constexpr auto begin() {
        return iterator_type<decltype(*this)>(0, *this);
    }

    [[nodiscard]]
    constexpr auto end() {
        return iterator_type<decltype(*this)>(bits_count - 1, *this);
    }

    [[nodiscard]]
    constexpr auto begin() const {
        return iterator_type<decltype(*this)>(0, *this);
    }

    [[nodiscard]]
    constexpr auto end() const {
        return iterator_type<decltype(*this)>(bits_count - 1, *this);
    }

    [[nodiscard]]
    constexpr auto cbegin() const {
        return iterator_type<decltype(*this)>(0, *this);
    }

    [[nodiscard]]
    constexpr auto cend() const {
        return iterator_type<decltype(*this)>(bits_count - 1, *this);
    }

  private:
    value_type storage;
};

}  // namespace cat
