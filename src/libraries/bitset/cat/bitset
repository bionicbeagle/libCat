// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/array>
#include <cat/bit>
#include <cat/math>
#include <cat/meta>

namespace cat {

template <ssize bits_count>
    requires(bits_count > 0)
class Bitset {
  private:

  public:
    // Store the smallest number of bytes needed for `bits_count`. If that is 8
    // bytes or fewer, use that many bytes. If it is larger, use an array of
    // 8-byte integers. Divide the bits by 8, rounding up.
    static constexpr ssize bytes = div_ceil(bits_count, 8);

    using Value = Conditional<
        bytes <= 8,
        // `UintFixed` will not compile here if it is larger than 8 or it is not
        // a power of 2. This is an `Array` of one element to make it iterable.
        Array<UintFixed<min(
                  // TODO: Signed int `round_to_pow2()`.
                  make_signed(round_to_pow2(make_unsigned(bytes.raw))), 8)>,
              1>,
        Array<uint8, div_ceil(bytes, 8)>>;

    static constexpr ssize storage_array_size = Value::size();

    static constexpr ssize storage_element_size =
        ssizeof<typename Value::Value>();

    constexpr Bitset() = default;

    template <typename... Ts>
        requires(is_same<Ts, typename Value::Value>&&...)
    static constexpr auto from(Ts... values) -> Bitset
        requires(ssizeof_pack<Ts...>() == Value::size()) {
        // `Value::Value` is some unsigned integer.
        // TODO: Assert that the input fits in `bits_count`.
        Bitset<bits_count> bitset;
        bitset.storage = {values...};
        return bitset;
    }

    constexpr auto operator==(Bitset<bits_count> const&) const
        -> bool = default;

    friend constexpr auto operator&(Bitset<bits_count> lhs,
                                    Bitset<bits_count> rhs) -> Bitset {
        Bitset<bits_count> bitset;
        for (ssize::Raw i = 0; i < lhs.storage_array_size; ++i) {
            bitset.storage[i] = lhs.storage[i] & rhs.storage[i];
        }
        return bitset;
    }

    friend constexpr auto operator&=(Bitset<bits_count>& self,
                                     Bitset<bits_count> operand) -> Bitset& {
        self = self & operand;
        return self;
    }

    friend constexpr auto operator|(Bitset<bits_count> lhs,
                                    Bitset<bits_count> rhs) -> Bitset {
        Bitset<bits_count> bitset;
        for (ssize::Raw i = 0; i < lhs.storage_array_size; ++i) {
            bitset.storage[i] = lhs.storage[i] | rhs.storage[i];
        }
        return bitset;
    }

    friend constexpr auto operator|=(Bitset<bits_count>& self,
                                     Bitset<bits_count> operand) -> Bitset& {
        self = self | operand;
        return self;
    }

    friend constexpr auto operator^(Bitset<bits_count> lhs,
                                    Bitset<bits_count> rhs) -> Bitset {
        Bitset<bits_count> bitset;
        for (ssize::Raw i = 0; i < lhs.storage_array_size; ++i) {
            bitset.storage[i] = lhs.storage[i] ^ rhs.storage[i];
        }
        return bitset;
    }

    friend constexpr auto operator^=(Bitset<bits_count>& self,
                                     Bitset<bits_count> operand) -> Bitset& {
        self = self ^ operand;
        return self;
    }

    friend constexpr auto operator~(Bitset<bits_count> self) -> Bitset& {
        for (auto& i : self.storage) {
            ~i;
        }
        return self;
    }

    // Evaluate true if every bit in this bitset is 1.
    constexpr auto all() -> bool {
        for (ssize i = 0; i < this->storage_array_size; ++i) {
            auto it = this->storage[i];
            using T = decltype(it);

            if (i > 0 || constant_evaluate(is_power_of_two(bits_count) ||
                                           !(bits_count & (63)))) {
                if (it != it.max) {
                    // If at least one bit is 0:
                    return false;
                }
            } else {
                // Leading bits of the leading byte should not be considered
                // part of the bitset, so they are masked off.
                constexpr T bits_offset(
                    // Size of this storage, 64 bits or fewer.
                    (ssizeof<T>() * 8) -
                    // Minus the number of unused bits in this bitset.
                    ((bytes * 8) - bits_count));

                T mask = (T(1u) << bits_offset) - T(1u);

                if (it != mask) {
                    return false;
                }
            }
        }
        return true;
    }

    // Evaluate true if every bit in this bitset is 0.
    constexpr auto none() -> bool {
        for (auto i : this->storage) {
            if (i != 0u) {
                return false;
            }
        }
        return true;
    }

    // Evaluate true if at least one bit in this bitset is 1.
    constexpr auto any() -> bool {
        for (auto i : this->storage) {
            if (i != 0u) {
                return true;
            }
        }
        return false;
    }

  private:
    Value storage;
};

}  // namespace cat
