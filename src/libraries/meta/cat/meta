// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

// These forward declarations are required.
namespace cat {
template <typename T>
struct RemoveReferenceTrait;
template <typename>
struct IsLvalueReferenceTrait;
}  // namespace cat

namespace std {
template <typename T>
constexpr auto move(T&& input) -> typename cat::RemoveReferenceTrait<T>::Type&&;
template <typename T>
constexpr auto forward(typename cat::RemoveReferenceTrait<T>::Type& input)
    -> T&&;
template <typename T>
constexpr auto forward(typename cat::RemoveReferenceTrait<T>::Type&& input)
    -> T&& requires(!cat::IsLvalueReferenceTrait<T>::value);
}  // namespace std

namespace cat {
using std::forward;
using std::move;

// Forward declare numeric types. These are implemented in `<numeral>`.
template <typename T>
struct Numeral;

using int1 = Numeral<__INT8_TYPE__>;
using int2 = Numeral<__INT16_TYPE__>;
using int4 = Numeral<__INT32_TYPE__>;
using int8 = Numeral<__INT64_TYPE__>;
using uint1 = Numeral<__UINT8_TYPE__>;
using uint2 = Numeral<__UINT16_TYPE__>;
using uint4 = Numeral<__UINT32_TYPE__>;
using uint8 = Numeral<__UINT64_TYPE__>;
using float4 = Numeral<float>;
using float8 = Numeral<double>;

using usize = Numeral<__SIZE_TYPE__>;
// TODO: Support word size of `4`:
using ssize = Numeral<long int>;

struct bool2;
struct bool4;

template <typename T, typename Storage>
struct ArithmeticPtr;

namespace detail {
    template <typename T, typename U = T&&>
    constexpr auto declval_detail(signed int) -> U;

    template <typename T>
    constexpr auto declval_detail(signed long) -> T;
}  // namespace detail

template <typename T>
auto declval() -> decltype(detail::declval_detail<T>(0));

template <typename T>
using Identity = T;

namespace detail {
    template <typename...>
    using Void = void;
}

template <typename T>
using AddConst = T const;

template <typename T>
using AddVolatile = T volatile;

template <typename T>
using AddCv = T const volatile;

template <typename T>
struct RemoveConstTrait {
    using Type = T;
};
template <typename T>
struct RemoveConstTrait<T const> {
    using Type = T;
};
template <typename T>
using RemoveConst = typename RemoveConstTrait<T>::Type;

template <typename T>
struct RemoveVolatileTrait {
    using Type = T;
};
template <typename T>
struct RemoveVolatileTrait<T volatile> {
    using Type = T;
};
template <typename T>
using RemoveVolatile = typename RemoveVolatileTrait<T>::Type;

template <typename T>
struct RemoveCvTrait {
    using Type = T;
};
template <typename T>
struct RemoveCvTrait<T const> {
    using Type = T;
};
template <typename T>
struct RemoveCvTrait<T volatile> {
    using Type = T;
};
template <typename T>
struct RemoveCvTrait<T const volatile> {
    using Type = T;
};
template <typename T>
using RemoveCv = typename RemoveCvTrait<T>::Type;

template <typename T>
struct RemoveReferenceTrait {
    using Type = T;
};
template <typename T>
struct RemoveReferenceTrait<T&> {
    using Type = T;
};
template <typename T>
struct RemoveReferenceTrait<T&&> {
    using Type = T;
};
template <typename T>
using RemoveReference = typename RemoveReferenceTrait<T>::Type;

template <typename T>
struct RemoveCvRefTrait {
    using Type = RemoveCvTrait<RemoveReferenceTrait<T>>;
};
template <typename T>
using RemoveCvRef = typename RemoveCvRefTrait<T>::Type::Type::Type;

namespace detail {
    template <typename T>
    struct RemovePointerTraitDetail {
        using Type = T;
    };
    template <typename T>
    struct RemovePointerTraitDetail<T*> {
        using Type = T;
    };
    template <typename T>
    struct RemovePointerTraitDetail<T* const> {
        using Type = T;
    };
    template <typename T>
    struct RemovePointerTraitDetail<T* volatile> {
        using Type = T;
    };
    template <typename T>
    struct RemovePointerTraitDetail<T* const volatile> {
        using Type = T;
    };
}  // namespace detail

template <typename T>
struct RemovePointerTrait : detail::RemovePointerTraitDetail<T> {};
template <typename T>
using RemovePointer = typename RemovePointerTrait<T>::Type;

// TODO: Generalize constant wrappers.

template <typename T, T constant_value>
struct IntegralConstant {
    static constexpr T value = constant_value;
    using Type = IntegralConstant<T, constant_value>;
};
template <typename T, T constant_value>
constexpr auto integral_constant = constant_value;

template <bool constant_value>
using BoolConstant = IntegralConstant<bool, constant_value>;
template <bool constant_value>
constexpr auto bool_constant = constant_value;

// TODO: Streamline these out entirely.
using TrueTypeTrait = BoolConstant<true>;
constexpr bool true_type = TrueTypeTrait::value;

using FalseTypeTrait = BoolConstant<false>;
constexpr bool false_type = FalseTypeTrait::value;

template <bool, typename T, typename U>
struct ConditionalTrait {
    using Type = T;
};
template <typename T, typename U>
struct ConditionalTrait<false, T, U> {
    using Type = U;
};
template <bool condition, typename T, typename U>
using Conditional = typename ConditionalTrait<condition, T, U>::Type;

// `__is_enum()` is a GNU builtin.
template <typename T>
constexpr bool is_enum = __is_enum(T);

// `__is_same()` is a GNU builtin.
template <typename T, typename U>
concept sameAs = __is_same(T, U);
template <typename T, typename U>
constexpr bool is_same = __is_same(T, U);

// `__is_base_of()` is a GNU builtin.
template <typename T, typename U>
constexpr bool is_base_of = __is_base_of(T, U);

// `__is_union()` is a GNU builtin.
template <typename T>
constexpr bool is_union = __is_union(T);

// `__is_class()` is a GNU builtin.
template <typename T>
constexpr bool is_class = __is_class(T);

template <typename T>
concept referenceable = requires {
    // Try to substitute a `T&`. If that is well-formed, this always holds true.
    __is_same(T&, T&);
};
template <typename T>
constexpr bool is_referenceable = referenceable<T>;

template <typename...>
constexpr bool is_reference = false;
template <referenceable T>
constexpr bool is_reference<T> = __is_same(T, RemoveReference<T>&) ||
                                 __is_same(T, RemoveReference<T>&&);

template <typename, template <typename...> typename>
constexpr bool is_specialization = false;

template <template <typename...> typename Template, typename... Args>
constexpr bool is_specialization<Template<Args...>, Template> = true;

template <typename T>
concept safeNumeral = is_specialization<T, Numeral>;
template <typename T>
constexpr bool is_safe_numeral = safeNumeral<T>;

template <typename T>
concept unsafeNumeral = !is_specialization<T, Numeral>;
template <typename T>
constexpr bool is_unsafe_numeral = unsafeNumeral<T>;

// TODO: Include half
template <typename T>
concept floatingPoint = __is_same(RemoveCvRef<T>, float) ||
                        __is_same(RemoveCvRef<T>, double) ||
                        __is_same(RemoveCvRef<T>, long double) ||
                        __is_same(RemoveCvRef<T>, float8) ||
                        __is_same(RemoveCvRef<T>, float4) ||
                        __is_same(RemoveCvRef<T>, __float128);
template <typename T>
constexpr bool is_floating_point = floatingPoint<T>;

template <typename T>
concept integral =
    (is_safe_numeral<RemoveCv<T>> && !is_floating_point<RemoveCv<T>>) ||
    __is_same(RemoveCv<T>, signed char) ||
    __is_same(RemoveCv<T>, unsigned char) || __is_same(RemoveCv<T>, char) ||
    __is_same(RemoveCv<T>, short) || __is_same(RemoveCv<T>, unsigned short) ||
    __is_same(RemoveCv<T>, int) || __is_same(RemoveCv<T>, unsigned int) ||
    __is_same(RemoveCv<T>, long) || __is_same(RemoveCv<T>, unsigned long) ||
    __is_same(RemoveCv<T>, long long) ||
    __is_same(RemoveCv<T>, unsigned long long);
template <typename T>
constexpr bool is_integral = integral<T>;

template <typename T>
concept boolean = __is_same(T, RemoveCvRef<bool>) ||
                  __is_same(T, RemoveCvRef<bool2>) ||
                  __is_same(T, RemoveCvRef<bool4>);
template <typename T>
constexpr bool is_bool = boolean<T>;

template <typename T>
concept arithmetic = integral<T> || floatingPoint<T>;
template <typename T>
constexpr bool is_arithmetic = arithmetic<T>;

namespace detail {
    template <typename T>
    concept hasLessThanOperator = requires(T t) {
        t < 0;
    };
}  // namespace detail

template <typename...>
constexpr bool is_signed = false;

// This expression only holds true if `T` can be constant-evaluated.
template <detail::hasLessThanOperator T>
constexpr bool is_signed<T> = bool_constant<(T(-1) < T(0))>;

template <typename T>
constexpr bool is_unsigned = !is_signed<T>;

template <typename T>
constexpr bool is_void = __is_same(T, void);

// TODO: For some reason, `__is_same(T, T const)` does not work.
template <typename>
constexpr bool is_const = false;
template <typename T>
constexpr bool is_const<T const> = true;

template <typename T>
constexpr bool is_volatile = __is_same(T, T volatile);

template <typename T>
constexpr bool is_pointer = !__is_same(T, RemovePointer<T>);

template <typename T>
constexpr bool is_array = !is_pointer<T> && requires(T t) {
    t[0];
};

template <typename T>
struct RemoveExtentTrait {
    using Type = T;
};
template <typename T, int size>
struct RemoveExtentTrait<T[size]> {
    using Type = T;
};
template <typename T>
struct RemoveExtentTrait<T[]> {
    using Type = T;
};
template <typename T>
using RemoveExtent = typename RemoveExtentTrait<T>::Type;

// TODO: Figure this out with concepts.
/*
namespace detail {
template <typename T>
struct IsMemberPointerTraitDetail : FalseTypeTrait {};
template <typename T, typename U>
struct IsMemberPointerTraitDetail<T U::*> : TrueTypeTrait {};
}  // namespace detail

template <typename T>
struct IsMemberPointerTrait : detail::IsMemberPointerTraitDetail<RemoveCv<T>> {
};
template <typename T>
constexpr bool is_member_pointer = IsMemberPointerTrait<T>::value;
*/

template <typename T>
constexpr bool is_null_pointer = __is_same(RemoveCv<T>, decltype(nullptr));

template <typename T>
constexpr bool is_scalar = is_arithmetic<T> || is_enum<T> || is_pointer<T> ||
                           // is_member_pointer<T> ||
                           is_null_pointer<T>;

template <typename T>
using AddPointer = Conditional<is_referenceable<T>, RemoveReference<T>*, T*>;

template <typename T>
using AddLvalueReference = T&;

template <typename T>
using AddRvalueReference = T&&;

template <typename T>
constexpr bool is_lvalue_reference = __is_same(T, RemoveReference<T>&);

template <typename T>
constexpr bool is_rvalue_reference = __is_same(T, RemoveReference<T>&&);

template <typename T, typename U>
using CopyConstFrom = Conditional<is_const<RemoveReference<U>>,
                                  // U is const.
                                  T const,
                                  // U is not const.
                                  RemoveConst<T>>;

template <typename T, typename U>
using CopyVolatileFrom = Conditional<is_volatile<RemoveReference<U>>,
                                     // U is volatile.
                                     RemoveVolatile<T> volatile,
                                     // U is not volatile.
                                     RemoveVolatile<T>>;

template <typename T, typename U>
using CopyRefFrom =
    Conditional<is_lvalue_reference<U>,
                // U is an l-value reference.
                AddLvalueReference<RemoveReference<T>>,
                Conditional<is_rvalue_reference<U>,
                            // U is an r-value reference.
                            AddRvalueReference<RemoveReference<T>>,
                            // U is not a reference.
                            RemoveReference<T>>>;

template <typename T, typename U>
using CopyCvFrom = CopyVolatileFrom<CopyConstFrom<T, U>, U>;

template <typename T, typename U>
using CopyCvRefFrom = CopyRefFrom<CopyConstFrom<T, U>, U>;

// `__underlying_type` is a GNU builtin.
template <typename T>
struct UnderlyingTypeTrait {
    using Type = __underlying_type(T);
};
// GCC 12 doesn't seem to compile this correctly if `__underlying_type()` is
// used directly.
template <typename T>
using UnderlyingType = typename UnderlyingTypeTrait<T>::Type;

template <typename From, typename To>
constexpr bool is_implicitly_convertible = __is_assignable(To, From) ||
                                           __is_constructible(To, From) ||
                                           __is_same(To, From);

template <typename From, typename To>
constexpr bool is_convertible = requires(From from) {
    static_cast<To>(from);
};

template <typename T>
constexpr bool is_sizable = requires {
    sizeof(T);
};

template <typename T>
concept enumerator = __is_enum(T);

// This requires a partial template specialization, because `__underlying_type`
// is not well-formed in any expression that involves a non-enum type.
template <typename...>
constexpr bool is_scoped_enum = false;

// TODO: Technically, an implicit conversion operator can be defined for enum
// classes that make this hold false.
template <enumerator T>
constexpr bool is_scoped_enum<T> =
    !is_implicitly_convertible<T, __underlying_type(T)>;

template <typename T>
constexpr bool is_object =
    is_scalar<T> || is_array<T> || is_union<T> || is_class<T>;

template <typename T>
constexpr bool is_function = !is_object<T>;

// Remove `const`/`volatile`-qualifiers, references, and pointers from a type.
template <typename T>
using Decay = Conditional<
    // Decay arrays to pointers.
    is_array<RemoveReference<T>>, RemoveExtent<RemoveReference<T>>*,
    Conditional<
        // Decay functions into function pointers.
        is_function<RemoveReference<T>>, AddPointer<RemoveReference<T>>,
        // Otherwise, remove cv-qualifiers.
        RemoveCv<RemoveReference<T>>>>;

template <typename, unsigned = 0>
struct ExtentTrait;

template <typename>
struct RemoveAllExtentsTrait;

template <typename T>
struct RemoveAllExtentsTrait {
    using Type = T;
};

template <typename T>
struct RemoveAllExtentsTrait<T[]> {
    using Type = typename RemoveAllExtentsTrait<T>::Type;
};

template <typename T, unsigned long long N>
struct RemoveAllExtentsTrait<T[N]> {
    using Type = typename RemoveAllExtentsTrait<T>::Type;
};

// TODO: Figure out how to implement this with concepts.
/*
template <typename T>
struct IsBoundedArrayTrait : FalseTypeTrait {};
template <typename T, signed long long N>
struct IsBoundedArrayTrait<T[N]> : TrueTypeTrait {};
template <typename T>
constexpr bool is_bounded_array = IsBoundedArrayTrait<T>::value;

template <typename T>
struct IsUnboundedArrayTrait : TrueTypeTrait {};
template <typename T, signed long long N>
struct IsUnboundedArrayTrait<T[N]> : FalseTypeTrait {};
template <typename T>
constexpr bool is_unbounded_array = IsUnBoundedArrayTrait<T>::value;
*/

// `__is_constructible` is a GNU builtin.
template <typename T, typename... Args>
constexpr bool is_constructible = __is_constructible(T, Args...);

// `__is_trivially_constructible` is a GNU builtin.
template <typename T, typename... Args>
constexpr bool is_trivially_constructible =
    __is_trivially_constructible(T, Args...);

template <typename T>
constexpr bool is_default_constructible = requires {
    T{};
};

template <typename T>
// clang-format off
constexpr bool is_trivially_default_constructible =
    is_default_constructible<T> && __is_trivially_constructible(T);
// clang-format on

template <typename T>
constexpr bool is_copy_constructible = __is_constructible(T, T const&);

template <typename T>
constexpr bool is_trivially_copy_constructible =
    __is_trivially_constructible(T, T const&);

template <typename T>
constexpr bool is_move_constructible = __is_constructible(T, T&&);

template <typename T>
constexpr bool is_trivially_move_constructible =
    __is_trivially_constructible(T, T&&);

// There is no `__has_destructor()` GCC builtin.
template <typename T>
constexpr bool is_destructible = requires {
    ~T();
};

// `__has_trivial_destructor()` is a GNU builtin.
template <typename T>
// clang-format off
constexpr bool is_trivially_destructible =
    is_destructible<T> && __has_trivial_destructor(T);
// clang-format on

// `__is_assingable` is a GNU builtin.
template <typename T, typename U>
constexpr bool is_assignable = __is_assignable(T, U);

// `__is_trivially_assignable` is a GNU builtin.
template <typename T, typename U>
constexpr bool is_trivially_assignable = __is_trivially_assignable(T, U);

template <typename T>
constexpr bool is_copy_assignable = __is_assignable(T, T const&);

template <typename T>
constexpr bool is_trivially_copy_assignable =
    __is_trivially_assignable(T, T const&);

template <typename T>
constexpr bool is_move_assignable = __is_assignable(T, T&&);

template <typename T>
constexpr bool is_trivially_move_assignable = __is_trivially_assignable(T, T&&);

// `__is_trivially_copyable()` is a GNU builtin.
template <typename T>
constexpr bool is_trivially_copyable = __is_trivially_copyable(T);

template <typename T>
constexpr bool is_trivial =
    is_trivially_copyable<T>&& is_trivially_default_constructible<T>;

template <typename Function, typename... Args>
concept invocable = requires(Function func, Args&&... args) {
    func(forward<Args>(args)...);
};

template <typename Function, typename... Args>
constexpr bool is_invocable = invocable<Function, Args...>;

// https://quuxplusone.github.io/blog/2019/02/06/arrow-proxy/
template <typename Reference>
struct ArrowProxy {
    Reference reference;
    auto operator->() -> Reference* {
        return &reference;
    }
};

template <invocable Function>
consteval auto constant_evaluate(auto value);

consteval auto constant_evaluate(auto value);

template <typename Derived, typename Base>
concept derivedFrom =
    __is_base_of(Base, Derived) &&
    is_convertible<Derived const volatile*, Base const volatile*>;

template <typename From, typename To>
concept convertibleTo = is_convertible<From, To> && requires {
    static_cast<To>(declval<From>());
};

template <typename T, typename... Args>
concept constructibleFrom = __is_constructible(T, Args...);

template <typename T>
concept moveConstructible = constructibleFrom<T, T> && convertibleTo<T, T>;

template <typename T>
concept copyConstructible =
    moveConstructible<T> && constructibleFrom<T, T&> && convertibleTo<T&, T> &&
    constructibleFrom<T, T const&> && convertibleTo<T const&, T> &&
    constructibleFrom<T, T const> && convertibleTo<T const, T>;

// boolean_testable is adapted from the exposition-only concept
// boolean-testable.
namespace detail {
    template <typename T>
    concept booleanTestableDetail = convertibleTo<T, bool>;
}

template <typename T>
concept booleanTestable = detail::booleanTestableDetail<T> && requires(T&& b) {
    { !forward<T>(b) } -> detail::booleanTestableDetail;
};

// `WeaklyEqualityComparableWith` is adapted from the exposition-only
// concept `__WeaklyEqualityComparableWith`.
namespace detail {
    template <typename T, typename U>
    concept weaklyEqualityComparableWith =
        requires(RemoveReference<T> const& t, RemoveReference<U> const& u) {
        { t == u } -> booleanTestableDetail;
        { t != u } -> booleanTestableDetail;
        { u == t } -> booleanTestableDetail;
        { u != t } -> booleanTestableDetail;
    };
}  // namespace detail

template <typename T>
concept equalityComparable = detail::weaklyEqualityComparableWith<T, T>;

namespace detail {
    template <typename T, typename U>
    concept partiallyOrderedWith = requires(RemoveReference<T> const& t,
                                            RemoveReference<U> const& u) {
        { t < u } -> booleanTestable;
        { t > u } -> booleanTestable;
        { t <= u } -> booleanTestable;
        { t >= u } -> booleanTestable;
        { u < t } -> booleanTestable;
        { u > t } -> booleanTestable;
        { u <= t } -> booleanTestable;
        { u >= t } -> booleanTestable;
    };
}  // namespace detail

template <typename T>
concept scopedEnum = is_scoped_enum<T>;

template <typename T, typename U>
concept narrowConvertible = requires() {
    U({declval<T>()});
};

// TODO: Support any integral.
template <int value>
concept powerOfTwo = ((value & (value - 1)) == 0);

// `is_trivially_relocatable` can be overrided by partial template
// specializations, such as:
//
// template <>
// constexpr bool is_trivially_relocatable<MyClass> = true;
//
// Trivially relocatable types can enable algorithms to make optimizations, such
// as relocating objects with `cat::copy_memory()` instead of `cat::move()`.
// By default, trivial types are trivially relocatable.
template <typename T>
constexpr bool is_trivially_relocatable = is_trivial<T>;

// Remove `const` qualifier from types for the purposes of querying
// relocatability.
template <typename T>
constexpr bool is_trivially_relocatable<T const> = is_trivially_relocatable<T>;

}  // namespace cat

// clang-format 12 sorts `CommonReference` before `CommonType` for some reason.
// clang-format off
#include "implementations/CommonType.tpp"
#include "implementations/CommonReference.tpp"
#include "implementations/constant_evaluate.tpp"
// clang-format on

namespace cat {

template <typename T, typename U>
concept commonReferenceWith =
    sameAs<CommonReference<T, U>, CommonReference<U, T>> &&
    convertibleTo<T, CommonReference<T, U>> &&
    convertibleTo<U, CommonReference<T, U>>;

template <typename T, typename U>
concept common_with = sameAs<CommonType<T, U>, CommonType<U, T>> && requires {
    static_cast<CommonType<T, U>>(declval<T>());
    static_cast<CommonType<T, U>>(declval<U>());
} && commonReferenceWith<AddLvalueReference<T const>,
                         AddLvalueReference<const U>> &&
    commonReferenceWith<AddLvalueReference<CommonType<T, U>>,
                        CommonReference<AddLvalueReference<const T>,
                                        AddLvalueReference<const U>>>;

}  // namespace cat
