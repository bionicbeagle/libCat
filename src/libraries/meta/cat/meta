// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

// TODO: Down with `typename`! clangd 15 emits false positive diagnostics if
// `typename` is not used for these type aliases. When that is solved, they
// should be streamlined out.

namespace cat {

// Forward declare numeric types. These are implemented in `<numeral>`.
enum class overflow_policies;

template <typename T, overflow_policies>
struct arithmetic;

struct bool2;
struct bool4;

template <typename T, typename storage_type, auto>
class arithmetic_ptr;

// TODO: `make_signed_type` and `make_unsigned_type` must handle cvref
// qualifiers.

namespace detail {
    template <typename T>
    struct make_signed_trait;

    template <>
    struct make_signed_trait<char> {
        using type = signed char;
    };
    template <>
    struct make_signed_trait<signed char> {
        using type = signed char;
    };
    template <>
    struct make_signed_trait<unsigned char> {
        using type = signed char;
    };
    template <>
    struct make_signed_trait<signed short> {
        using type = signed short;
    };
    template <>
    struct make_signed_trait<unsigned short> {
        using type = signed short;
    };
    template <>
    struct make_signed_trait<signed int> {
        using type = signed int;
    };
    template <>
    struct make_signed_trait<unsigned int> {
        using type = signed int;
    };
    template <>
    struct make_signed_trait<signed long> {
        using type = signed long;
    };
    template <>
    struct make_signed_trait<unsigned long> {
        using type = signed long;
    };
    template <>
    struct make_signed_trait<signed long long> {
        using type = signed long long;
    };
    template <>
    struct make_signed_trait<unsigned long long> {
        using type = signed long long;
    };

    template <typename T, auto policy>
    struct make_signed_trait<arithmetic<T, policy>> {
        using type = arithmetic<typename make_signed_trait<T>::type, policy>;
    };
}  // namespace detail

template <typename T>
using make_signed_type = typename detail::make_signed_trait<T>::type;

namespace detail {
    template <typename T>
    struct make_unsigned_trait;

    template <>
    struct make_unsigned_trait<char> {
        using type = unsigned char;
    };
    template <>
    struct make_unsigned_trait<signed char> {
        using type = unsigned char;
    };
    template <>
    struct make_unsigned_trait<unsigned char> {
        using type = unsigned char;
    };
    template <>
    struct make_unsigned_trait<signed short> {
        using type = unsigned short;
    };
    template <>
    struct make_unsigned_trait<unsigned short> {
        using type = unsigned short;
    };
    template <>
    struct make_unsigned_trait<signed int> {
        using type = unsigned int;
    };
    template <>
    struct make_unsigned_trait<unsigned int> {
        using type = unsigned int;
    };
    template <>
    struct make_unsigned_trait<signed long> {
        using type = unsigned long;
    };
    template <>
    struct make_unsigned_trait<unsigned long> {
        using type = unsigned long;
    };
    template <>
    struct make_unsigned_trait<signed long long> {
        using type = unsigned long long;
    };
    template <>
    struct make_unsigned_trait<unsigned long long> {
        using type = unsigned long long;
    };
}  // namespace detail

template <typename T>
using make_unsigned_type = typename detail::make_unsigned_trait<T>::type;

template <typename T, auto policy>
struct detail::make_unsigned_trait<arithmetic<T, policy>> {
    using type = arithmetic<typename make_unsigned_trait<T>::type, policy>;
};

namespace detail {
    template <typename T, typename U = T&&>
    constexpr auto declval_detail(signed int) -> U;

    template <typename T>
    constexpr auto declval_detail(signed long) -> T;
}  // namespace detail

template <typename T>
auto declval() -> decltype(detail::declval_detail<T>(0));

template <typename T>
using identity_type = T;

namespace detail {
    template <typename...>
    using void_type = void;

    template <typename>
    struct add_const_trait;

    template <typename T>
    struct add_const_trait {
        using type = T const;
    };

    template <typename T>
    struct add_const_trait<T&> {
        using type = T const&;
    };

    template <typename T>
    struct add_const_trait<T volatile> {
        using type = T const volatile;
    };

    template <typename T>
    struct add_const_trait<T&&> {
        using type = T const&&;
    };

    template <typename T>
    struct add_const_trait<T volatile&> {
        using type = T const volatile&;
    };

    template <typename T>
    struct add_const_trait<T volatile&&> {
        using type = T const volatile&&;
    };
}  // namespace detail

template <typename T>
using add_const = typename detail::add_const_trait<T>::type;

namespace detail {
    template <typename>
    struct add_volatile_trait;

    template <typename T>
    struct add_volatile_trait {
        using type = T volatile;
    };

    template <typename T>
    struct add_volatile_trait<T&> {
        using type = T volatile&;
    };

    template <typename T>
    struct add_volatile_trait<T&&> {
        using type = T volatile&&;
    };

    template <typename T>
    struct add_volatile_trait<T const> {
        using type = T const volatile;
    };

    template <typename T>
    struct add_volatile_trait<T const&> {
        using type = T const volatile&;
    };

    template <typename T>
    struct add_volatile_trait<T const&&> {
        using type = T const volatile&&;
    };
}  // namespace detail

template <typename T>
using add_volatile = typename detail::add_volatile_trait<T>::type;

template <typename T>
using add_cv = T const volatile;

namespace detail {
    template <typename T>
    struct remove_const_trait {
        using type = T;
    };
    template <typename T>
    struct remove_const_trait<T const> {
        using type = T;
    };
}  // namespace detail

template <typename T>
using remove_const = typename detail::remove_const_trait<T>::type;

namespace detail {
    template <typename T>
    struct remove_volatile_trait {
        using type = T;
    };
    template <typename T>
    struct remove_volatile_trait<T volatile> {
        using type = T;
    };
}  // namespace detail

template <typename T>
using remove_volatile = typename detail::remove_volatile_trait<T>::type;

namespace detail {
    template <typename T>
    struct remove_cv_trait {
        using type = T;
    };
    template <typename T>
    struct remove_cv_trait<T const> {
        using type = T;
    };
    template <typename T>
    struct remove_cv_trait<T volatile> {
        using type = T;
    };
    template <typename T>
    struct remove_cv_trait<T const volatile> {
        using type = T;
    };
}  // namespace detail

// TODO: Use GCC 13's `__remove_cv()`.
template <typename T>
using remove_cv = typename detail::remove_cv_trait<T>::type;

namespace detail {
    template <typename T>
    struct remove_reference_trait {
        using type = T;
    };
    template <typename T>
    struct remove_reference_trait<T&> {
        using type = T;
    };
    template <typename T>
    struct remove_reference_trait<T&&> {
        using type = T;
    };
}  // namespace detail

// TODO: Use GCC 13's `__remove_reference()`.
template <typename T>
using remove_reference = typename detail::remove_reference_trait<T>::type;

namespace detail {
    template <typename T>
    struct remove_cvref_trait {
        using type = remove_cv_trait<remove_reference_trait<T>>;
    };
}  // namespace detail

// TODO: Use GCC 13's `__remove_cvref()`.
template <typename T>
using remove_cvref = typename detail::remove_cvref_trait<T>::type::type::type;

namespace detail {
    template <typename T>
    struct remove_pointer_trait_detail {
        using type = T;
    };
    template <typename T>
    struct remove_pointer_trait_detail<T*> {
        using type = T;
    };
    template <typename T>
    struct remove_pointer_trait_detail<T* const> {
        using type = T;
    };
    template <typename T>
    struct remove_pointer_trait_detail<T* volatile> {
        using type = T;
    };
    template <typename T>
    struct remove_pointer_trait_detail<T* const volatile> {
        using type = T;
    };

    template <typename T>
    struct remove_pointer_trait : detail::remove_pointer_trait_detail<T> {};
}  // namespace detail

template <typename T>
using remove_pointer = typename detail::remove_pointer_trait<T>::type;

template <auto constant_value>
struct constant {
    static constexpr auto value = constant_value;
    using type = decltype(constant_value);
};

template <auto value>
inline constexpr auto constval = value;

using true_trait = constant<true>;
using false_trait = constant<false>;

namespace detail {
    template <bool, typename T, typename U>
    struct conditional_trait {
        using type = T;
    };
    template <typename T, typename U>
    struct conditional_trait<false, T, U> {
        using type = U;
    };
}  // namespace detail

template <bool condition, typename T, typename U>
using conditional = typename detail::conditional_trait<condition, T, U>::type;

template <typename T, typename U>
using larger_type = conditional<(sizeof(T) >= sizeof(U)), T, U>;

template <typename T, typename U>
using smaller_type = conditional<(sizeof(T) <= sizeof(U)), T, U>;

// `__is_enum()` is a GNU builtin.
template <typename T>
concept is_enum = __is_enum(T);

// `__is_same()` is a GNU builtin.
template <typename T, typename U>
concept is_same = __is_same(T, U);

// `__is_base_of()` is a GNU builtin.
template <typename T, typename U>
concept is_base_of = __is_base_of(T, U);

// `__is_union()` is a GNU builtin.
template <typename T>
concept is_union = __is_union(T);

// `__is_class()` is a GNU builtin.
template <typename T>
concept is_class = __is_class(T);

template <typename T>
concept is_referenceable = requires {
    // Try to substitute a `T&`. If that is well-formed, this always holds true.
    __is_same(T&, T&);
};

namespace detail {
    template <typename...>
    inline constexpr bool is_reference_detail = false;
    template <is_referenceable T>
    inline constexpr bool is_reference_detail<T> =
        __is_same(T, remove_reference<T>&) ||
        __is_same(T, remove_reference<T>&&);
}  // namespace detail

template <typename T>
concept is_reference = detail::is_reference_detail<T>;

template <typename, template <typename...> typename>
inline constexpr bool is_specialization = false;

template <template <typename...> typename Template, typename... Args>
inline constexpr bool is_specialization<Template<Args...>, Template> = true;

namespace detail {
    // TODO: Ignore reference in value categories here.
    // TODO: Include halfs, `_Float16`, `__fp16`, `__bf16`, etc.
    template <typename T>
    inline constexpr bool is_floating_point_detail =
        __is_same(remove_cv<T>, float) || __is_same(remove_cv<T>, double) ||
        __is_same(remove_cv<T>, long double) ||
        __is_same(remove_cv<T>, __float128);
    template <typename T, auto policy>
    inline constexpr bool is_floating_point_detail<arithmetic<T, policy>> =
        is_floating_point_detail<T>;
}  // namespace detail

template <typename T>
concept is_floating_point = detail::is_floating_point_detail<T>;

template <is_floating_point T>
struct detail::make_signed_trait<T> {
    using type = T;
};

namespace detail {
    // TODO: Remove references as well. That breaks some traits for some reason.
    // TODO: Support 16-byte integers.
    template <typename T>
    inline constexpr bool is_integral_detail =
        __is_same(remove_cv<T>, char) ||  //
        __is_same(remove_cv<T>, signed char) ||
        __is_same(remove_cv<T>, unsigned char) ||
        __is_same(remove_cv<T>, signed short) ||
        __is_same(remove_cv<T>, unsigned short) ||
        __is_same(remove_cv<T>, signed int) ||
        __is_same(remove_cv<T>, unsigned int) ||
        __is_same(remove_cv<T>, signed long) ||
        __is_same(remove_cv<T>, unsigned long) ||
        __is_same(remove_cv<T>, signed long long) ||
        __is_same(remove_cv<T>, unsigned long long);

    template <typename T, auto policy>
    inline constexpr bool is_integral_detail<arithmetic<T, policy>> =
        is_integral_detail<T>;

    template <typename T, typename storage_type, auto policy>
    inline constexpr bool
        is_integral_detail<arithmetic_ptr<T, storage_type, policy>> = true;
}  // namespace detail

template <typename T>
concept is_integral = detail::is_integral_detail<T>;

template <typename T>
concept is_bool = __is_same(T, remove_cvref<bool>) ||
                  __is_same(T, remove_cvref<bool2>) ||
                  __is_same(T, remove_cvref<bool4>);

template <typename T>
concept is_arithmetic = is_integral<T> || is_floating_point<T>;

namespace detail {
    template <typename T>
    concept has_less_than_operator = requires(T t) {
        t < static_cast<T>(0);
    };

    template <typename...>
    inline constexpr bool is_signed_detail = false;

    // This expression only holds true if `T` can be constant-evaluated.
    template <detail::has_less_than_operator T>
        requires(requires { T(-1); })
    inline constexpr bool is_signed_detail<T> = constval<(T(-1) < T(0))>;
}  // namespace detail

template <typename T>
concept is_signed = detail::is_signed_detail<T>;

template <typename T>
concept is_unsigned = !is_signed<T>;

template <typename T>
concept is_signed_integral = is_signed<T> && is_integral<T>;

template <typename T>
concept is_unsigned_integral = (!is_signed<T>)&&is_integral<T>;

template <is_integral Sign, is_integral T>
using copy_sign_from = conditional<is_signed<Sign>, make_signed_type<Sign>,
                                   detail::make_unsigned_trait<Sign>>;

template <typename T>
concept is_void = __is_same(T, void);

namespace detail {
    // TODO: For some reason, `__is_same(T, T const)` does not work.
    template <typename>
    inline constexpr bool is_const_detail = false;
    template <typename T>
    inline constexpr bool is_const_detail<T const> = true;
    template <typename T>
    inline constexpr bool is_const_detail<T const&> = true;
    template <typename T>
    inline constexpr bool is_const_detail<T const&&> = true;

    template <typename T>
    inline constexpr bool is_volatile_detail = __is_same(T, T volatile);

    template <typename T>
    inline constexpr bool is_pointer_detail = !__is_same(T, remove_pointer<T>);

    template <typename T>
    inline constexpr bool is_array_detail =
        !is_pointer_detail<T> && requires(T t) {
        t[0];
    };
}  // namespace detail

template <typename T>
concept is_const = detail::is_const_detail<T>;

template <typename T>
concept is_volatile = detail::is_volatile_detail<T>;

template <typename T>
concept is_pointer = detail::is_pointer_detail<T>;

template <typename T>
concept is_array = detail::is_array_detail<T>;

namespace detail {
    template <typename T>
    struct remove_extent_trait {
        using type = T;
    };
    template <typename T, int size>
    struct remove_extent_trait<T[size]> {
        using type = T;
    };
    template <typename T>
    struct remove_extent_trait<T[]> {
        using type = T;
    };
}  // namespace detail

template <typename T>
using remove_extent = typename detail::remove_extent_trait<T>::type;

namespace detail {
    template <typename T>
    struct is_member_pointer_trait : false_trait {};

    template <typename T, typename U>
    struct is_member_pointer_trait<T U::*> : true_trait {};
}  // namespace detail

template <typename T>
concept is_member_pointer =
    detail::is_member_pointer_trait<remove_cv<T>>::value;

namespace detail {
    template <typename T>
    struct is_member_function_pointer_helper_trait : false_trait {};

    // Forward declare this trait, so that it can be organized better later on.
    template <typename T>
    struct is_function_trait;

    template <typename T, typename U>
    struct is_member_function_pointer_helper_trait<T U::*>
        : is_function_trait<T> {};

    template <typename T>
    struct is_member_function_pointer_trait
        : is_member_function_pointer_helper_trait<remove_cv<T>> {};
}  // namespace detail

template <typename T>
concept is_member_function_pointer =
    detail::is_member_function_pointer_trait<T>::value;

template <typename T>
concept is_member_object_pointer =
    is_member_pointer<T> && !is_member_function_pointer<T>;

template <typename T>
concept is_null_pointer = __is_same(remove_cv<T>, decltype(nullptr));

template <typename T>
concept is_scalar = is_arithmetic<T> || is_enum<T> || is_pointer<T> ||
    is_member_pointer<T> || is_null_pointer<T>;

template <typename T>
using add_pointer = conditional<is_referenceable<T>, remove_reference<T>*, T*>;

template <typename T>
using add_lvalue_reference = T&;

template <typename T>
using add_rvalue_reference = T&&;

template <typename T>
concept is_lvalue_reference = __is_same(T, remove_reference<T>&);

template <typename T>
concept is_rvalue_reference = __is_same(T, remove_reference<T>&&);

template <typename From, typename To>
using copy_const_from = conditional<is_const<From>,
                                    // From is const.
                                    add_const<To>,
                                    // From is not const.
                                    remove_const<To>>;

template <typename From, typename To>
using copy_volatile_from = conditional<is_volatile<remove_reference<From>>,
                                       // From is volatile.
                                       add_volatile<To>,
                                       // From is not volatile.
                                       remove_volatile<To>>;

template <typename From, typename To>
using copy_ref_from =
    conditional<is_lvalue_reference<From>,
                // From is an l-value reference.
                add_lvalue_reference<remove_reference<To>>,
                conditional<is_rvalue_reference<From>,
                            // From is an r-value reference.
                            add_rvalue_reference<remove_reference<To>>,
                            // From is not a reference.
                            remove_reference<To>>>;

template <typename From, typename To>
using copy_cv_from = copy_volatile_from<From, copy_const_from<From, To>>;

template <typename From, typename To>
using copy_cvref_from = copy_ref_from<From, copy_cv_from<From, To>>;

namespace detail {
    // `__underlying_type` is a GNU builtin.
    template <typename T>
    struct underlying_type_trait {
        using type = __underlying_type(T);
    };
}  // namespace detail

// GCC 12 doesn't seem to compile this correctly if `__underlying_type()` is
// used directly.
template <typename T>
using underlying_type = typename detail::underlying_type_trait<T>::type;

template <typename From, typename To>
concept is_convertible = __is_convertible(From, To);

template <typename From, typename To>
concept is_implicitly_convertible =
    __is_assignable(To, From) ||
    __is_constructible(To, From) || is_convertible<From, To> ||
    __is_same(To, From);

// TODO: Add `__is_nothrow_convertible()` from GCC 13.

template <typename T>
concept is_sizable = requires {
    sizeof(T);
};

template <typename T>
concept is_scoped_enum = __is_enum(T) && is_sizable<T> &&
                         !is_implicitly_convertible<T, int>;
//     !requires(T t, void (*p_f)(int)) {
//     p_f(t);
// };

template <typename T>
inline constexpr bool is_object =
    is_scalar<T> || is_array<T> || is_union<T> || is_class<T>;

template <typename T>
concept is_function = !is_object<T>;

namespace detail {
    template <typename T>
    struct is_function_trait : constant<is_function<T>> {};
}  // namespace detail

// Remove `const`/`volatile`-qualifiers, references, and pointers from a
// type.
template <typename T>
using Decay = conditional<
    // Decay arrays to pointers.
    is_array<remove_reference<T>>, remove_extent<remove_reference<T>>*,
    conditional<
        // Decay functions into function pointers.
        is_function<remove_reference<T>>, add_pointer<remove_reference<T>>,
        // Otherwise, remove cv-qualifiers.
        remove_cv<remove_reference<T>>>>;

namespace detail {
    template <typename, unsigned = 0>
    struct extent_trait;

    template <typename>
    struct remove_all_extents_trait;

    template <typename T>
    struct remove_all_extents_trait {
        using type = T;
    };

    template <typename T>
    struct remove_all_extents_trait<T[]> {
        using type = typename remove_all_extents_trait<T>::type;
    };

    template <typename T, unsigned long long N>
    struct remove_all_extents_trait<T[N]> {
        using type = typename remove_all_extents_trait<T>::type;
    };
}  // namespace detail

// TODO: Figure out how to implement this with concepts.
/*
template <typename T>
struct IsBoundedarrayTrait : false_trait {};
template <typename T, signed long long N>
struct IsBoundedarrayTrait<T[N]> : true_trait {};
template <typename T>
inline constexpr bool is_bounded_array = IsBoundedarrayTrait<T>::value;

template <typename T>
struct IsUnboundedarrayTrait : true_trait {};
template <typename T, signed long long N>
struct IsUnboundedarrayTrait<T[N]> : false_trait {};
template <typename T>
inline constexpr bool is_unbounded_array = IsUnBoundedarrayTrait<T>::value;
*/

// `__is_constructible` is a GNU builtin.
template <typename T, typename... Args>
concept is_constructible = __is_constructible(T, Args...);

// `__is_trivially_constructible` is a GNU builtin.
template <typename T, typename... Args>
concept is_trivially_constructible = __is_trivially_constructible(T, Args...);

template <typename T>
concept is_default_constructible = requires {
    T();
};

template <typename T>
concept is_trivially_default_constructible = is_default_constructible<T> &&
    __is_trivially_constructible(T);

template <typename T>
concept is_copy_constructible = __is_constructible(T, T const&);

template <typename T>
concept is_trivially_copy_constructible =
    __is_trivially_constructible(T, T const&);

template <typename T>
concept is_move_constructible = __is_constructible(T, T&&);

template <typename T>
concept is_trivially_move_constructible = __is_trivially_constructible(T, T&&);

// There is no `__has_destructor()` GCC builtin.
template <typename T>
concept is_destructible = requires {
    ~T();
};

// `__has_trivial_destructor()` is a GNU builtin.
template <typename T>
concept is_trivially_destructible = is_destructible<T> &&
    __has_trivial_destructor(T);

// `__is_assingable` is a GNU builtin.
template <typename T, typename U>
concept is_assignable = __is_assignable(T, U);

// `__is_trivially_assignable` is a GNU builtin.
template <typename T, typename U>
concept is_trivially_assignable = __is_trivially_assignable(T, U);

template <typename T>
concept is_copy_assignable = __is_assignable(T, T const&);

template <typename T>
concept is_trivially_copy_assignable = __is_trivially_assignable(T, T const&);

template <typename T>
concept is_move_assignable = __is_assignable(T, T&&);

template <typename T>
concept is_trivially_move_assignable = __is_trivially_assignable(T, T&&);

// `__is_trivially_copyable()` is a GNU builtin.
template <typename T>
concept is_trivially_copyable = __is_trivially_copyable(T);

template <typename T>
concept is_trivial =
    is_trivially_copyable<T> && is_trivially_default_constructible<T>;

// TODO: Add `reference_constructs_from_temporary<>` and
// `reference_converts_from_temporary<>`.

}  // namespace cat

// Forward declare these from `<cat/utility>`.
namespace std {

template <typename T>
constexpr auto move(T&& input) -> cat::remove_reference<T>&&;

template <typename T>
constexpr auto forward(cat::remove_reference<T>& input) -> T&&;
template <typename T>
    requires(!cat::is_lvalue_reference<T>)
constexpr auto forward(cat::remove_reference<T>&& input) -> T&&;

}  // namespace std

namespace cat {

using std::forward;
using std::move;

// `rvalue` binds r-value references and excludes any other references. This
// is useful for perfect-forwarding parameter functions which could
// otherwise hide `const&` or `&&` overloads.
template <typename T>
concept rvalue = is_rvalue_reference<T&&> && !is_const<T>;

template <typename Function, typename... Args>
concept is_invocable = requires(Function func, Args&&... args) {
    func(forward<Args>(args)...);
};

// https://quuxplusone.github.io/blog/2019/02/06/arrow-proxy/
template <typename reference_type>
struct arrow_proxy {
    reference_type reference;
    auto operator->() -> reference_type* {
        return &reference;
    }
};

consteval auto constant_evaluate(is_invocable auto value) -> decltype(auto);

consteval auto constant_evaluate(auto value) -> decltype(auto);

namespace detail {
    template <typename T>
    concept is_boolean_testable_detail = is_convertible<T, bool>;
}

// boolean_testable is adapted from the exposition-only concept
// boolean-testable.
template <typename T>
concept is_boolean_testable = detail::is_boolean_testable_detail<T> &&
    requires(T&& b) {
    { !forward<T>(b) } -> detail::is_boolean_testable_detail;
};

// `weakly_equality_comparable_with` is adapted from the exposition-only
// concept `__weakly_equality_comparable_with`.
namespace detail {
    template <typename T, typename U>
    concept is_weakly_equality_comparable_with =
        requires(remove_reference<T> const& t, remove_reference<U> const& u) {
        { t == u } -> is_boolean_testable_detail;
        { t != u } -> is_boolean_testable_detail;
        { u == t } -> is_boolean_testable_detail;
        { u != t } -> is_boolean_testable_detail;
    };
}  // namespace detail

template <typename T>
concept is_equality_comparable =
    detail::is_weakly_equality_comparable_with<T, T>;

namespace detail {
    template <typename T, typename U>
    concept is_partially_ordered_with = requires(remove_reference<T> const& t,
                                                 remove_reference<U> const& u) {
        { t < u } -> is_boolean_testable;
        { t > u } -> is_boolean_testable;
        { t <= u } -> is_boolean_testable;
        { t >= u } -> is_boolean_testable;
        { u < t } -> is_boolean_testable;
        { u > t } -> is_boolean_testable;
        { u <= t } -> is_boolean_testable;
        { u >= t } -> is_boolean_testable;
    };
}  // namespace detail

template <typename T, typename U>
concept is_narrow_convertible = requires() {
    U({declval<T>()});
};

// `is_trivially_relocatable` can be overrided by partial template
// specializations, such as:
//
// template <>
// constexpr bool is_trivially_relocatable<MyClass> = true;
//
// Trivially relocatable types can enable algorithms to make optimizations,
// such as relocating objects with `cat::copy_memory()` instead of
// `cat::move()`. By default, trivial types are trivially relocatable.
template <typename T>
inline constexpr bool is_trivially_relocatable = is_trivial<T>;

// Remove `const` qualifier from types for the purposes of querying
// relocatability.
template <typename T>
inline constexpr bool is_trivially_relocatable<T const> =
    is_trivially_relocatable<T>;

}  // namespace cat

// clang-format 12 sorts `common_reference` before `common_type` for some
// reason.
// clang-format off
#include "implementations/common_type.tpp"
#include "implementations/common_reference.tpp"
#include "implementations/constant_evaluate.tpp"
// clang-format on

namespace cat {

template <typename T, typename U>
concept has_common_reference_with =
    is_same<common_reference<T, U>, common_reference<U, T>> &&
    is_convertible<T, common_reference<T, U>> &&
    is_convertible<U, common_reference<T, U>>;

template <typename T, typename U>
concept has_common_with =
    is_same<common_type<T, U>, common_type<U, T>> && requires {
    static_cast<common_type<T, U>>(declval<T>());
    static_cast<common_type<T, U>>(declval<U>());
} && has_common_reference_with<add_lvalue_reference<T const>,
                               add_lvalue_reference<const U>> &&
    has_common_reference_with<add_lvalue_reference<common_type<T, U>>,
                              common_reference<add_lvalue_reference<const T>,
                                               add_lvalue_reference<const U>>>;

}  // namespace cat
