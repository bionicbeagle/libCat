// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/allocator>

namespace cat {

class LinearAllocator : public AllocatorInterface<LinearAllocator> {
  private:
    template <typename T>
    struct LinearMemoryHandle : detail::BaseMemoryHandle<T> {
        T* p_storage;

        // TODO: Simplify with CRTP or deducing-this.
        auto get() -> decltype(auto) {
            return *this;
        }

        auto get() const -> decltype(auto) {
            return *this;
        }
    };

    LinearAllocator(uintptr<void> p_address, ssize arena_bytes)
        : p_arena_begin(p_address + static_cast<usize>(arena_bytes)),
          p_arena_end(p_address) {
    }

  public:
    // Allocate a `LinearAllocator` from another allocator.
    static auto backed(is_stable_allocator auto& backing, ssize arena_bytes)
        -> Maybe<LinearAllocator> {
        Span memory = TRY(backing.template alloc_multi<Byte>(arena_bytes));
        return LinearAllocator(memory.data(), arena_bytes);
    }

    // Allocate a `LinearAllocator` from another allocator, given a handle to
    // it.
    // TODO: Can this return a tuple of the allocator and handle?
    static auto backed_handle(is_stable_allocator auto& backing,
                              mem auto& handle) -> LinearAllocator {
        return LinearAllocator(backing.template p_get(handle),
                               handle.raw_size());
    }

    // TODO: Can this return a tuple of the allocator and handle?
    static auto backed_handle_sized(is_stable_allocator auto& backing,
                                    mem auto& handle, ssize arena_size)
        -> LinearAllocator {
        cat::assert(arena_size <= handle.raw_size());
        return LinearAllocator(backing.template p_get(handle), arena_size);
    }

    // Reset the bumped pointer to the beginning of this arena.
    void reset() {
        this->p_arena_current = p_arena_begin;
    }

  private:
    auto allocation_bytes(usize alignment, ssize allocation_bytes)
        -> MaybeNonZero<ssize> {
        uintptr<void> allocation = align_down(
            this->p_arena_current - usize{allocation_bytes}, alignment);

        // The allocation size is the difference between the current pointer
        // and the new pointer.
        if (allocation >= p_arena_end) {
            return static_cast<ssize>((this->p_arena_current - allocation).raw);
        }
        return nullopt;
    }

    // Try to allocate memory and bump the pointer down.
    auto allocate(ssize allocation_bytes) -> MaybePtr<void> {
        if (this->p_arena_current - allocation_bytes >= p_arena_end) {
            this->p_arena_current -= allocation_bytes;
            // Return a pointer that is then used to in-place construct a `T`.
            return this->p_arena_current;
        }
        return nullptr;
    }

    // Try to allocate memory aligned to some boundary and bump the pointer
    // down.
    auto aligned_allocate(usize alignment, ssize allocation_bytes)
        -> MaybePtr<void> {
        uintptr<void> allocation =
            align_down(this->p_arena_current - allocation_bytes, alignment);
        if (allocation >= p_arena_end) {
            this->p_arena_current = allocation;
            // Return a pointer that is then used for in-place construction.
            return static_cast<void*>(allocation);
        }
        return nullptr;
    }

    // Try to allocate memory and bump the pointer down, and return the memory
    // with size allocated.
    auto aligned_allocate_feedback(usize alignment, ssize allocation_bytes)
        -> MaybeSizedAllocation<void*> {
        uintptr<void> allocation =
            align_down(this->p_arena_current - allocation_bytes, alignment);
        if (allocation >= p_arena_end) {
            ssize bytes_allocated =
                static_cast<ssize>(this->p_arena_current - allocation);
            this->p_arena_current = allocation;

            return MaybeSizedAllocation<void*>(Tuple{
                // Return a pointer that is then used for in-place construction.
                static_cast<void*>(this->p_arena_current), bytes_allocated});
        }
        return nullopt;
    }

    // In general, memory cannot be deallocated in a linear allocator, so
    // this function is no-op.
    void deallocate(void const*, ssize) {
    }

    // Produce a handle to allocated memory.
    template <typename T>
    auto make_handle(T* p_handle_storage) -> LinearMemoryHandle<T> {
        return LinearMemoryHandle<T>{{}, p_handle_storage};
    }

    // Access some memory.
    template <typename T>
    auto access(LinearMemoryHandle<T>& memory) -> T* {
        return memory.p_storage;
    }

    template <typename T>
    auto access(LinearMemoryHandle<T> const& memory) const -> T const* {
        return memory.p_storage;
    }

  public:
    static constexpr bool has_pointer_stability = true;
  private:
    friend AllocatorInterface<LinearAllocator>;

    uintptr<void> const p_arena_begin;
    uintptr<void> const p_arena_end;
    uintptr<void> p_arena_current = p_arena_begin;
};

}  // namespace cat
