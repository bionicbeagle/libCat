// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/string>
#include <cat/tuple>

namespace cat {

template <typename T>
concept mem = requires(T handle) {
    handle.is_inline_handle;
    handle.is_multi_handle;
    handle.size();
    handle.raw_size();
    handle.is_inline();
};

inline constexpr ssize inline_buffer_size = 256;

// TODO: Handles' `.get()` should be only visible to allocators.
namespace detail {
    // `base_memory_handle` is an opaque memory handle. allocators are to define
    // and produce a memory handle type which derives from this. These handles
    // contain absolutely arbitrary storage (such as a `T*`, or an `ssize`
    // address offset). Handles must provide a `.get()` method to return
    // whatever that storage is.
    template <typename T>
    struct base_memory_handle {
        static constexpr bool is_inline_handle = false;
        static constexpr bool is_multi_handle = false;
        using allocation_type = T;

        // Number of `T`s allocated. This is always 1 if the call is not
        // intercepted by a `multi_memory_handle`.
        constexpr auto size() const -> ssize {
            return 1;
        }

        // If `.set_count()` is no-op if it is not intercepted by a
        // `multi_memory_handle`.
        void set_count(ssize) {
        }

        // Number of bytes allocated. This is always the size of `T` if the call
        // is not intercepted by a `multi_memory_handle`.
        constexpr auto raw_size() const -> ssize {
            return ssizeof(T);
        }

        // `is_inline()` always holds false if the call is not intercepted by an
        // `inline_memory_handle`.
        constexpr auto is_inline() const -> bool {
            return false;
        }
    };

    // A `multi_memory_handle` wraps another memory handle for `*_multi`
    // allocations. It effectively overrides `handle_type`'s `.size()` and
    // `.raw_size()` methods with the length of an allocated array.
    template <typename handle_type>
    struct multi_memory_handle {
        static constexpr bool is_inline_handle = handle_type::is_inline_handle;
        static constexpr bool is_multi_handle = true;
        using allocation_type = typename handle_type::allocation_type;
        handle_type handle;

        // How large this allocation was, in terms of `allocation_type`.
        ssize array_length;

        multi_memory_handle() = default;

        multi_memory_handle(handle_type input_handle) : handle(input_handle) {
        }

        // TODO: Variadic emplace.
        void set_inline_storage(allocation_type value) {
            this->handle.set_inline_storage(value);
        }

        void set_inlined(bool inlined) {
            this->handle.set_inlined(inlined);
        }

        // Intercept a propagating call to `.set_count()`.
        void set_count(ssize count) {
            this->array_length = count;
        }

        // Intercept a propagating call to `.size()`.
        auto size() const -> ssize {
            return this->array_length;
        }

        // Intercept a propagating call to `.raw_size()`.
        auto raw_size() const -> ssize {
            return this->array_length * ssizeof(allocation_type);
        }

        constexpr auto is_inline() const -> bool {
            return this->handle.is_inline();
        }

        // Get the allocator-specific handle type.
        auto get() & -> decltype(auto) {
            return this->handle.get();
        }

        // Get the allocator-specific handle type.
        auto get() const& -> decltype(auto) {
            return this->handle.get();
        }

        auto get_inline() & -> allocation_type& {
            return this->handle.get_inline();
        }

        auto get_inline() const& -> allocation_type const& {
            return this->handle.get_inline();
        }
    };

    // An `inline_memory_handle` wraps another memory handle for `inline_*`
    // allocations. It extends the storage of this handle to at least 256 bytes,
    // and if the memory allocated is smaller than that, it is stored inside the
    // handle instead of inside an allocator. It effectively overrides the
    // `.is_inline()` method of the handle that it wraps.
    template <typename handle_type>
    struct inline_memory_handle {
        static constexpr bool is_inline_handle = true;
        static constexpr bool is_multi_handle = handle_type::is_multi_handle;
        using allocation_type = typename handle_type::allocation_type;

        union {
            handle_type handle;
            allocation_type inline_storage;
            // Reserve `inline_buffer_size` bytes to make the size
            // of this handle predictible.
            byte empty[inline_buffer_size.raw];
        };

        bool is_on_stack;

        // The default constructor must not initialize data.
        // NOLINTNEXTLINE This would be ill-formed if it is `default`ed.
        inline_memory_handle() {
        }

        inline_memory_handle(handle_type input_handle)
            : handle(input_handle), is_on_stack(handle.is_inline()) {
        }

        ~inline_memory_handle() {
            if (this->is_on_stack) {
                this->inline_storage.~allocation_type();
            }
        }

        // Intercept a propagating call to `.set_inline_storage()`.
        // TODO: Variadic emplace.
        void set_inline_storage(allocation_type value) {
            this->inline_storage = value;
        }

        // Intercept a propagating call to `.set_inlined()`.
        void set_inlined(bool inlined) {
            this->is_on_stack = inlined;
        }

        void set_count(ssize count) {
            this->handle.set_count(count);
        }

        auto size() const -> ssize {
            return handle.size();
        }

        auto raw_size() const -> ssize {
            return handle.raw_size();
        }

        constexpr auto is_inline() const -> bool {
            return this->is_on_stack;
        }

        // Get the allocator-specific handle type.
        auto get() & -> decltype(auto) {
            return this->handle.get();
        }

        // Get the allocator-specific handle type.
        auto get() const& -> decltype(auto) {
            return this->handle.get();
        }

        // Intercept calls to `.get_inline()`.
        auto get_inline() & -> allocation_type& {
            return this->inline_storage;
        }

        // Intercept calls to `.get_inline()`.
        auto get_inline() const& -> allocation_type const& {
            return this->inline_storage;
        }
    };
}  // namespace detail

template <typename T, typename allocation_type = void*>
concept is_allocator = requires(T allocator) {
    // Every allocator has a  `.opq_alloc()` method.
    // One might not have `.alloc()`.
    allocator.template opq_alloc<allocation_type>();

    // TODO: It would be nice if these could make the concept more precise:
    // allocator.free(decltype(allocator.template make_handle<allocation_typeU>(
    //     allocation_typeU(), sizeof(allocation_typeU))){});
    // allocator.get(decltype(allocator.template make_handle<allocation_typeU>(
    //     allocation_typeU(), sizeof(allocation_typeU))){});
};

namespace detail {
    // `clangd` emits false-positive diagnostics if this constraint is used
    // anonymously without a `concept`.
    template <typename allocator_type>
    concept is_stable_derived_allocator = allocator_type::has_pointer_stability;

    template <typename allocator_type>
    concept has_allocate = requires(allocator_type allocator) {
        allocator.allocate(1_sz);
    };

    template <typename allocator_type>
    concept has_aligned_allocate = requires(allocator_type allocator) {
        allocator.aligned_allocate(1_uz, 1_sz);
    };

    template <typename allocator_type>
    concept has_allocation_size = requires(allocator_type allocator) {
        allocator.allocation_bytes(1_uz, 1_sz);
    };

    template <typename allocator_type>
    concept has_allocate_feedback = requires(allocator_type allocator) {
        allocator.allocate_feedback(1_sz);
    };

    template <typename allocator_type>
    concept has_aligned_allocate_feedback = requires(allocator_type allocator) {
        allocator.aligned_allocate_feedback(1_uz, 1_sz);
    };

    template <typename allocator_type>
    concept has_max_allocation_bytes = requires(allocator_type allocator) {
        allocator.max_allocation_bytes;
    };
}  // namespace detail

// TODO: Make unstable allocators.
template <typename allocator_type>
concept is_stable_allocator =
    is_allocator<allocator_type> && allocator_type::has_pointer_stability;

template <typename T>
using sized_allocation = tuple<T, ssize>;

template <typename T>
using maybe_sized_allocation = maybe<sized_allocation<T>>;

/* maybe<compact<sized_allocation<T>,
                     [](sized_allocation<T> tuple) -> bool {
                         return (tuple.second() != 0_sz);
                     },
                     sized_allocation<T>{T(), 0_sz}>>;
*/

// TODO: For some reason, this implementation of `opq_salloc()`, this returns an
// `int` in GCC 12. That must be some kind of bug. For now, a less efficient
// implementation is being used.
/*
    template <typename T,  typename... Args>
[[nodiscard]]constexpr auto opq_salloc(Args&&... constructor_args) {
maybe size = this->opq_nalloc<T>().value();

// GCC 12 fails to deduce the type of template aliases with a lambda in
// an unevaluted context, such as compact maybes, so it must be
// stored in a temporary value `return_val` first.
//
// `[[maybe_unused]]` is required because GCC 12 can mistakenly think
// this is uninitialized.
using alloc_type = sized_allocation<decltype(this->opq_xalloc<T, is_zeroed>())>;

if (size.has_value()) {
    [[maybe_unused]] maybe_sized_allocation<alloc_type> return_val =
        maybe_sized_allocation<alloc_type>{nullopt};
    return return_val;
}

// If `opq_nalloc()` did not fail, this cannot fail.
auto allocation =
    this->opq_xalloc<T, is_zeroed>(forward<Args>(constructor_args)...);

[[maybe_unused]] maybe_sized_allocation<alloc_type> return_val =
    maybe_sized_allocation<alloc_type>{alloc_type(allocation, 0_sz)};
return return_val;
}
*/

// TODO: `_multi` functions should take signed or unsigned integrals.

template <typename derived_type>
class allocator_interface {
  public:
    // Try to allocate a `T`.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_alloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_align_alloc<T>(alignof(T),
                                            forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_alloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a `T`.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_xalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_align_xalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_xalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto alloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_alloc<T>(alignof(T),
                                        forward<Args>(constructor_args)...);
        } else {
            return this->unalign_alloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto xalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_xalloc<T>(alignof(T),
                                         forward<Args>(constructor_args)...);
        } else {
            return this->unalign_xalloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate an array of `T`.
    template <typename T>
    [[nodiscard]] constexpr auto opq_alloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_align_alloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_alloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`.
    template <typename T>
    [[nodiscard]] constexpr auto opq_xalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_align_xalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_xalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of `T`,
    // and provide a pointer handle.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto alloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_alloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_alloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`, and
    // provide a pointer handle.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto xalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_xalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_align_alloc(
            usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, true, false, false, false, false>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with an alignment guarantee.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_align_xalloc(
            usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, false, false, false>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto align_alloc(usize alignment,
                                                 Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, true, false, true, false, false>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto align_xalloc(usize alignment,
                                                  Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, true, false, false>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a `T` with no alignment guarantee.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_unalign_alloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, false, false, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with no alignment guarantee.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_unalign_xalloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, false, false, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto unalign_alloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, true, false, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto unalign_xalloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, true, false, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate an array of `T` with alignment guarantee.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_alloc_multi(usize alignment,
                                                       ssize count) {
        return this
            ->meta_alloc<T, false, true, true, true, false, false, false>(
                alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_xalloc_multi(usize alignment,
                                                        ssize count) {
        return this
            ->meta_alloc<T, false, false, true, true, false, false, false>(
                alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto align_alloc_multi(usize alignment,
                                                       ssize count) {
        return this->meta_alloc<T, false, true, true, true, true, false, false>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto align_xalloc_multi(usize alignment,
                                                        ssize count) {
        return this
            ->meta_alloc<T, false, false, true, true, true, false, false>(
                alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_alloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, true, false, true, false, false, false>(
                1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_xalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, false, false, false>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto unalign_alloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, true, false, true, true, false, false>(
                1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto unalign_xalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, true, false, false>(
                1u, count);
    }

    // Try to allocate a small-size optimized `T`.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_alloc(
            Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_inline_align_alloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_inline_unalign_alloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a small-size optimized `T`.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_xalloc(
            Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_inline_align_xalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_inline_unalign_xalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_alloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_inline_align_alloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_inline_unalign_alloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_xalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_inline_align_xalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_inline_unalign_xalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_align_alloc(
        usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, true, true, false, false, false, false>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_align_xalloc(
        usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, true, false, false, false, false>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_unalign_alloc(
        Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, true, false, false, false, false, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_unalign_xalloc(
        Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, false, false, false, false, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_alloc_multi(usize alignment,
                                                              ssize count) {
        return this->meta_alloc<T, true, true, true, true, false, false, false>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_xalloc_multi(usize alignment,
                                                               ssize count) {
        return this
            ->meta_alloc<T, true, false, true, true, false, false, false>(
                alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_alloc_multi(ssize count) {
        return this
            ->meta_alloc<T, true, true, false, true, false, false, false>(
                1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_xalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, true, false, false, true, false, false, false>(
                1u, count);
    }

    // Try to get the number of bytes that allocating a `T` would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_nalloc() -> maybe_non_zero<ssize> {
        return this->opq_align_nalloc<T>(alignof(T));
    }

    // Get the number of bytes that allocating a `T` would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_xnalloc() -> ssize {
        return this->opq_align_xnalloc<T>(alignof(T));
    }

    // Try to get the number of bytes that allocating an array of `T` would
    // reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_nalloc_multi(ssize count)
        -> maybe_non_zero<ssize> {
        return this->opq_align_nalloc_multi<T>(alignof(T), count);
    }

    // Get the number of bytes that allocating an array of `T` would
    // reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_xnalloc_multi(ssize count) -> ssize {
        return this->opq_align_nalloc_multi<T>(alignof(T), count).value();
    }

    // Try to get the number of bytes that allocating a `T` with an alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_nalloc(usize alignment)
        -> maybe_non_zero<ssize> {
        return this->self().allocation_bytes(alignment, ssizeof(T));
    }

    // Get the number of bytes that allocating a `T` with an alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_xnalloc(usize alignment) -> ssize {
        return this->self().allocation_bytes(alignment, ssizeof(T)).value();
    }

    // Try to get the number of bytes that allocating a `T` with no alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_nalloc() -> maybe_non_zero<ssize> {
        return this->self().allocation_bytes(1u, ssizeof(T));
    }

    // Get the number of bytes that allocating a `T` with no alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_xnalloc() -> ssize {
        return this->self().allocation_bytes(1u, ssizeof(T)).value();
    }

    // Try to get the number of bytes that allocating an array of `T` with an
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_nalloc_multi(usize alignment,
                                                        ssize count)
        -> maybe_non_zero<ssize> {
        return this->self().allocation_bytes(alignment, ssizeof(T) * count);
    }

    // Get the number of bytes that allocating an array of `T` with an
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_xnalloc_multi(usize alignment,
                                                         ssize count) -> ssize {
        return this->self()
            .allocation_bytes(alignment, ssizeof(T) * count)
            .value();
    }

    // Try to get the number of bytes that allocating an array of `T` with no
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_nalloc_multi(ssize count)
        -> maybe_non_zero<ssize> {
        return this->self().allocation_bytes(1u, ssizeof(T) * count);
    }

    // Get the number of bytes that allocating an array of `T` with no
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_xnalloc_multi(ssize count)
        -> ssize {
        return this->self().allocation_bytes(1u, ssizeof(T) * count).value();
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_nalloc() -> maybe_non_zero<ssize> {
        return this->opq_inline_align_nalloc<T>(alignof(T));
    }

    // Get the number of bytes that allocating a small-size optimized `T`
    // would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_xnalloc() -> ssize {
        return this->opq_inline_align_xnalloc<T>(alignof(T));
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_nalloc_multi(ssize count)
        -> maybe_non_zero<ssize> {
        return this->opq_inline_align_nalloc_multi<T>(alignof(T), count);
    }

    // Get the number of bytes that allocating a small-size optimized array of
    // `T` would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_xnalloc_multi(ssize count)
        -> ssize {
        return this->opq_inline_align_xnalloc_multi<T>(alignof(T), count);
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_nalloc(usize alignment)
        -> maybe_non_zero<ssize> {
        if constexpr (ssizeof(T) > inline_buffer_size) {
            return this->self().allocation_bytes(alignment, ssizeof(T));
        } else {
            return inline_buffer_size;
        }
    }

    // Get the number of bytes that allocating a small-size optimized `T` with
    // an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_xnalloc(usize alignment)
        -> ssize {
        return this->opq_inline_align_nalloc<T>(alignment).value();
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_nalloc()
        -> maybe_non_zero<ssize> {
        return this->opq_inline_align_nalloc<T>(1u);
    }

    // Get the number of bytes that allocating a small-size optimized `T` with
    // no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_xnalloc() -> ssize {
        return this->opq_inline_align_xnalloc<T>(1u);
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_nalloc_multi(usize alignment,
                                                               ssize count)
        -> maybe_non_zero<ssize> {
        if (ssizeof(T) * count > inline_buffer_size) {
            return this->self().allocation_bytes(alignment, ssizeof(T) * count);
        }
        return inline_buffer_size;
    }

    // Get the number of bytes that allocating a small-size optimized
    // array of `T` with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_xnalloc_multi(usize alignment,
                                                                ssize count)
        -> ssize {
        return this->opq_inline_align_nalloc_multi<T>(alignment, count).value();
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_nalloc_multi(ssize count)
        -> maybe_non_zero<ssize> {
        return this->opq_inline_align_nalloc_multi<T>(1u, count);
    }

    // Get the number of bytes that allocating a small-size optimized
    // array of `T` with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_xnalloc_multi(ssize count)
        -> ssize {
        return this->opq_inline_align_xnalloc_multi<T>(1u, count);
    }

    // Try to allocate a `T`, and return the number of bytes that were
    // allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_salloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_salloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_salloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a `T`, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_xsalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xsalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_xsalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto salloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_salloc<T>(alignof(T),
                                         forward<Args>(constructor_args)...);
        } else {
            return this->unalign_salloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto xsalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_xsalloc<T>(alignof(T),
                                          forward<Args>(constructor_args)...);
        } else {
            return this->unalign_xsalloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate an array of `T`, and return the number of bytes that were
    // allocated.
    template <typename T>
    [[nodiscard]] constexpr auto opq_salloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_salloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_salloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`, and return the number of bytes that were
    // allocated.
    template <typename T>
    [[nodiscard]] constexpr auto opq_xsalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xsalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_xsalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of `T`,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto salloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_salloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_salloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto xsalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_xsalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xsalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee, and return the number
    // of bytes that were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_align_salloc(
            usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, true, false, false, false, true>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with an alignment guarantee, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_align_xsalloc(
            usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, false, false, true>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto align_salloc(usize alignment,
                                                  Args&&... constructor_args) {
        return this->meta_alloc<T, false, true, true, false, true, false, true>(
            alignment, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto align_xsalloc(usize alignment,
                                                   Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, true, false, true>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a `T` with no alignment guarantee, and return the number
    // of bytes that were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_unalign_salloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, false, false, true>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with no alignment guarantee, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_unalign_xsalloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, false, false, true>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto unalign_salloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, true, false, true>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto unalign_xsalloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, true, false, true>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_salloc_multi(usize alignment,
                                                        ssize count) {
        return this->meta_alloc<T, false, true, true, true, false, false, true>(
            alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_xsalloc_multi(usize alignment,
                                                         ssize count) {
        return this
            ->meta_alloc<T, false, false, true, true, false, false, true>(
                alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto align_salloc_multi(usize alignment,
                                                        ssize count) {
        return this->meta_alloc<T, false, true, true, true, true, false, true>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with an
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto align_xsalloc_multi(usize alignment,
                                                         ssize count) {
        return this->meta_alloc<T, false, false, true, true, true, false, true>(
            alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_salloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, true, false, true>(
            1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_xsalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, false, false, true>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto unalign_salloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, true, false, true>(
            1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with no
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto unalign_xsalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, true, false, true>(
                1u, count);
    }

    // Try to allocate a small-size optimized `T`, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_salloc(
            Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_salloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_inline_unalign_salloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a small-size optimized `T`, and return the number of bytes that
    // were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_xsalloc(
            Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_xsalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_inline_unalign_xsalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`, and return the
    // number of bytes that were allocated.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_salloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_salloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_inline_unalign_salloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_xsalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_xsalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_inline_unalign_xsalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_align_salloc(
            usize alignment, Args&&... constructor_args) {
        return this->meta_alloc<T, true, true, true, false, false, false, true>(
            alignment, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_align_xsalloc(
            usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, true, false, false, false, true>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_unalign_salloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, true, false, false, false, false, true>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_unalign_xsalloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, false, false, false, false, true>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_salloc_multi(usize alignment,
                                                               ssize count) {
        return this->meta_alloc<T, true, true, false, true, false, false, true>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_xsalloc_multi(usize alignment,
                                                                ssize count) {
        return this->meta_alloc<T, true, false, true, true, false, false, true>(
            alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_salloc_multi(ssize count) {
        return this->meta_alloc<T, true, true, false, true, false, false, true>(
            1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_xsalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, true, false, false, true, false, false, true>(
                1u, count);
    }

    // Try to allocate a `T`.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_calloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_calloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_calloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a `T`.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_xcalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xcalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_xcalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto calloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_calloc<T>(alignof(T),
                                         forward<Args>(constructor_args)...);
        } else {
            return this->unalign_calloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto xcalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_xcalloc<T>(alignof(T),
                                          forward<Args>(constructor_args)...);
        } else {
            return this->unalign_xcalloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate an array of `T`.
    template <typename T>
    [[nodiscard]] constexpr auto opq_calloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_calloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_calloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`.
    template <typename T>
    [[nodiscard]] constexpr auto opq_xcalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xcalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_xcalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T`, and provide a pointer handle.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto calloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_calloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_calloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`, and
    // provide a pointer handle.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto xcalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_xcalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xcalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_align_calloc(
            usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, true, false, false, true, false>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with an alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_align_xcalloc(
            usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, false, true, false>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto align_calloc(usize alignment,
                                                  Args&&... constructor_args) {
        return this->meta_alloc<T, false, true, true, false, true, true, false>(
            alignment, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto align_xcalloc(usize alignment,
                                                   Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, true, true, false>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a `T` with no alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_unalign_calloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, false, true, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with no alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_unalign_xcalloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, false, true, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto unalign_calloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, true, true, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>&&
                 is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto unalign_xcalloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, true, true, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate an array of `T` with alignment guarantee, and zero-out
    // the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_calloc_multi(usize alignment,
                                                        ssize count) {
        return this->meta_alloc<T, false, true, true, true, false, true, false>(
            alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_xcalloc_multi(usize alignment,
                                                         ssize count) {
        return this
            ->meta_alloc<T, false, false, true, true, false, true, false>(
                alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with an alignment guarantee, and provide a pointer handle, and
    // zero-out the allocated memory.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto align_calloc_multi(usize alignment,
                                                        ssize count) {
        return this->meta_alloc<T, false, true, true, true, true, true, false>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle, and zero-out
    // the allocated memory.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto align_xcalloc_multi(usize alignment,
                                                         ssize count) {
        return this->meta_alloc<T, false, false, true, true, true, true, false>(
            alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee, and zero-out
    // the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_calloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, true, true, false>(
            1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_xcalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, true, true, false>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with no alignment guarantee, and provide a pointer handle, and
    // zero-out the allocated memory.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto unalign_calloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, true, true, false>(
            1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle, and zero-out
    // the allocated memory.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto unalign_xcalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, true, true, false>(
                1u, count);
    }

    // Try to allocate a small-size optimized `T`, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_calloc(
            Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_calloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_inline_unalign_calloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a small-size optimized `T`, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_xcalloc(
            Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_xcalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_inline_unalign_xcalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_calloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_calloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_inline_unalign_calloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_xcalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_xcalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_inline_unalign_xcalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_align_calloc(
            usize alignment, Args&&... constructor_args) {
        return this->meta_alloc<T, true, true, true, false, false, true, false>(
            alignment, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee, and
    // zero-out the allocated memory.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_align_xcalloc(
            usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, true, false, false, true, false>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_unalign_calloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, true, false, false, false, true, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee, and
    // zero-out the allocated memory.
    template <typename T, typename... Args>
    requires(is_constructible<T, Args...>)
        [[nodiscard]] constexpr auto opq_inline_unalign_xcalloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, false, false, false, true, false>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_calloc_multi(usize alignment,
                                                               ssize count) {
        return this->meta_alloc<T, true, true, true, true, false, true, false>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_xcalloc_multi(usize alignment,
                                                                ssize count) {
        return this->meta_alloc<T, true, false, true, true, false, true, false>(
            alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_calloc_multi(ssize count) {
        return this->meta_alloc<T, true, true, false, true, false, true, false>(
            1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_xcalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, true, false, false, true, false, true, false>(
                1u, count);
    }

    // Try to allocate a `T`, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_scalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_scalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_scalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a `T`, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_xscalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xscalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_xscalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto scalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_scalloc<T>(alignof(T),
                                          forward<Args>(constructor_args)...);
        } else {
            return this->unalign_scalloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto xscalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_xscalloc<T>(alignof(T),
                                           forward<Args>(constructor_args)...);
        } else {
            return this->unalign_xscalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate an array of `T`, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_scalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_scalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_scalloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_xscalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xscalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_xscalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T`, and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto scalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_scalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_scalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`,
    // and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto xscalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->align_xscalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xscalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee, and return the number
    // of bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_align_scalloc(usize alignment,
                                                   Args&&... constructor_args) {
        return this->meta_alloc<T, false, true, true, false, false, true, true>(
            alignment, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with an alignment guarantee, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_align_xscalloc(
        usize alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, false, true, true>(
                alignment, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto align_scalloc(usize alignment,
                                                   Args&&... constructor_args) {
        return this->meta_alloc<T, false, true, true, false, true, true, true>(
            alignment, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto align_xscalloc(
            usize alignment, Args&&... constructor_args) {
        return this->meta_alloc<T, false, false, true, false, true, true, true>(
            alignment, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a `T` with no alignment guarantee, and return the number
    // of bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_unalign_scalloc(
        Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, false, true, true>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with no alignment guarantee, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_unalign_xscalloc(
        Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, false, true, true>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto unalign_scalloc(
            Args&&... constructor_args) {
        return this->meta_alloc<T, false, true, false, false, true, true, true>(
            1u, 1, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto unalign_xscalloc(
            Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, true, true, true>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_scalloc_multi(usize alignment,
                                                         ssize count) {
        return this->meta_alloc<T, false, true, true, true, false, true, true>(
            alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_align_xscalloc_multi(usize alignment,
                                                          ssize count) {
        return this->meta_alloc<T, false, false, true, true, false, true, true>(
            alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with an alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto align_scalloc_multi(usize alignment,
                                                         ssize count) {
        return this->meta_alloc<T, false, true, true, true, true, true, true>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with
    // an alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto align_xscalloc_multi(usize alignment,
                                                          ssize count) {
        return this->meta_alloc<T, false, false, true, true, true, true, true>(
            alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_scalloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, false, true, true>(
            1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_unalign_xscalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, false, true, true>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with no alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto unalign_scalloc_multi(ssize count) {
        return this->meta_alloc<T, false, true, false, true, true, true, true>(
            1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with
    // no alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    requires(detail::is_stable_derived_allocator<derived_type>)
        [[nodiscard]] constexpr auto unalign_xscalloc_multi(ssize count) {
        return this->meta_alloc<T, false, false, false, true, true, true, true>(
            1u, count);
    }

    // Try to allocate a small-size optimized `T`, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_scalloc(
        Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_scalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_inline_unalign_scalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a small-size optimized `T`, and return the number of bytes that
    // were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_xscalloc(
        Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_xscalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_inline_unalign_xscalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`, and return the
    // number of bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_scalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_scalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_inline_unalign_scalloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_xscalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_inline_align_xscalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_inline_unalign_xscalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee,
    // and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_align_scalloc(
        usize alignment, Args&&... constructor_args) {
        return this->meta_alloc<T, true, true, true, false, false, true, true>(
            alignment, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_align_xscalloc(
        usize alignment, Args&&... constructor_args) {
        return this->meta_alloc<T, true, false, true, false, false, true, true>(
            alignment, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee,
    // and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_unalign_scalloc(
        Args&&... constructor_args) {
        return this->meta_alloc<T, true, true, false, false, false, true, true>(
            1u, 1, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]] constexpr auto opq_inline_unalign_xscalloc(
        Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, false, false, false, true, true>(
                1u, 1, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_scalloc_multi(usize alignment,
                                                                ssize count) {
        return this->meta_alloc<T, true, true, true, true, false, true, true>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_align_xscalloc_multi(
        usize alignment, ssize count) {
        return this->meta_alloc<T, true, false, true, true, false, true, true>(
            alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_scalloc_multi(ssize count) {
        return this->meta_alloc<T, true, true, false, true, false, true, true>(
            1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto opq_inline_unalign_xscalloc_multi(
        ssize count) {
        return this->meta_alloc<T, true, false, false, true, false, true, true>(
            1u, count);
    }

    // Try to move a memory handle from this allocator into another.
    [[nodiscard]] constexpr auto opq_realloc_to(auto& allocator,
                                                mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_alloc<T, T>, allocator,
            handle);
    }

    // Try to move a memory handle from this allocator into itself.
    [[nodiscard]] constexpr auto opq_realloc(mem auto& handle) {
        return this->opq_realloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another.
    template <typename T>
    [[nodiscard]] constexpr auto realloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::alloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself.
    template <typename T>
    [[nodiscard]] constexpr auto realloc(T* p_handle) {
        return this->realloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another.
    [[nodiscard]] constexpr auto opq_xrealloc_to(auto& allocator,
                                                 mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_xalloc<T, T>, allocator,
            handle);
    }

    // Move a memory handle from this allocator into itself.
    [[nodiscard]] constexpr auto opq_xrealloc(mem auto& handle) {
        return this->opq_xrealloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another.
    template <typename T>
    [[nodiscard]] constexpr auto xrealloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::xalloc<T, T>, allocator,
            p_handle);
    }

    // Move a pointer handle from this allocator into itself.
    template <typename T>
    [[nodiscard]] constexpr auto xrealloc(T* p_handle) {
        return this->xrealloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee.
    [[nodiscard]] constexpr auto opq_align_realloc_to(auto& allocator,
                                                      mem auto& handle,
                                                      usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_align_alloc<T, T>,
            allocator, handle, alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee.
    [[nodiscard]] constexpr auto opq_align_realloc(mem auto& handle,
                                                   usize alignment) {
        return this->opq_align_realloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee.
    [[nodiscard]] constexpr auto opq_align_xrealloc_to(auto& allocator,
                                                       mem auto& handle,
                                                       usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_align_xalloc<T, T>,
            allocator, handle, alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee.
    auto opq_align_xrealloc(mem auto& handle, usize alignment) {
        return this->opq_align_xrealloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee.
    [[nodiscard]] constexpr auto opq_unalign_realloc_to(auto& allocator,
                                                        mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_unalign_alloc<T, T>,
            allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee.
    [[nodiscard]] constexpr auto opq_unalign_realloc(mem auto& handle) {
        return this->opq_unalign_realloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee.
    [[nodiscard]] constexpr auto opq_unalign_xrealloc_to(auto& allocator,
                                                         mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_unalign_xalloc<T, T>,
            allocator, handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee.
    auto opq_unalign_xrealloc(mem auto& handle) {
        return this->opq_unalign_xrealloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee.
    [[nodiscard]] constexpr auto align_realloc_to(auto& allocator,
                                                  auto* p_handle,
                                                  usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::align_alloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee.
    [[nodiscard]] constexpr auto align_realloc(auto* p_handle,
                                               usize alignment) {
        return this->align_realloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee.
    [[nodiscard]] constexpr auto align_xrealloc_to(auto& allocator,
                                                   auto* p_handle,
                                                   usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::align_xalloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee.
    auto align_xrealloc(auto* p_handle, usize alignment) {
        return this->align_xrealloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee.
    [[nodiscard]] constexpr auto unalign_realloc_to(auto& allocator,
                                                    auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::unalign_alloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee.
    [[nodiscard]] constexpr auto unalign_realloc(auto* p_handle) {
        return this->unalign_realloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee.
    [[nodiscard]] constexpr auto unalign_xrealloc_to(auto& allocator,
                                                     auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::unalign_xalloc<T, T>, allocator,
            p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee.
    auto unalign_xrealloc(auto* p_handle) {
        return this->unalign_xrealloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another.
    [[nodiscard]] constexpr auto opq_realloc_multi_to(auto& allocator,
                                                      mem auto& handle,
                                                      ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_alloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move an array memory handle from this allocator into itself.
    [[nodiscard]] constexpr auto opq_realloc_multi(mem auto& handle,
                                                   ssize new_count) {
        return this->opq_realloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another.
    template <typename T>
    [[nodiscard]] constexpr auto realloc_multi_to(auto& allocator, T* p_handle,
                                                  ssize old_count,
                                                  ssize new_count) {
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::alloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself.
    template <typename T>
    [[nodiscard]] constexpr auto realloc_multi(T* p_handle, ssize old_count,
                                               ssize new_count) {
        return this->realloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another.
    [[nodiscard]] constexpr auto opq_xrealloc_multi_to(auto& allocator,
                                                       mem auto& handle,
                                                       ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_xalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself.
    [[nodiscard]] constexpr auto opq_xrealloc_multi(mem auto& handle,
                                                    ssize new_count) {
        return this->opq_xrealloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another.
    template <typename T>
    [[nodiscard]] constexpr auto xrealloc_multi_to(auto& allocator, T* p_handle,
                                                   ssize old_count,
                                                   ssize new_count) {
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::xalloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself.
    template <typename T>
    [[nodiscard]] constexpr auto xrealloc_multi(T* p_handle, ssize old_count,
                                                ssize new_count) {
        return this->xrealloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another.
    [[nodiscard]] constexpr auto opq_align_realloc_multi_to(auto& allocator,
                                                            mem auto& handle,
                                                            usize alignment,
                                                            ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_align_alloc_multi<T>,
            allocator, handle, new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee.
    [[nodiscard]] constexpr auto opq_align_realloc_multi(mem auto& handle,
                                                         usize alignment,
                                                         ssize new_count) {
        return this->opq_align_realloc_multi_to(*this, handle, alignment,
                                                new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee.
    [[nodiscard]] constexpr auto opq_align_xrealloc_multi_to(auto& allocator,
                                                             mem auto& handle,
                                                             usize alignment,
                                                             ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_align_xalloc_multi<T>,
            allocator, handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee.
    auto opq_align_xrealloc_multi(mem auto& handle, usize alignment,
                                  ssize new_count) {
        return this->opq_align_xrealloc_multi_to(*this, handle, alignment,
                                                 new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee.
    [[nodiscard]] constexpr auto opq_unalign_realloc_multi_to(auto& allocator,
                                                              mem auto& handle,
                                                              ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_unalign_alloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee.
    [[nodiscard]] constexpr auto opq_unalign_realloc_multi(mem auto& handle,
                                                           ssize new_count) {
        return this->opq_unalign_realloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee.
    [[nodiscard]] constexpr auto opq_unalign_xrealloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_unalign_xalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee.
    auto opq_unalign_xrealloc_multi(mem auto& handle, ssize new_count) {
        return this->opq_unalign_xrealloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee.
    [[nodiscard]] constexpr auto align_realloc_multi_to(auto& allocator,
                                                        auto* p_handle,
                                                        usize alignment,
                                                        ssize old_count,
                                                        ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::align_alloc_multi<T>, allocator,
            p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee.
    [[nodiscard]] constexpr auto align_realloc_multi(auto* p_handle,
                                                     usize alignment,
                                                     ssize old_count,
                                                     ssize new_count) {
        return this->align_realloc_multi_to(*this, p_handle, alignment,
                                            old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee.
    [[nodiscard]] constexpr auto align_xrealloc_multi_to(auto& allocator,
                                                         auto* p_handle,
                                                         usize alignment,
                                                         ssize old_count,
                                                         ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::align_xalloc_multi<T>,
            allocator, p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee.
    auto align_xrealloc_multi(auto* p_handle, usize alignment, ssize old_count,
                              ssize new_count) {
        return this->align_xrealloc_multi_to(*this, p_handle, alignment,
                                             old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee.
    [[nodiscard]] constexpr auto unalign_realloc_multi_to(auto& allocator,
                                                          auto* p_handle,
                                                          ssize old_count,
                                                          ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::unalign_alloc_multi<T>,
            allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee.
    [[nodiscard]] constexpr auto unalign_realloc_multi(auto* p_handle,
                                                       ssize old_count,
                                                       ssize new_count) {
        return this->unalign_realloc_multi_to(*this, p_handle, old_count,
                                              new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee.
    [[nodiscard]] constexpr auto unalign_xrealloc_multi_to(auto& allocator,
                                                           auto* p_handle,
                                                           ssize old_count,
                                                           ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::unalign_xalloc_multi<T>,
            allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee.
    auto unalign_xrealloc_multi(auto* p_handle, ssize old_count,
                                ssize new_count) {
        return this->unalign_xrealloc_multi_to(*this, p_handle, old_count,
                                               new_count);
    }

    // Try to move a memory handle from this allocator into another, and
    // zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_recalloc_to(auto& allocator,
                                                 mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_calloc<T, T>, allocator,
            handle);
    }

    // Try to move a memory handle from this allocator into itself, and zero-out
    // the allocated memory.
    [[nodiscard]] constexpr auto opq_recalloc(mem auto& handle) {
        return this->opq_recalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto recalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::calloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto recalloc(T* p_handle) {
        return this->recalloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another, and zero-out the
    // allocated memory.
    [[nodiscard]] constexpr auto opq_xrecalloc_to(auto& allocator,
                                                  mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_xcalloc<T, T>, allocator,
            handle);
    }

    // Move a memory handle from this allocator into itself, and zero-out the
    // allocated memory.
    [[nodiscard]] constexpr auto opq_xrecalloc(mem auto& handle) {
        return this->opq_xrecalloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto xrecalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::xcalloc<T, T>, allocator,
            p_handle);
    }

    // Move a pointer handle from this allocator into itself, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto xrecalloc(T* p_handle) {
        return this->xrecalloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_align_recalloc_to(auto& allocator,
                                                       mem auto& handle,
                                                       usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_align_calloc<T, T>,
            allocator, handle, alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_align_recalloc(mem auto& handle,
                                                    usize alignment) {
        return this->opq_align_recalloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_align_xrecalloc_to(auto& allocator,
                                                        mem auto& handle,
                                                        usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_align_xcalloc<T, T>,
            allocator, handle, alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee, and zero-out the allocated memory.
    auto opq_align_xrecalloc(mem auto& handle, usize alignment) {
        return this->opq_align_xrecalloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_unalign_recalloc_to(auto& allocator,
                                                         mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_unalign_calloc<T, T>,
            allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_unalign_recalloc(mem auto& handle) {
        return this->opq_unalign_recalloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_unalign_xrecalloc_to(auto& allocator,
                                                          mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_unalign_xcalloc<T, T>,
            allocator, handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee, and zero-out the allocated memory.
    auto opq_unalign_xrecalloc(mem auto& handle) {
        return this->opq_unalign_xrecalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto align_recalloc_to(auto& allocator,
                                                   auto* p_handle,
                                                   usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::align_calloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto align_recalloc(auto* p_handle,
                                                usize alignment) {
        return this->align_recalloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto align_xrecalloc_to(auto& allocator,
                                                    auto* p_handle,
                                                    usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::align_xcalloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee, and zero-out the allocated memory.
    auto align_xrecalloc(auto* p_handle, usize alignment) {
        return this->align_xrecalloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto unalign_recalloc_to(auto& allocator,
                                                     auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::unalign_calloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto unalign_recalloc(auto* p_handle) {
        return this->unalign_recalloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto unalign_xrecalloc_to(auto& allocator,
                                                      auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::unalign_xcalloc<T, T>,
            allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee, and zero-out the allocated memory.
    auto unalign_xrecalloc(auto* p_handle) {
        return this->unalign_xrecalloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another, and
    // zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_recalloc_multi_to(auto& allocator,
                                                       mem auto& handle,
                                                       ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_calloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move an array memory handle from this allocator into itself, and
    // zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_recalloc_multi(mem auto& handle,
                                                    ssize new_count) {
        return this->opq_recalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto recalloc_multi_to(auto& allocator, T* p_handle,
                                                   ssize old_count,
                                                   ssize new_count) {
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::calloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto recalloc_multi(T* p_handle, ssize old_count,
                                                ssize new_count) {
        return this->recalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_xrecalloc_multi_to(auto& allocator,
                                                        mem auto& handle,
                                                        ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_xcalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself,
    // and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_xrecalloc_multi(mem auto& handle,
                                                     ssize new_count) {
        return this->opq_xrecalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another,
    // and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto xrecalloc_multi_to(auto& allocator,
                                                    T* p_handle,
                                                    ssize old_count,
                                                    ssize new_count) {
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::xcalloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself,
    // and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]] constexpr auto xrecalloc_multi(T* p_handle, ssize old_count,
                                                 ssize new_count) {
        return this->xrecalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_align_recalloc_multi_to(auto& allocator,
                                                             mem auto& handle,
                                                             usize alignment,
                                                             ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_align_calloc_multi<T>,
            allocator, handle, new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_align_recalloc_multi(mem auto& handle,
                                                          usize alignment,
                                                          ssize new_count) {
        return this->opq_align_recalloc_multi_to(*this, handle, alignment,
                                                 new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_align_xrecalloc_multi_to(auto& allocator,
                                                              mem auto& handle,
                                                              usize alignment,
                                                              ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_align_xcalloc_multi<T>,
            allocator, handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee, and zero-out the allocated memory.
    auto opq_align_xrecalloc_multi(mem auto& handle, usize alignment,
                                   ssize new_count) {
        return this->opq_align_xrecalloc_multi_to(*this, handle, alignment,
                                                  new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_unalign_recalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_unalign_calloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_unalign_recalloc_multi(mem auto& handle,
                                                            ssize new_count) {
        return this->opq_unalign_recalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_unalign_xrecalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_unalign_xcalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee, and zero-out the allocated memory.
    auto opq_unalign_xrecalloc_multi(mem auto& handle, ssize new_count) {
        return this->opq_unalign_xrecalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto align_recalloc_multi_to(auto& allocator,
                                                         auto* p_handle,
                                                         usize alignment,
                                                         ssize old_count,
                                                         ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::align_calloc_multi<T>,
            allocator, p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto align_recalloc_multi(auto* p_handle,
                                                      usize alignment,
                                                      ssize old_count,
                                                      ssize new_count) {
        return this->align_recalloc_multi_to(*this, p_handle, alignment,
                                             old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto align_xrecalloc_multi_to(auto& allocator,
                                                          auto* p_handle,
                                                          usize alignment,
                                                          ssize old_count,
                                                          ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::align_xcalloc_multi<T>,
            allocator, p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee, and zero-out the allocated memory.
    auto align_xrecalloc_multi(auto* p_handle, usize alignment, ssize old_count,
                               ssize new_count) {
        return this->align_xrecalloc_multi_to(*this, p_handle, alignment,
                                              old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto unalign_recalloc_multi_to(auto& allocator,
                                                           auto* p_handle,
                                                           ssize old_count,
                                                           ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::unalign_calloc_multi<T>,
            allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto unalign_recalloc_multi(auto* p_handle,
                                                        ssize old_count,
                                                        ssize new_count) {
        return this->unalign_recalloc_multi_to(*this, p_handle, old_count,
                                               new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto unalign_xrecalloc_multi_to(auto& allocator,
                                                            auto* p_handle,
                                                            ssize old_count,
                                                            ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::unalign_xcalloc_multi<T>,
            allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee, and zero-out the allocated memory.
    auto unalign_xrecalloc_multi(auto* p_handle, ssize old_count,
                                 ssize new_count) {
        return this->unalign_xrecalloc_multi_to(*this, p_handle, old_count,
                                                new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another.
    [[nodiscard]] constexpr auto opq_inline_realloc_to(auto& allocator,
                                                       mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_inline_alloc<T, T>,
            allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself.
    [[nodiscard]] constexpr auto opq_inline_realloc(mem auto& handle) {
        return this->opq_inline_realloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another.
    [[nodiscard]] constexpr auto opq_inline_xrealloc_to(auto& allocator,
                                                        mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_inline_xalloc<T, T>,
            allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself.
    [[nodiscard]] constexpr auto opq_inline_xrealloc(mem auto& handle) {
        return this->opq_inline_xrealloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_align_realloc_to(auto& allocator,
                                                             mem auto& handle,
                                                             usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_inline_align_alloc<T, T>,
            allocator, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_align_realloc(mem auto& handle,
                                                          usize alignment) {
        return this->opq_inline_align_realloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_align_xrealloc_to(auto& allocator,
                                                              mem auto& handle,
                                                              usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_inline_align_xalloc<T, T>,
            allocator, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee.
    auto opq_inline_align_xrealloc(mem auto& handle, usize alignment) {
        return this->opq_inline_align_xrealloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_unalign_realloc_to(
        auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_inline_unalign_alloc<T, T>,
            allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_unalign_realloc(mem auto& handle) {
        return this->opq_inline_unalign_realloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_unalign_xrealloc_to(
        auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_inline_unalign_xalloc<T, T>,
            allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee.
    auto opq_inline_unalign_xrealloc(mem auto& handle) {
        return this->opq_inline_unalign_xrealloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another.
    [[nodiscard]] constexpr auto opq_inline_realloc_multi_to(auto& allocator,
                                                             mem auto& handle,
                                                             ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_inline_alloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself.
    [[nodiscard]] constexpr auto opq_inline_realloc_multi(mem auto& handle,
                                                          ssize new_count) {
        return this->opq_realloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another.
    [[nodiscard]] constexpr auto opq_inline_xrealloc_multi_to(auto& allocator,
                                                              mem auto& handle,
                                                              ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_inline_xalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself.
    [[nodiscard]] constexpr auto opq_inline_xrealloc_multi(mem auto& handle,
                                                           ssize new_count) {
        return this->opq_inline_xrealloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another.
    [[nodiscard]] constexpr auto opq_inline_align_realloc_multi_to(
        auto& allocator, mem auto& handle, usize alignment, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_inline_align_alloc_multi<T>,
            allocator, handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_align_realloc_multi(
        mem auto& handle, usize alignment, ssize new_count) {
        return this->opq_inline_align_realloc_multi_to(*this, handle, alignment,
                                                       new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_align_xrealloc_multi_to(
        auto& allocator, mem auto& handle, usize alignment, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_inline_align_xalloc_multi<
                T>,
            allocator, handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee.
    auto opq_inline_align_xrealloc_multi(mem auto& handle, usize alignment,
                                         ssize new_count) {
        return this->opq_inline_align_xrealloc_multi_to(*this, handle,
                                                        alignment, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_unalign_realloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_inline_unalign_alloc_multi<
                T>,
            allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_unalign_realloc_multi(
        mem auto& handle, ssize new_count) {
        return this->opq_inline_unalign_realloc_multi_to(*this, handle,
                                                         new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee.
    [[nodiscard]] constexpr auto opq_inline_unalign_xrealloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_inline_unalign_xalloc_multi<
                T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee.
    auto opq_inline_unalign_xrealloc_multi(mem auto& handle, ssize new_count) {
        return this->opq_inline_unalign_xrealloc_multi_to(*this, handle,
                                                          new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_recalloc_to(auto& allocator,
                                                        mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_calloc<T, T>, allocator,
            handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_recalloc(mem auto& handle) {
        return this->opq_inline_recalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another, and
    // zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_xrecalloc_to(auto& allocator,
                                                         mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_inline_xcalloc<T, T>,
            allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself, and
    // zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_xrecalloc(mem auto& handle) {
        return this->opq_inline_xrecalloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_align_recalloc_to(auto& allocator,
                                                              mem auto& handle,
                                                              usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_inline_align_calloc<T, T>,
            allocator, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_align_recalloc(mem auto& handle,
                                                           usize alignment) {
        return this->opq_inline_align_recalloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_align_xrecalloc_to(
        auto& allocator, mem auto& handle, usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_inline_align_xcalloc<T, T>,
            allocator, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee, and zero-out the allocated memory.
    auto opq_inline_align_xrecalloc(mem auto& handle, usize alignment) {
        return this->opq_inline_align_xrecalloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_unalign_recalloc_to(
        auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, false>(
            &allocator_interface<derived_type>::opq_inline_unalign_calloc<T, T>,
            allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_unalign_recalloc(mem auto& handle) {
        return this->opq_inline_unalign_recalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_unalign_xrecalloc_to(
        auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, false>(
            &allocator_interface<derived_type>::opq_inline_unalign_xcalloc<T,
                                                                           T>,
            allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee, and zero-out the allocated memory.
    auto opq_inline_unalign_xrecalloc(mem auto& handle) {
        return this->opq_inline_unalign_xrecalloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_recalloc_multi_to(auto& allocator,
                                                              mem auto& handle,
                                                              ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_inline_calloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_recalloc_multi(mem auto& handle,
                                                           ssize new_count) {
        return this->opq_inline_recalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_xrecalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_inline_xcalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_xrecalloc_multi(mem auto& handle,
                                                            ssize new_count) {
        return this->opq_inline_xrecalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and zero-out the allocated memory.
    [[nodiscard]] constexpr auto opq_inline_align_recalloc_multi_to(
        auto& allocator, mem auto& handle, usize alignment, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_inline_align_calloc_multi<
                T>,
            allocator, handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]] constexpr auto opq_inline_align_recalloc_multi(
        mem auto& handle, usize alignment, ssize new_count) {
        return this->opq_inline_align_recalloc_multi_to(*this, handle,
                                                        alignment, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]] constexpr auto opq_inline_align_xrecalloc_multi_to(
        auto& allocator, mem auto& handle, usize alignment, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<derived_type>::opq_inline_align_xcalloc_multi<
                T>,
            allocator, handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee, and zero-out the
    // allocated memory.
    auto opq_inline_align_xrecalloc_multi(mem auto& handle, usize alignment,
                                          ssize new_count) {
        return this->opq_inline_align_xrecalloc_multi_to(*this, handle,
                                                         alignment, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]] constexpr auto opq_inline_unalign_recalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, false>(
            &allocator_interface<derived_type>::opq_inline_unalign_calloc_multi<
                T>,
            allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]] constexpr auto opq_inline_unalign_recalloc_multi(
        mem auto& handle, ssize new_count) {
        return this->opq_inline_unalign_recalloc_multi_to(*this, handle,
                                                          new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]] constexpr auto opq_inline_unalign_xrecalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, false>(
            &allocator_interface<
                derived_type>::opq_inline_unalign_xcalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee, and zero-out the
    // allocated memory.
    auto opq_inline_unalign_xrecalloc_multi(mem auto& handle, ssize new_count) {
        return this->opq_inline_unalign_xrecalloc_multi_to(*this, handle,
                                                           new_count);
    }

    // Try to move a memory handle from this allocator into another, and return
    // the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_resalloc_to(auto& allocator,
                                                 mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_salloc<T, T>, allocator,
            handle);
    }

    // Try to move a memory handle from this allocator into itself, and return
    // the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_resalloc(mem auto& handle) {
        return this->opq_resalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto resalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::salloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto resalloc(T* p_handle) {
        return this->resalloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_xresalloc_to(auto& allocator,
                                                  mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_xalloc<T, T>, allocator,
            handle);
    }

    // Move a memory handle from this allocator into itself, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_xresalloc(mem auto& handle) {
        return this->opq_xresalloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another, and return the
    // number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto xresalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::xsalloc<T, T>, allocator,
            p_handle);
    }

    // Move a pointer handle from this allocator into itself, and return the
    // number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto xresalloc(T* p_handle) {
        return this->xresalloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_align_resalloc_to(auto& allocator,
                                                       mem auto& handle,
                                                       usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_align_salloc<T, T>,
            allocator, handle, alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_align_resalloc(mem auto& handle,
                                                    usize alignment) {
        return this->opq_align_resalloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_align_xresalloc_to(auto& allocator,
                                                        mem auto& handle,
                                                        usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_align_xalloc<T, T>,
            allocator, handle, alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee, and return the number of bytes that were allocated.
    auto opq_align_xresalloc(mem auto& handle, usize alignment) {
        return this->opq_align_xresalloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_unalign_resalloc_to(auto& allocator,
                                                         mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_unalign_salloc<T, T>,
            allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_unalign_resalloc(mem auto& handle) {
        return this->opq_unalign_resalloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_unalign_xresalloc_to(auto& allocator,
                                                          mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_unalign_xalloc<T, T>,
            allocator, handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee, and return the number of bytes that were allocated.
    auto opq_unalign_xresalloc(mem auto& handle) {
        return this->opq_unalign_xresalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto align_resalloc_to(auto& allocator,
                                                   auto* p_handle,
                                                   usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::align_salloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto align_resalloc(auto* p_handle,
                                                usize alignment) {
        return this->align_resalloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto align_xresalloc_to(auto& allocator,
                                                    auto* p_handle,
                                                    usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::align_xalloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee, and return the number of bytes that were allocated.
    auto align_xresalloc(auto* p_handle, usize alignment) {
        return this->align_xresalloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto unalign_resalloc_to(auto& allocator,
                                                     auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::unalign_salloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto unalign_resalloc(auto* p_handle) {
        return this->unalign_resalloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto unalign_xresalloc_to(auto& allocator,
                                                      auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::unalign_xalloc<T, T>, allocator,
            p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee, and return the number of bytes that were allocated.
    auto unalign_xresalloc(auto* p_handle) {
        return this->unalign_xresalloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another, and return
    // the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_resalloc_multi_to(auto& allocator,
                                                       mem auto& handle,
                                                       ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_salloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move an array memory handle from this allocator into itself, and
    // return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_resalloc_multi(mem auto& handle,
                                                    ssize new_count) {
        return this->opq_resalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto resalloc_multi_to(auto& allocator, T* p_handle,
                                                   ssize old_count,
                                                   ssize new_count) {
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::salloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto resalloc_multi(T* p_handle, ssize old_count,
                                                ssize new_count) {
        return this->resalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_xresalloc_multi_to(auto& allocator,
                                                        mem auto& handle,
                                                        ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::opq_xsalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_xresalloc_multi(mem auto& handle,
                                                     ssize new_count) {
        return this->opq_xresalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another,
    // and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto xresalloc_multi_to(auto& allocator,
                                                    T* p_handle,
                                                    ssize old_count,
                                                    ssize new_count) {
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::xsalloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself,
    // and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto xresalloc_multi(T* p_handle, ssize old_count,
                                                 ssize new_count) {
        return this->xresalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_align_resalloc_multi_to(auto& allocator,
                                                             mem auto& handle,
                                                             usize alignment,
                                                             ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_align_salloc_multi<T>,
            allocator, handle, new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto opq_align_resalloc_multi(mem auto& handle,
                                                          usize alignment,
                                                          ssize new_count) {
        return this->opq_align_resalloc_multi_to(*this, handle, alignment,
                                                 new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_align_xresalloc_multi_to(auto& allocator,
                                                              mem auto& handle,
                                                              usize alignment,
                                                              ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::opq_align_xsalloc_multi<T>,
            allocator, handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    auto opq_align_xresalloc_multi(mem auto& handle, usize alignment,
                                   ssize new_count) {
        return this->opq_align_xresalloc_multi_to(*this, handle, alignment,
                                                  new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto opq_unalign_resalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_unalign_salloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto opq_unalign_resalloc_multi(mem auto& handle,
                                                            ssize new_count) {
        return this->opq_unalign_resalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_unalign_xresalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::opq_unalign_xsalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    auto opq_unalign_xresalloc_multi(mem auto& handle, ssize new_count) {
        return this->opq_unalign_xresalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto align_resalloc_multi_to(auto& allocator,
                                                         auto* p_handle,
                                                         usize alignment,
                                                         ssize old_count,
                                                         ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::align_salloc_multi<T>,
            allocator, p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto align_resalloc_multi(auto* p_handle,
                                                      usize alignment,
                                                      ssize old_count,
                                                      ssize new_count) {
        return this->align_resalloc_multi_to(*this, p_handle, alignment,
                                             old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto align_xresalloc_multi_to(auto& allocator,
                                                          auto* p_handle,
                                                          usize alignment,
                                                          ssize old_count,
                                                          ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::align_xsalloc_multi<T>,
            allocator, p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    auto align_xresalloc_multi(auto* p_handle, usize alignment, ssize old_count,
                               ssize new_count) {
        return this->align_xresalloc_multi_to(*this, p_handle, alignment,
                                              old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto unalign_resalloc_multi_to(auto& allocator,
                                                           auto* p_handle,
                                                           ssize old_count,
                                                           ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::unalign_salloc_multi<T>,
            allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto unalign_resalloc_multi(auto* p_handle,
                                                        ssize old_count,
                                                        ssize new_count) {
        return this->unalign_resalloc_multi_to(*this, p_handle, old_count,
                                               new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto unalign_xresalloc_multi_to(auto& allocator,
                                                            auto* p_handle,
                                                            ssize old_count,
                                                            ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::unalign_xsalloc_multi<T>,
            allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    auto unalign_xresalloc_multi(auto* p_handle, ssize old_count,
                                 ssize new_count) {
        return this->unalign_xresalloc_multi_to(*this, p_handle, old_count,
                                                new_count);
    }

    // Try to move a memory handle from this allocator into another, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_rescalloc_to(auto& allocator,
                                                  mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_scalloc<T, T>, allocator,
            handle);
    }

    // Try to move a memory handle from this allocator into itself, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_rescalloc(mem auto& handle) {
        return this->opq_rescalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto rescalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::scalloc<T, T>, allocator,
            p_handle);
    }

    // Try to move a pointer handle from this allocator into itself, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto rescalloc(T* p_handle) {
        return this->rescalloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_xrescalloc_to(auto& allocator,
                                                   mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_xscalloc<T, T>, allocator,
            handle);
    }

    // Move a memory handle from this allocator into itself, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_xrescalloc(mem auto& handle) {
        return this->opq_xrescalloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto xrescalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::xscalloc<T, T>, allocator,
            p_handle);
    }

    // Move a pointer handle from this allocator into itself, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto xrescalloc(T* p_handle) {
        return this->xrescalloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_align_rescalloc_to(auto& allocator,
                                                        mem auto& handle,
                                                        usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_align_scalloc<T, T>,
            allocator, handle, alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_align_rescalloc(mem auto& handle,
                                                     usize alignment) {
        return this->opq_align_rescalloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] constexpr auto opq_align_xrescalloc_to(auto& allocator,
                                                         mem auto& handle,
                                                         usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_align_xscalloc<T, T>,
            allocator, handle, alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto opq_align_xrescalloc(mem auto& handle, usize alignment) {
        return this->opq_align_xrescalloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_unalign_rescalloc_to(auto& allocator,
                                                          mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_unalign_scalloc<T, T>,
            allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_unalign_rescalloc(mem auto& handle) {
        return this->opq_unalign_rescalloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] constexpr auto opq_unalign_xrescalloc_to(auto& allocator,
                                                           mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_unalign_xscalloc<T, T>,
            allocator, handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto opq_unalign_xrescalloc(mem auto& handle) {
        return this->opq_unalign_xrescalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto align_rescalloc_to(auto& allocator,
                                                    auto* p_handle,
                                                    usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::align_scalloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto align_rescalloc(auto* p_handle,
                                                 usize alignment) {
        return this->align_rescalloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] constexpr auto align_xrescalloc_to(auto& allocator,
                                                     auto* p_handle,
                                                     usize alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::align_xscalloc<T, T>, allocator,
            p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto align_xrescalloc(auto* p_handle, usize alignment) {
        return this->align_xrescalloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto unalign_rescalloc_to(auto& allocator,
                                                      auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::unalign_scalloc<T, T>,
            allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto unalign_rescalloc(auto* p_handle) {
        return this->unalign_rescalloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] constexpr auto unalign_xrescalloc_to(auto& allocator,
                                                       auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::unalign_xscalloc<T, T>,
            allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto unalign_xrescalloc(auto* p_handle) {
        return this->unalign_xrescalloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_rescalloc_multi_to(auto& allocator,
                                                        mem auto& handle,
                                                        ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_scalloc_multi<T>, allocator,
            handle, new_count);
    }

    // Try to move an array memory handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_rescalloc_multi(mem auto& handle,
                                                     ssize new_count) {
        return this->opq_rescalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto rescalloc_multi_to(auto& allocator,
                                                    T* p_handle,
                                                    ssize old_count,
                                                    ssize new_count) {
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::scalloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself, zero-out the allocated memory, and return the number of bytes
    // that were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto rescalloc_multi(T* p_handle, ssize old_count,
                                                 ssize new_count) {
        return this->rescalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto opq_xrescalloc_multi_to(auto& allocator,
                                                         mem auto& handle,
                                                         ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::opq_xscalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto opq_xrescalloc_multi(mem auto& handle,
                                                      ssize new_count) {
        return this->opq_xrescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto xrescalloc_multi_to(auto& allocator,
                                                     T* p_handle,
                                                     ssize old_count,
                                                     ssize new_count) {
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::xscalloc_multi<T>, allocator,
            p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    template <typename T>
    [[nodiscard]] constexpr auto xrescalloc_multi(T* p_handle, ssize old_count,
                                                  ssize new_count) {
        return this->xrescalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto opq_align_rescalloc_multi_to(auto& allocator,
                                                              mem auto& handle,
                                                              usize alignment,
                                                              ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_align_scalloc_multi<T>,
            allocator, handle, new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_align_rescalloc_multi(mem auto& handle,
                                                           usize alignment,
                                                           ssize new_count) {
        return this->opq_align_rescalloc_multi_to(*this, handle, alignment,
                                                  new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_align_xrescalloc_multi_to(
        auto& allocator, mem auto& handle, usize alignment, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::opq_align_xscalloc_multi<T>,
            allocator, handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto opq_align_xrescalloc_multi(mem auto& handle, usize alignment,
                                    ssize new_count) {
        return this->opq_align_xrescalloc_multi_to(*this, handle, alignment,
                                                   new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_unalign_rescalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_unalign_scalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_unalign_rescalloc_multi(mem auto& handle,
                                                             ssize new_count) {
        return this->opq_unalign_rescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_unalign_xrescalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::opq_unalign_xscalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto opq_unalign_xrescalloc_multi(mem auto& handle, ssize new_count) {
        return this->opq_unalign_xrescalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto align_rescalloc_multi_to(auto& allocator,
                                                          auto* p_handle,
                                                          usize alignment,
                                                          ssize old_count,
                                                          ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::align_scalloc_multi<T>,
            allocator, p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto align_rescalloc_multi(auto* p_handle,
                                                       usize alignment,
                                                       ssize old_count,
                                                       ssize new_count) {
        return this->align_rescalloc_multi_to(*this, p_handle, alignment,
                                              old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto align_xrescalloc_multi_to(auto& allocator,
                                                           auto* p_handle,
                                                           usize alignment,
                                                           ssize old_count,
                                                           ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::align_xscalloc_multi<T>,
            allocator, p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto align_xrescalloc_multi(auto* p_handle, usize alignment,
                                ssize old_count, ssize new_count) {
        return this->align_xrescalloc_multi_to(*this, p_handle, alignment,
                                               old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto unalign_rescalloc_multi_to(auto& allocator,
                                                            auto* p_handle,
                                                            ssize old_count,
                                                            ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::unalign_scalloc_multi<T>,
            allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto unalign_rescalloc_multi(auto* p_handle,
                                                         ssize old_count,
                                                         ssize new_count) {
        return this->unalign_rescalloc_multi_to(*this, p_handle, old_count,
                                                new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto unalign_xrescalloc_multi_to(auto& allocator,
                                                             auto* p_handle,
                                                             ssize old_count,
                                                             ssize new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::unalign_xscalloc_multi<T>,
            allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto unalign_xrescalloc_multi(auto* p_handle, ssize old_count,
                                  ssize new_count) {
        return this->unalign_xrescalloc_multi_to(*this, p_handle, old_count,
                                                 new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_resalloc_to(auto& allocator,
                                                        mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_inline_salloc<T, T>,
            allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_resalloc(mem auto& handle) {
        return this->opq_inline_resalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another, and
    // return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_xresalloc_to(auto& allocator,
                                                         mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_inline_xalloc<T, T>,
            allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself, and
    // return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_xresalloc(mem auto& handle) {
        return this->opq_inline_xresalloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto opq_inline_align_resalloc_to(auto& allocator,
                                                              mem auto& handle,
                                                              usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_inline_align_salloc<T, T>,
            allocator, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_inline_align_resalloc(mem auto& handle,
                                                           usize alignment) {
        return this->opq_inline_align_resalloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_inline_align_xresalloc_to(
        auto& allocator, mem auto& handle, usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_inline_align_xalloc<T, T>,
            allocator, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee, and return the number of bytes that were
    // allocated.
    auto opq_inline_align_xresalloc(mem auto& handle, usize alignment) {
        return this->opq_inline_align_xresalloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_resalloc_to(
        auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_inline_unalign_salloc<T, T>,
            allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_resalloc(mem auto& handle) {
        return this->opq_inline_unalign_resalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_xresalloc_to(
        auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_inline_unalign_xalloc<T, T>,
            allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee, and return the number of bytes that were
    // allocated.
    auto opq_inline_unalign_xresalloc(mem auto& handle) {
        return this->opq_inline_unalign_xresalloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_resalloc_multi_to(auto& allocator,
                                                              mem auto& handle,
                                                              ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_inline_salloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_inline_resalloc_multi(mem auto& handle,
                                                           ssize new_count) {
        return this->opq_resalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_inline_xresalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::opq_inline_xsalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_inline_xresalloc_multi(mem auto& handle,
                                                            ssize new_count) {
        return this->opq_inline_xresalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_inline_align_resalloc_multi_to(
        auto& allocator, mem auto& handle, usize alignment, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_inline_align_salloc_multi<
                T>,
            allocator, handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_align_resalloc_multi(
        mem auto& handle, usize alignment, ssize new_count) {
        return this->opq_inline_align_resalloc_multi_to(*this, handle,
                                                        alignment, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee, and return the number
    // of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_align_xresalloc_multi_to(
        auto& allocator, mem auto& handle, usize alignment, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::opq_inline_align_xsalloc_multi<
                T>,
            allocator, handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee, and return the number
    // of bytes that were allocated.
    auto opq_inline_align_xresalloc_multi(mem auto& handle, usize alignment,
                                          ssize new_count) {
        return this->opq_inline_align_xresalloc_multi_to(*this, handle,
                                                         alignment, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_resalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_inline_unalign_salloc_multi<
                T>,
            allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_resalloc_multi(
        mem auto& handle, ssize new_count) {
        return this->opq_inline_unalign_resalloc_multi_to(*this, handle,
                                                          new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee, and return the number
    // of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_xresalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<
                derived_type>::opq_inline_unalign_xsalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee, and return the number
    // of bytes that were allocated.
    auto opq_inline_unalign_xresalloc_multi(mem auto& handle, ssize new_count) {
        return this->opq_inline_unalign_xresalloc_multi_to(*this, handle,
                                                           new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_rescalloc_to(auto& allocator,
                                                         mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_scalloc<T, T>, allocator,
            handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself, zero-out the allocated memory, and return the number of bytes
    // that were allocated.
    [[nodiscard]] constexpr auto opq_inline_rescalloc(mem auto& handle) {
        return this->opq_inline_rescalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_inline_xrescalloc_to(auto& allocator,
                                                          mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_inline_xscalloc<T, T>,
            allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that were
    // allocated.
    [[nodiscard]] constexpr auto opq_inline_xrescalloc(mem auto& handle) {
        return this->opq_inline_xrescalloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_align_rescalloc_to(
        auto& allocator, mem auto& handle, usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_inline_align_scalloc<T, T>,
            allocator, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_align_rescalloc(mem auto& handle,
                                                            usize alignment) {
        return this->opq_inline_align_rescalloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_align_xrescalloc_to(
        auto& allocator, mem auto& handle, usize alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_inline_align_xscalloc<T, T>,
            allocator, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    auto opq_inline_align_xrescalloc(mem auto& handle, usize alignment) {
        return this->opq_inline_align_xrescalloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_rescalloc_to(
        auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<true, true>(
            &allocator_interface<derived_type>::opq_inline_unalign_scalloc<T,
                                                                           T>,
            allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_rescalloc(
        mem auto& handle) {
        return this->opq_inline_unalign_rescalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_xrescalloc_to(
        auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<false, true>(
            &allocator_interface<derived_type>::opq_inline_unalign_xscalloc<T,
                                                                            T>,
            allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    auto opq_inline_unalign_xrescalloc(mem auto& handle) {
        return this->opq_inline_unalign_xrescalloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_rescalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_inline_scalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_rescalloc_multi(mem auto& handle,
                                                            ssize new_count) {
        return this->opq_inline_rescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_xrescalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::opq_inline_xscalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_xrescalloc_multi(mem auto& handle,
                                                             ssize new_count) {
        return this->opq_inline_xrescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_align_rescalloc_multi_to(
        auto& allocator, mem auto& handle, usize alignment, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<derived_type>::opq_inline_align_scalloc_multi<
                T>,
            allocator, handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_align_rescalloc_multi(
        mem auto& handle, usize alignment, ssize new_count) {
        return this->opq_inline_align_rescalloc_multi_to(*this, handle,
                                                         alignment, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_align_xrescalloc_multi_to(
        auto& allocator, mem auto& handle, usize alignment, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<derived_type>::opq_inline_align_xscalloc_multi<
                T>,
            allocator, handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    auto opq_inline_align_xrescalloc_multi(mem auto& handle, usize alignment,
                                           ssize new_count) {
        return this->opq_inline_align_xrescalloc_multi_to(*this, handle,
                                                          alignment, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_rescalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<true, true>(
            &allocator_interface<
                derived_type>::opq_inline_unalign_scalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_rescalloc_multi(
        mem auto& handle, ssize new_count) {
        return this->opq_inline_unalign_rescalloc_multi_to(*this, handle,
                                                           new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]] constexpr auto opq_inline_unalign_xrescalloc_multi_to(
        auto& allocator, mem auto& handle, ssize new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<false, true>(
            &allocator_interface<
                derived_type>::opq_inline_unalign_xscalloc_multi<T>,
            allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    auto opq_inline_unalign_xrescalloc_multi(mem auto& handle,
                                             ssize new_count) {
        return this->opq_inline_unalign_xrescalloc_multi_to(*this, handle,
                                                            new_count);
    }

    // Invalidate any memory handle, invoking its data's destructor.
    template <mem T>
    void free(T const& handle) {
        using allocation_type = typename T::allocation_type const;

        // If this is not a small-size optimized handle:
        if (!handle.is_inline()) {
            allocation_type const* p_memory;
            if constexpr (T::is_multi_handle) {
                // Get the pointer from a span produced by the
                // allocator.
                p_memory = this->get(handle).data();
            } else {
                // Get the pointer from the allocator.
                p_memory = addressof(this->get(handle));
            }

            // if constexpr (is_destructible<allocation_type>) {
            for (ssize i = 0; i < handle.size(); ++i) {
                p_memory[i.raw].~allocation_type();
            }
            // }
            this->self().deallocate(static_cast<void const*>(p_memory),
                                    handle.raw_size());
        }
        // If this is not small-size optimized, it will be freed at the
        // end of the stack frame, so this function call is no-op.
    };

    // TODO: This needs unit tests.
    // Invalidate a pointer handle to a `T`, and call its destructor.
    template <typename T>
    requires(detail::is_stable_derived_allocator<
             derived_type>) constexpr void free(T* p_memory) {
        if constexpr (detail::has_max_allocation_bytes<derived_type>) {
            static_assert(ssizeof(T) <= derived_type::max_allocation_bytes,
                          "This allocation is too large for this allocator!");
        }

        if (__builtin_is_constant_evaluated()) {
            delete p_memory;
        } else {
            // if constexpr (is_destructible<T>) {
            p_memory->~T();
            // }
            this->self().deallocate(static_cast<void const*>(p_memory),
                                    ssizeof(T));
        }
    }

    // Invalidate a pointer handle to an array of `T`, and call its
    // destructors.
    template <typename T>
    requires(detail::is_stable_derived_allocator<
             derived_type>) constexpr void free_multi(T* p_memory,
                                                      ssize count) {
        if constexpr (detail::has_max_allocation_bytes<derived_type>) {
            static_assert(ssizeof(T) <= derived_type::max_allocation_bytes,
                          "This allocation is too large for this allocator!");
            cat::assert(
                ssizeof(T) * count <= derived_type::max_allocation_bytes,
                "This allocation is too large for this allocator!");
        }

        if (__builtin_is_constant_evaluated()) {
            if (p_memory) {
                // if (count > 0) {
                delete[] p_memory;
                // }
            }
        } else {
            // if constexpr (is_destructible<T>) {
            for (ssize i = 0; i < count; ++i) {
                p_memory[i.raw].~T();
            }
            // }
            this->self().deallocate(static_cast<void const*>(p_memory),
                                    ssizeof(T) * count);
        }
    }

    template <mem T>
    constexpr void cfree(T& handle) {
        free(handle);
        zero_memory_explicit(addressof(this->get(handle)), handle.raw_size());
    }

    template <typename T>
    constexpr void cfree(T* p_handle) {
        free(p_handle);
        zero_memory_explicit(p_handle, ssizeof(T));
    }

    template <typename T>
    constexpr void cfree_multi(T* p_handle, ssize count) {
        free(p_handle, count);
        zero_memory_explicit(p_handle, count * ssizeof(T));
    }

    // Get a non-`const` handle to the data in any memory handle. If that
    // memory handle is to a multi-allocation, this returns a `span`.
    template <mem T>
    [[nodiscard]] constexpr auto get(T& handle) & -> decltype(auto) {
        using allocation_type = typename T::allocation_type;
        if constexpr (T::is_inline_handle) {
            // Get small-size optimized data:
            if (handle.is_inline()) {
                if constexpr (T::is_multi_handle) {
                    return span<allocation_type>{addressof(handle.get_inline()),
                                                 handle.size()};
                } else {
                    return handle.get_inline();
                }
            }
        }

        // Get non-small-size optimized data:
        if constexpr (T::is_multi_handle) {
            return span<allocation_type>(
                this->self().template access<allocation_type>(handle.get()),
                handle.size());
        } else {
            return *(
                this->self().template access<allocation_type>(handle.get()));
        }
    }

    // Get a `const` handle to the data in any memory handle. If that memory
    // handle is to a multi-allocation, this returns a `span`.
    template <mem T>
    [[nodiscard]] constexpr auto get(T const& memory) & -> decltype(auto) {
        return unconst(this)->get(unconst(memory));
    }

    // Get a non-`const` reference to the data in any pointer handle.
    template <typename T>
    [[nodiscard]] constexpr auto get(T* p_handle) & -> T& {
        return *p_handle;
    }

    // Get a `const` reference to the data in any pointer handle.
    template <typename T>
    [[nodiscard]] constexpr auto get(T const* p_handle) & -> T& {
        return *p_handle;
    }

    // Get a pointer to an allocated non-`const` `mem`.
    template <mem T>
    requires(derived_type::has_pointer_stability)
        [[nodiscard]] constexpr auto p_get(T& memory) -> auto {
        decltype(auto) ref = this->get(memory);
        using handle_type = decltype(this->get(memory));
        if constexpr (is_reference<handle_type>) {
            return addressof(ref);
        } else {
            return ref.data();
        }
    }

    // Get a `const` pointer to an allocated `mem`.
    template <mem T>
    requires(derived_type::has_pointer_stability)
        [[nodiscard]] constexpr auto p_get(T const& memory) -> auto {
        decltype(auto) ref = this->get(memory);
        using handle_type = decltype(this->get(memory));
        if constexpr (is_reference<handle_type>) {
            return addressof(ref);
        } else {
            return ref.data();
        }
    }

    // If the allocator does not over-ride a `.reset()` method, produce a
    // no-op.
    constexpr void reset() {
    }

  private:
    constexpr auto self() -> derived_type& {
        return static_cast<derived_type&>(*this);
    }

    template <typename T, bool is_inline, bool is_fail_safe, bool is_aligned,
              bool is_multiple, bool is_stable, bool is_zeroed,
              bool has_feedback, typename... Args>
    requires(
        // Inline allocations cannot produce pointers.
        !(is_inline && is_stable)
        // Multi-allocations must be default-constructed.
        && (!is_multiple || (sizeof...(Args) <= 0))
        // TODO: Zeroed-out allocations should not have arguments.
        // Zeroed-out allocations must be trivial.
        && (!is_zeroed || is_trivial<T>)) [[gnu::optimize(
        "-fno-tree-loop-distribute-"
        "patterns")]] constexpr auto meta_alloc(usize allocation_alignment,
                                                ssize allocation_count,
                                                Args&&... constructor_args) {
        if constexpr (detail::has_max_allocation_bytes<derived_type>) {
            static_assert(ssizeof(T) <= derived_type::max_allocation_bytes,
                          "This allocation is too large for this allocator!");
            cat::assert(ssizeof(T) * allocation_count <=
                            derived_type::max_allocation_bytes,
                        "This allocation is too larger for this allocator!");
        }

        ssize const allocation_bytes = allocation_count * ssizeof(T);

        // Produce a basic handle for this memory type.

        using underlying_handle =
            decltype(this->self().template make_handle<T>(declval<T*>()));

        // Get the return value of a user-supplied `.allocate()`. This must
        // be some kind of `maybe`. It holds some data that can pass into a
        // `handle_type`'s constructor.
        using maybe_allocation =
            conditional<has_feedback, maybe_sized_allocation<void*>,
                        maybe_ptr<void>>;

        // Produce an appropriate handle type for this allocation.
        using handle_type = conditional<
            is_multiple,
            detail::multi_memory_handle<conditional<
                is_inline,
                // If this an array of small-size optimized `T`:
                detail::inline_memory_handle<underlying_handle>,
                // If this is an array of not small-size optimized `T`:
                underlying_handle>>,
            conditional<is_inline,
                        // If this a small-size optimized `T`:
                        detail::inline_memory_handle<underlying_handle>,
                        // If this is not a small-size optimized `T`:
                        underlying_handle>>;

        using return_handle = conditional<
            is_fail_safe,
            conditional<is_stable,
                        conditional<has_feedback,
                                    conditional<is_multiple,
                                                // tuple of a span with size
                                                // feedback.
                                                maybe<tuple<span<T>, ssize>>,
                                                // Failsafe pointer with size.
                                                maybe_sized_allocation<T*>>,
                                    conditional<is_multiple,
                                                // TODO: Use a `maybe_span<T>`.
                                                // span.
                                                maybe<span<T>>,
                                                // Failsafe pointer w/out size.
                                                maybe_ptr<T>>>,
                        // Not a pointer:
                        conditional<has_feedback,
                                    // Failsafe opaque handle with size.
                                    maybe_sized_allocation<handle_type>,
                                    // Failsafe opaque handle w/out size.
                                    maybe<handle_type>>>,
            // Not fail-safe:
            conditional<is_stable,
                        conditional<has_feedback,
                                    conditional<is_multiple,
                                                // Unsafe tuple of a span
                                                // with size.
                                                tuple<span<T>, ssize>,
                                                // Unsafe pointer with size.
                                                sized_allocation<T*>>,
                                    conditional<is_multiple,
                                                // Unsafe span.
                                                span<T>,
                                                // Unsafe pointer w/out
                                                // size.
                                                T*>>,
                        conditional<has_feedback,
                                    // Unsafe opaque handle with size.
                                    sized_allocation<handle_type>,
                                    // Unsafe opaque memory handle w/out
                                    // size.
                                    handle_type>>>;

        // In `constexpr` code, unconditionally make an allocation.
        if (__builtin_is_constant_evaluated()) {
            if constexpr (is_stable) {
                T* p_allocation = nullptr;

                // Construct one or multiple `T`s.
                if constexpr (is_multiple) {
                    p_allocation =
                        new (std::align_val_t{allocation_alignment.raw})
                            T[allocation_count.raw];
                } else {
                    p_allocation =
                        new (std::align_val_t{allocation_alignment.raw})
                            T(constructor_args...);
                }

                // Data must be default-constructed in `constexpr` code.
                for (ssize i = 0; i < allocation_count; ++i) {
                    construct_at(p_allocation + i);
                }

                if constexpr (has_feedback) {
                    if constexpr (is_multiple) {
                        return return_handle{
                            tuple{span<T>{p_allocation, allocation_count},
                                  allocation_count * ssizeof(T)}};
                    } else {
                        return return_handle{sized_allocation<T*>{
                            p_allocation, allocation_count * ssizeof(T)}};
                    }
                } else {
                    // No size feedback.
                    if constexpr (is_multiple) {
                        return return_handle{
                            span<T>{p_allocation, allocation_count}};
                    } else {
                        return return_handle(p_allocation);
                    }
                }
            } else {
                // TODO: Opaque constexpr allocations.
                __builtin_unreachable();
            }
        } else {  // NOLINT
            // Non-constexpr code.
            if constexpr (is_inline) {
                if (allocation_bytes < inline_buffer_size) {
                    // Allocate memory on this stack frame.
                    handle_type stack_handle;
                    stack_handle.set_inlined(true);
                    stack_handle.set_count(allocation_count);

                    if constexpr (is_zeroed) {
                        zero_memory(addressof(stack_handle),
                                    inline_buffer_size);
                    }

                    if constexpr (is_multiple) {
                        for (ssize i = 0; i < allocation_count; ++i) {
                            construct_at(static_cast<T*>(static_cast<void*>(
                                             &stack_handle)) +
                                         i);
                        }
                    } else {
                        stack_handle.set_inline_storage(
                            T(forward<Args>(constructor_args)...));
                    }

                    // Return here to skip error handling, because an
                    // on-stack allocation cannot fail.
                    if constexpr (has_feedback) {
                        return return_handle{sized_allocation<handle_type>{
                            move(stack_handle), inline_buffer_size}};
                    } else {
                        return return_handle(move(stack_handle));
                    }
                }
            }

            // If this allocation is not small-size optimized, or is larger
            // than `inline_buffer_size`:

            // Make an allocation.
            maybe_allocation maybe_memory;

            if constexpr (is_aligned) {
                if constexpr (has_feedback) {
                    if constexpr (detail::has_aligned_allocate_feedback<
                                      derived_type>) {
                        // Call `.aligned_allocate_feedback()` function for
                        // optimized size-feedback.
                        maybe_memory = this->self().aligned_allocate_feedback(
                            allocation_alignment, allocation_bytes);
                    } else {
                        if constexpr (detail::has_allocation_size<
                                          derived_type>) {
                            // If a `.aligned_allocate_feedback()` is not
                            // provided, use `.allocation_bytes()`.
                            maybe actual_allocation_bytes =
                                this->self().allocation_bytes(
                                    allocation_alignment, allocation_bytes);

                            if (actual_allocation_bytes.has_value()) {
                                void* p_allocation =
                                    this->self()
                                        .aligned_allocate(
                                            allocation_alignment,
                                            actual_allocation_bytes.value())
                                        // If `.allocation_bytes()` succeeded,
                                        // this will not fail.
                                        .value();

                                maybe_memory = maybe_sized_allocation<void*>(
                                    tuple<void*, ssize>{
                                        p_allocation,
                                        actual_allocation_bytes.value()});
                            } else {
                                maybe_memory = nullopt;
                            }
                        } else {
                            // If a `.allocation_bytes()` is not provided,
                            // simply assume that it allocates
                            // `allocation_bytes`.
                            maybe temp_memory = this->self().aligned_allocate(
                                allocation_alignment, allocation_bytes);
                            if (temp_memory.has_value()) {
                                maybe_memory = maybe_sized_allocation<void*>{
                                    temp_memory.value(), allocation_bytes};
                            } else {
                                maybe_memory = nullopt;
                            }
                        };
                    }
                } else {
                    if constexpr (detail::has_aligned_allocate<derived_type>) {
                        maybe_memory = this->self().aligned_allocate(
                            allocation_alignment, allocation_bytes);
                    } else {
                        // If a `.aligned_allocate()` is not provided, ensure
                        // alignment with a runtime check.
                        maybe_memory = this->self().allocate(allocation_bytes);
                        if (maybe_memory.has_value()) {
                            cat::assert(cat::is_aligned(maybe_memory.value(),
                                                        allocation_alignment),
                                        "allocation_type is misaligned!");
                        }
                    }
                }
            } else {
                if constexpr (has_feedback) {
                    if constexpr (detail::has_allocate_feedback<derived_type>) {
                        // Call `.allocate_feedback()` function for
                        // optimized size-feedback.
                        maybe_memory =
                            this->self().allocate_feedback(allocation_bytes);
                    } else {
                        if constexpr (detail::has_aligned_allocate_feedback<
                                          derived_type>) {
                            // If `.allocate_feedback()` is not provided,
                            // but `.aligned_allocate_feedback()` is, fall back
                            // to that with alignment of `1u`.
                            maybe_memory =
                                this->self().aligned_allocate_feedback(
                                    1u, allocation_bytes);
                        } else if constexpr (detail::has_allocation_size<
                                                 derived_type>) {
                            // If a `.aligned_allocate_feedback()` is not
                            // provided, use `.allocation_size`().
                            maybe size = this->self().allocation_bytes(
                                1u, allocation_bytes);

                            if (size.has_value()) {
                                maybe_memory = maybe_sized_allocation<void*>{
                                    // If `.allocation_bytes()` succeeded, this
                                    // will not fail.
                                    this->self()
                                        .allocate(allocation_bytes)
                                        .value(),
                                    size.value()};
                            } else {
                                maybe_memory = nullopt;
                            }
                        } else {
                            // If a `.allocation_bytes()` is also not
                            // provided, simply assume that it allocates
                            // `allocation_size`.
                            auto temp_memory = this->self().aligned_allocate(
                                allocation_alignment, allocation_bytes);
                            if (temp_memory.has_value()) {
                                maybe_memory = maybe_sized_allocation<void*>{
                                    temp_memory.value(), allocation_bytes};
                            } else {
                                maybe_memory = nullopt;
                            }
                        };
                    }
                } else {
                    // Otherwise, make an allocation without size feedback.
                    if constexpr (detail::has_allocate<derived_type>) {
                        maybe_memory = this->self().allocate(allocation_bytes);
                    } else {
                        // If `.allocate` is not provided, implement it in
                        // terms of
                        // `.aligned_allocate()`.
                        maybe_memory =
                            this->self().allocate_aligned(1u, allocation_bytes);
                    }
                }
            }

            if constexpr (is_fail_safe) {
                if (!maybe_memory.has_value()) {
                    // Return an empty maybe if this failed to allocate.
                    return return_handle(nullopt);
                }
            }

            T* p_allocation;
            if constexpr (has_feedback) {
                // The `.first()` element of the `sized_allocation` tuple is
                // a `void*`.
                p_allocation = static_cast<T*>(maybe_memory.value().first());
            } else {
                p_allocation = static_cast<T*>(maybe_memory.value());
            }

            if constexpr (is_zeroed) {
                zero_memory(p_allocation, allocation_bytes);
            }

            // Construct the `T`s inside the allocator.
            for (ssize i = 0; i < allocation_count; ++i) {
                construct_at(p_allocation + i,
                             forward<Args>(constructor_args)...);
            }

            // If this allocation has size feedback, store it.
            ssize size_feedback;
            if constexpr (has_feedback) {
                size_feedback = maybe_memory.value().second();
            }

            if constexpr (is_stable) {
                if constexpr (has_feedback) {
                    if constexpr (is_multiple) {
                        return return_handle{
                            tuple{span<T>{p_allocation, allocation_count},
                                  size_feedback}};
                    } else {
                        return return_handle{
                            sized_allocation<T*>{p_allocation, size_feedback}};
                    }
                } else {
                    // No size feedback.
                    if constexpr (is_multiple) {
                        return return_handle{
                            span<T>{p_allocation, allocation_count}};
                    } else {
                        return return_handle(p_allocation);
                    }
                }
            } else {
                underlying_handle const raw_handle =
                    this->self().template make_handle<T>(p_allocation);
                handle_type handle{move(raw_handle)};

                if constexpr (is_inline) {
                    handle.set_inlined(false);
                }

                if constexpr (is_multiple) {
                    handle.set_count(allocation_count);
                }

                if constexpr (has_feedback) {
                    return return_handle(sized_allocation<handle_type>{
                        move(handle), size_feedback});
                } else {
                    return return_handle(move(handle));
                }
            }
        }
    }

    // Take a generic allocation method, invoke it on an allocator with a
    // generic memory handle, and free the original handle if that
    // allocation suceeded.
    template <bool is_fail_safe, bool has_feedback, typename... Args>
    constexpr auto meta_realloc(auto function, auto& allocator, auto& handle,
                                Args&&... arguments) {
        using allocation_type = decltype((&allocator->*function)(
            forward<Args>(arguments)..., move(this->get(handle))));
        allocation_type allocation;
        allocation = (&allocator->*function)(
            // Possible alignment and/or count arguments.
            forward<Args>(arguments)...,
            // Move the data from this handle.
            move(this->get(handle)));

        if constexpr (is_fail_safe) {
            if (!allocation.has_value()) {
                return allocation;
            }
        }

        this->free(handle);
        return allocation;
    }

    // Copy data from `handle` into `allocation`.
    constexpr void relocate_handle(mem auto& handle, auto allocation) {
        if constexpr (is_trivially_relocatable<int>) {
            copy_memory(addressof(this->get(handle)), addressof(allocation),
                        handle.raw_size());
        } else {
            for (ssize i = 0; i < handle.size(); ++i) {
                *(addressof(this->get(allocation)) + i) =
                    move(*(addressof(this->get(handle)) + i));
            }
        }
    }

    // Copy data from `p_handle` into `p_allocation`.
    constexpr void relocate_pointer_handle(auto* p_handle, auto* p_allocation,
                                           ssize count) {
        // TODO: Use a `relocate()` function to streamline this.
        if constexpr (is_trivially_relocatable<decltype(*p_allocation)>) {
            copy_memory(p_handle, p_allocation, count);
        } else {
            for (ssize i = 0; i < count; ++i) {
                *(p_allocation + i) = move(*(p_handle + i));
            }
        }
    }

    // Copy data from `p_handle` into `allocation`.
    template <typename T>
    constexpr void relocate_pointer_handle(auto* p_handle, span<T> allocation,
                                           ssize count) {
        // TODO: Use a `relocate()` function to streamline this.
        if constexpr (is_trivially_relocatable<decltype(*(
                          allocation.data()))>) {
            copy_memory(p_handle, allocation.data(), count);
        } else {
            for (ssize i = 0; i < count; ++i) {
                allocation[i] = move(*(p_handle + i));
            }
        }
    }

    template <bool is_fail_safe, bool has_feedback, typename... Args>
    constexpr auto meta_realloc_multi(auto function, auto& allocator,
                                      mem auto& handle, ssize new_count,
                                      Args&&... maybe_alignment) {
        using allocation_type = decltype((&allocator->*function)(
            forward<Args>(maybe_alignment)..., new_count));
        allocation_type allocation;
        allocation = (&allocator->*function)(forward<Args>(maybe_alignment)...,
                                             new_count);

        if constexpr (is_fail_safe) {
            if constexpr (has_feedback) {
                if (!allocation.has_value()) {
                    return allocation;
                }
                this->relocate_handle(handle, allocation.value().first());
            } else {
                if (!allocation.has_value()) {
                    return allocation;
                }
                this->relocate_handle(handle, allocation.value());
            }
        } else {
            if constexpr (has_feedback) {
                this->relocate_handle(handle, allocation.first());
            } else {
                this->relocate_handle(handle, allocation);
            }
        }

        // This can be an opaque handle.
        this->free(handle);
        return allocation;
    }

    template <bool is_fail_safe, bool has_feedback, typename... Args>
    constexpr auto meta_realloc_multi(auto function, auto& allocator,
                                      auto* p_handle, ssize old_count,
                                      ssize new_count,
                                      Args&&... maybe_alignment) {
        using allocation_type = decltype((&allocator->*function)(
            forward<Args>(maybe_alignment)..., new_count));

        allocation_type allocation = (&allocator->*function)(
            forward<Args>(maybe_alignment)..., new_count);

        if constexpr (is_fail_safe) {
            if constexpr (has_feedback) {
                if (!allocation.has_value()) {
                    return allocation;
                }
                this->relocate_pointer_handle(
                    p_handle, allocation.value().first(), old_count);
            } else {
                if (!allocation.has_value()) {
                    return allocation;
                }
                this->relocate_pointer_handle(p_handle, allocation.value(),
                                              old_count);
            }
        } else {
            if constexpr (has_feedback) {
                this->relocate_pointer_handle(p_handle, allocation.first(),
                                              old_count);
            } else {
                this->relocate_pointer_handle(p_handle, allocation, old_count);
            }
        }

        this->free_multi(p_handle, old_count);
        return allocation;
    }
};

}  // namespace cat
