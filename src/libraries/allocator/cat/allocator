// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/string>
#include <cat/tuple>

namespace cat {

template <typename T>
concept mem = requires(T handle) {
                  handle.is_inline_handle;
                  handle.is_multi_handle;
                  handle.size();
                  handle.raw_size();
                  handle.is_inline();
              };

inline constexpr idx inline_buffer_size = 256u;

// TODO: Handles' `.get()` should be only visible to allocators.
namespace detail {
    // `base_memory_handle` is an opaque memory handle. allocators are to define
    // and produce a memory handle type which derives from this. These handles
    // contain absolutely arbitrary storage (such as a `T*`, or an `ssize`
    // address offset). Handles must provide a `.get()` method to return
    // whatever that storage is.
    template <typename T>
    struct base_memory_handle {
        static constexpr bool is_inline_handle = false;
        static constexpr bool is_multi_handle = false;
        using allocation_type = T;

        // Number of `T`s allocated. This is always 1 if the call is not
        // intercepted by a `multi_memory_handle`.
        [[nodiscard]]
        constexpr auto size() const -> idx {
            return 1u;
        }

        // If `.set_count()` is no-op if it is not intercepted by a
        // `multi_memory_handle`.
        void set_count(iword) {
        }

        // Number of bytes allocated. This is always the size of `T` if the call
        // is not intercepted by a `multi_memory_handle`.
        [[nodiscard]]
        constexpr auto raw_size() const -> idx {
            return static_cast<idx>(sizeof(T));
        }

        // `is_inline()` always holds false if the call is not intercepted by an
        // `inline_memory_handle`.
        [[nodiscard]]
        constexpr auto is_inline() const -> bool {
            return false;
        }
    };

    // A `multi_memory_handle` wraps another memory handle for `*_multi`
    // allocations. It effectively overrides `handle_type`'s `.size()` and
    // `.raw_size()` methods with the length of an allocated array.
    template <typename handle_type>
    struct multi_memory_handle {
        static constexpr bool is_inline_handle = handle_type::is_inline_handle;
        static constexpr bool is_multi_handle = true;
        using allocation_type = handle_type::allocation_type;
        handle_type handle;

        // How large this allocation was, in terms of `allocation_type`.
        idx array_length;

        multi_memory_handle() = default;

        multi_memory_handle(handle_type input_handle) : handle(input_handle) {
        }

        // TODO: Variadic emplace.
        void set_inline_storage(allocation_type value) {
            this->handle.set_inline_storage(value);
        }

        void set_inlined(bool inlined) {
            this->handle.set_inlined(inlined);
        }

        // Intercept a propagating call to `.set_count()`.
        void set_count(idx count) {
            // This conversion to `idx` is safe, because `count` is always
            // positive.
            this->array_length = count;
        }

        // Intercept a propagating call to `.size()`.
        [[nodiscard]]
        auto size() const -> idx {
            return this->array_length;
        }

        // Intercept a propagating call to `.raw_size()`.
        [[nodiscard]]
        auto raw_size() const -> idx {
            return idx(this->array_length * sizeof(allocation_type));
        }

        [[nodiscard]]
        constexpr auto is_inline() const -> bool {
            return this->handle.is_inline();
        }

        // Get the allocator-specific handle type.
        auto get() & -> decltype(auto) {
            return this->handle.get();
        }

        // Get the allocator-specific handle type.
        auto get() const& -> decltype(auto) {
            return this->handle.get();
        }

        auto get_inline() & -> allocation_type& {
            return this->handle.get_inline();
        }

        auto get_inline() const& -> allocation_type const& {
            return this->handle.get_inline();
        }
    };

    // An `inline_memory_handle` wraps another memory handle for `inline_*`
    // allocations. It extends the storage of this handle to at least 256 bytes,
    // and if the memory allocated is smaller than that, it is stored inside the
    // handle instead of inside an allocator. It effectively overrides the
    // `.is_inline()` method of the handle that it wraps.
    template <typename handle_type>
    struct inline_memory_handle {
        static constexpr bool is_inline_handle = true;
        static constexpr bool is_multi_handle = handle_type::is_multi_handle;
        using allocation_type = handle_type::allocation_type;

        union {
            handle_type handle;
            allocation_type inline_storage;
            // Reserve `inline_buffer_size` bytes to make the size
            // of this handle predictible.
            byte empty[inline_buffer_size.raw];
        };

        bool is_on_stack;

        // The default constructor must not initialize data.
        // NOLINTNEXTLINE This would be ill-formed if it is `default`ed.
        inline_memory_handle() {
        }

        inline_memory_handle(handle_type input_handle)
            : handle(input_handle), is_on_stack(handle.is_inline()) {
        }

        ~inline_memory_handle() {
            if (this->is_on_stack) {
                this->inline_storage.~allocation_type();
            }
        }

        // Intercept a propagating call to `.set_inline_storage()`.
        // TODO: Variadic emplace.
        void set_inline_storage(allocation_type value) {
            this->inline_storage = value;
        }

        // Intercept a propagating call to `.set_inlined()`.
        void set_inlined(bool inlined) {
            this->is_on_stack = inlined;
        }

        void set_count(idx count) {
            this->handle.set_count(count);
        }

        [[nodiscard]]
        auto size() const -> idx {
            return handle.size();
        }

        [[nodiscard]]
        auto raw_size() const -> idx {
            return handle.raw_size();
        }

        [[nodiscard]]
        constexpr auto is_inline() const -> bool {
            return this->is_on_stack;
        }

        // Get the allocator-specific handle type.
        auto get() & -> decltype(auto) {
            return this->handle.get();
        }

        // Get the allocator-specific handle type.
        auto get() const& -> decltype(auto) {
            return this->handle.get();
        }

        // Intercept calls to `.get_inline()`.
        auto get_inline() & -> allocation_type& {
            return this->inline_storage;
        }

        // Intercept calls to `.get_inline()`.
        auto get_inline() const& -> allocation_type const& {
            return this->inline_storage;
        }
    };
}  // namespace detail

template <typename T, typename allocation_type = void*>
concept is_allocator = requires(T allocator) {
                           // Every allocator has a  `.alloc()` method.
                           allocator.template alloc<allocation_type>();

                           // TODO: It would be nice if these could make the
                           // concept more precise:
                           // allocator.free(decltype(allocator.template
                           // make_handle<allocation_typeU>(
                           //     allocation_typeU(),
                           //     sizeof(allocation_typeU))){});
                           // allocator.get(decltype(allocator.template
                           // make_handle<allocation_typeU>(
                           //     allocation_typeU(),
                           //     sizeof(allocation_typeU))){});
                       };

namespace detail {
    template <typename allocator_type>
    concept has_allocate =
        requires(allocator_type allocator) { allocator.allocate(1_sz); };

    template <typename allocator_type>
    concept has_aligned_allocate = requires(allocator_type allocator) {
                                       allocator.aligned_allocate(1_uz, 1_sz);
                                   };

    template <typename allocator_type>
    concept has_allocation_bytes = requires(allocator_type allocator) {
                                       allocator.allocation_bytes(1_uz, 1_sz);
                                   };

    template <typename allocator_type>
    concept has_allocate_feedback = requires(allocator_type allocator) {
                                        allocator.allocate_feedback(1_sz);
                                    };

    template <typename allocator_type>
    concept has_aligned_allocate_feedback =
        requires(allocator_type allocator) {
            allocator.aligned_allocate_feedback(1_uz, 1_sz);
        };

    template <typename allocator_type>
    concept has_max_allocation_bytes =
        requires(allocator_type allocator) { allocator.max_allocation_bytes; };
}  // namespace detail

template <typename T>
using sized_allocation = tuple<T, idx>;

// TODO: Implement compact optimization.
template <typename T>
using maybe_sized_allocation = maybe<sized_allocation<T>>;

template <typename derived_type>
class allocator_interface {
  public:
    // Try to allocate a `T`.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_alloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_align_alloc<T>(alignof(T),
                                            forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_alloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a `T`.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_xalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_align_xalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_xalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto alloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_alloc<T>(alignof(T),
                                        forward<Args>(constructor_args)...);
        } else {
            return this->unalign_alloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto xalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_xalloc<T>(alignof(T),
                                         forward<Args>(constructor_args)...);
        } else {
            return this->unalign_xalloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate an array of `T`.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_alloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_align_alloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_alloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_xalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->opq_align_xalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_xalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of `T`,
    // and provide a pointer handle.
    template <typename T>

    [[nodiscard]]
    constexpr auto alloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_alloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_alloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`, and
    // provide a pointer handle.
    template <typename T>

    [[nodiscard]]
    constexpr auto xalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_xalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_align_alloc(uword alignment,
                                   Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, true, false, false, false, false>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with an alignment guarantee.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_align_xalloc(uword alignment,
                                    Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, false, false, false>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto align_alloc(uword alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, true, false, true, false, false>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto align_xalloc(uword alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, true, false, false>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a `T` with no alignment guarantee.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_unalign_alloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, false, false, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with no alignment guarantee.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_unalign_xalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, false, false, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto unalign_alloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, true, false, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and provide a pointer handle.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto unalign_xalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, true, false, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate an array of `T` with alignment guarantee.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_align_alloc_multi(uword alignment, idx count) {
        return this
            ->meta_alloc<T, false, true, true, true, false, false, false>(
                alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_align_xalloc_multi(uword alignment, idx count) {
        return this
            ->meta_alloc<T, false, false, true, true, false, false, false>(
                alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle.
    template <typename T>

    [[nodiscard]]
    constexpr auto align_alloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, true, true, true, true, false, false>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle.
    template <typename T>

    [[nodiscard]]
    constexpr auto align_xalloc_multi(uword alignment, idx count) {
        return this
            ->meta_alloc<T, false, false, true, true, true, false, false>(
                alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_unalign_alloc_multi(idx count) {
        return this
            ->meta_alloc<T, false, true, false, true, false, false, false>(
                1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_unalign_xalloc_multi(idx count) {
        return this
            ->meta_alloc<T, false, false, false, true, false, false, false>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle.
    template <typename T>

    [[nodiscard]]
    constexpr auto unalign_alloc_multi(idx count) {
        return this
            ->meta_alloc<T, false, true, false, true, true, false, false>(
                1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle.
    template <typename T>

    [[nodiscard]]
    constexpr auto unalign_xalloc_multi(idx count) {
        return this
            ->meta_alloc<T, false, false, false, true, true, false, false>(
                1u, count);
    }

    // Try to allocate a small-size optimized `T`.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_alloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_alloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->inline_unalign_alloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a small-size optimized `T`.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_xalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_xalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->inline_unalign_xalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_alloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_alloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_alloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_xalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_xalloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_xalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_align_alloc(uword alignment,
                                      Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, true, true, false, false, false, false>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_align_xalloc(uword alignment,
                                       Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, true, false, false, false, false>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_unalign_alloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, true, false, false, false, false, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_unalign_xalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, false, false, false, false, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_alloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, true, true, true, true, false, false, false>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_xalloc_multi(uword alignment, idx count) {
        return this
            ->meta_alloc<T, true, false, true, true, false, false, false>(
                alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_alloc_multi(idx count) {
        return this
            ->meta_alloc<T, true, true, false, true, false, false, false>(
                1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_xalloc_multi(idx count) {
        return this
            ->meta_alloc<T, true, false, false, true, false, false, false>(
                1u, count);
    }

    // Try to get the number of bytes that allocating a `T` would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto nalloc() -> maybe_non_zero<idx> {
        return this->align_nalloc<T>(alignof(T));
    }

    // Get the number of bytes that allocating a `T` would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto xnalloc() -> idx {
        return this->align_xnalloc<T>(alignof(T));
    }

    // Try to get the number of bytes that allocating an array of `T` would
    // reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto nalloc_multi(idx count) -> maybe_non_zero<idx> {
        return this->align_nalloc_multi<T>(alignof(T), count);
    }

    // Get the number of bytes that allocating an array of `T` would
    // reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto xnalloc_multi(idx count) -> idx {
        return this->align_nalloc_multi<T>(alignof(T), count).value();
    }

    // Try to get the number of bytes that allocating a `T` with an alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto align_nalloc(uword alignment) -> maybe_non_zero<idx> {
        return this->self().allocation_bytes(alignment, sizeof(T));
    }

    // Get the number of bytes that allocating a `T` with an alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto align_xnalloc(uword alignment) -> idx {
        return this->self().allocation_bytes(alignment, sizeof(T)).value();
    }

    // Try to get the number of bytes that allocating a `T` with no alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto unalign_nalloc() -> maybe_non_zero<idx> {
        return this->self().allocation_bytes(1u, sizeof(T));
    }

    // Get the number of bytes that allocating a `T` with no alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto unalign_xnalloc() -> idx {
        return this->self().allocation_bytes(1u, sizeof(T)).value();
    }

    // Try to get the number of bytes that allocating an array of `T` with an
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto align_nalloc_multi(uword alignment, idx count)
        -> maybe_non_zero<idx> {
        return this->self().allocation_bytes(alignment, idx(count * sizeof(T)));
    }

    // Get the number of bytes that allocating an array of `T` with an
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto align_xnalloc_multi(uword alignment, idx count) -> idx {
        return this->self()
            .allocation_bytes(alignment, idx(count * sizeof(T)))
            .value();
    }

    // Try to get the number of bytes that allocating an array of `T` with no
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto unalign_nalloc_multi(idx count) -> maybe_non_zero<idx> {
        return this->self().allocation_bytes(1u, count * sizeof(T));
    }

    // Get the number of bytes that allocating an array of `T` with no
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto unalign_xnalloc_multi(idx count) -> idx {
        return this->self().allocation_bytes(1u, count * sizeof(T)).value();
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_nalloc() -> maybe_non_zero<idx> {
        return this->inline_align_nalloc<T>(alignof(T));
    }

    // Get the number of bytes that allocating a small-size optimized `T`
    // would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_xnalloc() -> idx {
        return this->inline_align_xnalloc<T>(alignof(T));
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_nalloc_multi(idx count) -> maybe_non_zero<idx> {
        return this->inline_align_nalloc_multi<T>(alignof(T), count);
    }

    // Get the number of bytes that allocating a small-size optimized array of
    // `T` would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_xnalloc_multi(idx count) -> idx {
        return this->inline_align_xnalloc_multi<T>(alignof(T), count);
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_nalloc(uword alignment) -> maybe_non_zero<idx> {
        if constexpr (sizeof(T) > inline_buffer_size) {
            return this->self().allocation_bytes(alignment, sizeof(T));
        } else {
            return inline_buffer_size;
        }
    }

    // Get the number of bytes that allocating a small-size optimized `T` with
    // an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_xnalloc(uword alignment) -> idx {
        return this->inline_align_nalloc<T>(alignment).value();
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_nalloc() -> maybe_non_zero<idx> {
        return this->inline_align_nalloc<T>(1u);
    }

    // Get the number of bytes that allocating a small-size optimized `T` with
    // no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_xnalloc() -> idx {
        return this->inline_align_xnalloc<T>(1u);
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_nalloc_multi(uword alignment, idx count)
        -> maybe_non_zero<idx> {
        if (count * sizeof(T) > inline_buffer_size) {
            return this->self().allocation_bytes(alignment, count * sizeof(T));
        }
        return inline_buffer_size;
    }

    // Get the number of bytes that allocating a small-size optimized
    // array of `T` with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_xnalloc_multi(uword alignment, idx count)
        -> idx {
        return this->inline_align_nalloc_multi<T>(alignment, count).value();
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_nalloc_multi(idx count)
        -> maybe_non_zero<idx> {
        return this->inline_align_nalloc_multi<T>(1u, count);
    }

    // Get the number of bytes that allocating a small-size optimized
    // array of `T` with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_xnalloc_multi(idx count) -> idx {
        return this->inline_align_xnalloc_multi<T>(1u, count);
    }

    // Try to allocate a `T`, and return the number of bytes that were
    // allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_salloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_salloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_salloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a `T`, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_xsalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xsalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_xsalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto salloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_salloc<T>(alignof(T),
                                         forward<Args>(constructor_args)...);
        } else {
            return this->unalign_salloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto xsalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_xsalloc<T>(alignof(T),
                                          forward<Args>(constructor_args)...);
        } else {
            return this->unalign_xsalloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate an array of `T`, and return the number of bytes that were
    // allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_salloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_salloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_salloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`, and return the number of bytes that were
    // allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_xsalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xsalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_xsalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of `T`,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto salloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->align_salloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_salloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto xsalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->align_xsalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xsalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee, and return the number
    // of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_align_salloc(uword alignment,
                                    Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, true, false, false, false, true>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with an alignment guarantee, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_align_xsalloc(uword alignment,
                                     Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, false, false, true>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto align_salloc(uword alignment, Args&&... constructor_args) {
        return this->meta_alloc<T, false, true, true, false, true, false, true>(
            alignment, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto align_xsalloc(uword alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, true, false, true>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a `T` with no alignment guarantee, and return the number
    // of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_unalign_salloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, false, false, true>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with no alignment guarantee, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_unalign_xsalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, false, false, true>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto unalign_salloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, true, false, true>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto unalign_xsalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, true, false, true>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_align_salloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, true, true, true, false, false, true>(
            alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_align_xsalloc_multi(uword alignment, idx count) {
        return this
            ->meta_alloc<T, false, false, true, true, false, false, true>(
                alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    template <typename T>

    [[nodiscard]]
    constexpr auto align_salloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, true, true, true, true, false, true>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with an
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T>

    [[nodiscard]]
    constexpr auto align_xsalloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, false, true, true, true, false, true>(
            alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_unalign_salloc_multi(idx count) {
        return this->meta_alloc<T, false, true, false, true, true, false, true>(
            1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_unalign_xsalloc_multi(idx count) {
        return this
            ->meta_alloc<T, false, false, false, true, false, false, true>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    template <typename T>

    [[nodiscard]]
    constexpr auto unalign_salloc_multi(idx count) {
        return this->meta_alloc<T, false, true, false, true, true, false, true>(
            1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with no
    // alignment guarantee, and return the number of bytes that were allocated.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto unalign_xsalloc_multi(idx count) {
        return this
            ->meta_alloc<T, false, false, false, true, true, false, true>(
                1u, count);
    }

    // Try to allocate a small-size optimized `T`, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_salloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_salloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->inline_unalign_salloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a small-size optimized `T`, and return the number of bytes that
    // were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_xsalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xsalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->inline_unalign_xsalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`, and return the
    // number of bytes that were allocated.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_salloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_salloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_salloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`, and return the number of
    // bytes that were allocated.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_xsalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xsalloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_xsalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_align_salloc(uword alignment,
                                       Args&&... constructor_args) {
        return this->meta_alloc<T, true, true, true, false, false, false, true>(
            alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_align_xsalloc(uword alignment,
                                        Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, true, false, false, false, true>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee,
    // and return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_unalign_salloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, true, false, false, false, false, true>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee, and
    // return the number of bytes that were allocated.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_unalign_xsalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, false, false, false, false, true>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_salloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, true, true, false, true, false, false, true>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_xsalloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, true, false, true, true, false, false, true>(
            alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_salloc_multi(idx count) {
        return this->meta_alloc<T, true, true, false, true, false, false, true>(
            1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_xsalloc_multi(idx count) {
        return this
            ->meta_alloc<T, true, false, false, true, false, false, true>(
                1u, count);
    }

    // Try to allocate a `T`.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_calloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_calloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_calloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a `T`.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_xcalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xcalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_xcalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto calloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_calloc<T>(alignof(T),
                                         forward<Args>(constructor_args)...);
        } else {
            return this->unalign_calloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // provide a pointer handle.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto xcalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_xcalloc<T>(alignof(T),
                                          forward<Args>(constructor_args)...);
        } else {
            return this->unalign_xcalloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate an array of `T`.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_calloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_calloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_calloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_xcalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xcalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_xcalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T`, and provide a pointer handle.
    template <typename T>

    [[nodiscard]]
    constexpr auto calloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->align_calloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_calloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`, and
    // provide a pointer handle.
    template <typename T>

    [[nodiscard]]
    constexpr auto xcalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->align_xcalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xcalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_align_calloc(uword alignment,
                                    Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, true, false, false, true, false>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with an alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_align_xcalloc(uword alignment,
                                     Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, false, true, false>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto align_calloc(uword alignment, Args&&... constructor_args) {
        return this->meta_alloc<T, false, true, true, false, true, true, false>(
            alignment, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto align_xcalloc(uword alignment, Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, true, true, false>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a `T` with no alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_unalign_calloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, false, true, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with no alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto opq_unalign_xcalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, false, true, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto unalign_calloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, true, true, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and provide a pointer handle, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto unalign_xcalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, true, true, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate an array of `T` with alignment guarantee, and zero-out
    // the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_align_calloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, true, true, true, false, true, false>(
            alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_align_xcalloc_multi(uword alignment, idx count) {
        return this
            ->meta_alloc<T, false, false, true, true, false, true, false>(
                alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with an alignment guarantee, and provide a pointer handle, and
    // zero-out the allocated memory.
    template <typename T>

    [[nodiscard]]
    constexpr auto align_calloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, true, true, true, true, true, false>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle, and zero-out
    // the allocated memory.
    template <typename T>

    [[nodiscard]]
    constexpr auto align_xcalloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, false, true, true, true, true, false>(
            alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee, and zero-out
    // the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_unalign_calloc_multi(idx count) {
        return this->meta_alloc<T, false, true, false, true, true, true, false>(
            1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_unalign_xcalloc_multi(idx count) {
        return this
            ->meta_alloc<T, false, false, false, true, true, true, false>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with no alignment guarantee, and provide a pointer handle, and
    // zero-out the allocated memory.
    template <typename T>

    [[nodiscard]]
    constexpr auto unalign_calloc_multi(idx count) {
        return this->meta_alloc<T, false, true, false, true, true, true, false>(
            1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle, and zero-out
    // the allocated memory.
    template <typename T>

    [[nodiscard]]
    constexpr auto unalign_xcalloc_multi(idx count) {
        return this
            ->meta_alloc<T, false, false, false, true, true, true, false>(
                1u, count);
    }

    // Try to allocate a small-size optimized `T`, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_calloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_calloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->inline_unalign_calloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a small-size optimized `T`, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_xcalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xcalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->inline_unalign_xcalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_calloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_calloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_calloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_xcalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xcalloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_xcalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_align_calloc(uword alignment,
                                       Args&&... constructor_args) {
        return this->meta_alloc<T, true, true, true, false, false, true, false>(
            alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee, and
    // zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_align_xcalloc(uword alignment,
                                        Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, true, false, false, true, false>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_unalign_calloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, true, false, false, false, true, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee, and
    // zero-out the allocated memory.
    template <typename T, typename... Args>
        requires(is_constructible<T, Args...>)
    [[nodiscard]]
    constexpr auto inline_unalign_xcalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, false, false, false, true, false>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_calloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, true, true, true, true, false, true, false>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_xcalloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, true, false, true, true, false, true, false>(
            alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_calloc_multi(idx count) {
        return this->meta_alloc<T, true, true, false, true, false, true, false>(
            1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_xcalloc_multi(idx count) {
        return this
            ->meta_alloc<T, true, false, false, true, false, true, false>(
                1u, count);
    }

    // Try to allocate a `T`, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto opq_scalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_scalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_scalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a `T`, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto opq_xscalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xscalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->opq_unalign_xscalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto scalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_scalloc<T>(alignof(T),
                                          forward<Args>(constructor_args)...);
        } else {
            return this->unalign_scalloc<T>(forward<Args>(constructor_args)...);
        }
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto xscalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->align_xscalloc<T>(alignof(T),
                                           forward<Args>(constructor_args)...);
        } else {
            return this->unalign_xscalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate an array of `T`, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_scalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_scalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_scalloc_multi<T>(count);
        }
    }

    // Allocate an array of `T`, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_xscalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->opq_align_xscalloc_multi<T>(alignof(T), count);
        } else {
            return this->opq_unalign_xscalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T`, and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto scalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->align_scalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_scalloc_multi<T>(count);
        }
    }

    // If this allocator has pointer stability, allocate an array of `T`,
    // and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto xscalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->align_xscalloc_multi<T>(alignof(T), count);
        } else {
            return this->unalign_xscalloc_multi<T>(count);
        }
    }

    // Try to allocate a `T` with an alignment guarantee, and return the number
    // of bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto opq_align_scalloc(uword alignment,
                                     Args&&... constructor_args) {
        return this->meta_alloc<T, false, true, true, false, false, true, true>(
            alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with an alignment guarantee, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto opq_align_xscalloc(uword alignment,
                                      Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, true, false, false, true, true>(
                alignment, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto align_scalloc(uword alignment, Args&&... constructor_args) {
        return this->meta_alloc<T, false, true, true, false, true, true, true>(
            alignment, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto align_xscalloc(uword alignment, Args&&... constructor_args) {
        return this->meta_alloc<T, false, false, true, false, true, true, true>(
            alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a `T` with no alignment guarantee, and return the number
    // of bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto opq_unalign_scalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, true, false, false, false, true, true>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a `T` with no alignment guarantee, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto opq_unalign_xscalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, false, true, true>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto unalign_scalloc(Args&&... constructor_args) {
        return this->meta_alloc<T, false, true, false, false, true, true, true>(
            1u, 1u, forward<Args>(constructor_args)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and return the number of bytes that were allocated,
    // and zero-out the allocated memory.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto unalign_xscalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, false, false, false, false, true, true, true>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_align_scalloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, true, true, true, false, true, true>(
            alignment, count);
    }

    // Allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_align_xscalloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, false, true, true, false, true, true>(
            alignment, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with an alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>

    [[nodiscard]]
    constexpr auto align_scalloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, true, true, true, true, true, true>(
            alignment, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with
    // an alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>

    [[nodiscard]]
    constexpr auto align_xscalloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, false, false, true, true, true, true, true>(
            alignment, count);
    }

    // Try to allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_unalign_scalloc_multi(idx count) {
        return this->meta_alloc<T, false, true, false, true, false, true, true>(
            1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that were allocated, and zero-out the allocated
    // memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto opq_unalign_xscalloc_multi(idx count) {
        return this
            ->meta_alloc<T, false, false, false, true, false, true, true>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of
    // `T` with no alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T>

    [[nodiscard]]
    constexpr auto unalign_scalloc_multi(idx count) {
        return this->meta_alloc<T, false, true, false, true, true, true, true>(
            1u, count);
    }

    // If this allocator has pointer stability, allocate an array of `T` with
    // no alignment guarantee, and return the number of bytes that were
    // allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>

    [[nodiscard]]
    constexpr auto unalign_xscalloc_multi(idx count) {
        return this->meta_alloc<T, false, false, false, true, true, true, true>(
            1u, count);
    }

    // Try to allocate a small-size optimized `T`, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_scalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_scalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->inline_unalign_scalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Allocate a small-size optimized `T`, and return the number of bytes that
    // were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_xscalloc(Args&&... constructor_args) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xscalloc<T>(
                alignof(T), forward<Args>(constructor_args)...);
        } else {
            return this->inline_unalign_xscalloc<T>(
                forward<Args>(constructor_args)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`, and return the
    // number of bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_scalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_scalloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_scalloc_multi<T>(count);
        }
    }

    // Allocate a small-size optimized array of `T`, and return the number of
    // bytes that were allocated, and zero-out the allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_xscalloc_multi(idx count) {
        if constexpr (alignof(T) > 1) {
            return this->inline_align_xscalloc_multi<T>(alignof(T), count);
        } else {
            return this->inline_unalign_xscalloc_multi<T>(count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee,
    // and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_align_scalloc(uword alignment,
                                        Args&&... constructor_args) {
        return this->meta_alloc<T, true, true, true, false, false, true, true>(
            alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_align_xscalloc(uword alignment,
                                         Args&&... constructor_args) {
        return this->meta_alloc<T, true, false, true, false, false, true, true>(
            alignment, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee,
    // and return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_unalign_scalloc(Args&&... constructor_args) {
        return this->meta_alloc<T, true, true, false, false, false, true, true>(
            1u, 1u, forward<Args>(constructor_args)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee, and
    // return the number of bytes that were allocated, and zero-out the
    // allocated memory.
    template <typename T, typename... Args>
    [[nodiscard]]
    constexpr auto inline_unalign_xscalloc(Args&&... constructor_args) {
        return this
            ->meta_alloc<T, true, false, false, false, false, true, true>(
                1u, 1u, forward<Args>(constructor_args)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_scalloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, true, true, true, true, false, true, true>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_align_xscalloc_multi(uword alignment, idx count) {
        return this->meta_alloc<T, true, false, true, true, false, true, true>(
            alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_scalloc_multi(idx count) {
        return this->meta_alloc<T, true, true, false, true, false, true, true>(
            1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that were allocated, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto inline_unalign_xscalloc_multi(idx count) {
        return this->meta_alloc<T, true, false, false, true, false, true, true>(
            1u, count);
    }

    // Try to move a memory handle from this allocator into another.
    [[nodiscard]]
    constexpr auto opq_realloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_alloc<T, T>, true, false>(
            allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself.
    [[nodiscard]]
    constexpr auto opq_realloc(mem auto& handle) {
        return this->opq_realloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another.
    template <typename T>
    [[nodiscard]]
    constexpr auto realloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<
            &allocator_interface<derived_type>::alloc<T, T>, true, false>(
            allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself.
    template <typename T>
    [[nodiscard]]
    constexpr auto realloc(T* p_handle) {
        return this->realloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another.
    [[nodiscard]]
    constexpr auto opq_xrealloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_xalloc<T, T>, false, false>(
            allocator, handle);
    }

    // Move a memory handle from this allocator into itself.
    [[nodiscard]]
    constexpr auto opq_xrealloc(mem auto& handle) {
        return this->opq_xrealloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrealloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<
            &allocator_interface<derived_type>::xalloc<T, T>, false, false>(
            allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrealloc(T* p_handle) {
        return this->xrealloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee.
    [[nodiscard]]
    constexpr auto opq_align_realloc_to(auto& allocator, mem auto& handle,
                                        uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_align_alloc<T, T>, true,
            false>(allocator, handle, alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee.
    [[nodiscard]]
    constexpr auto opq_align_realloc(mem auto& handle, uword alignment) {
        return this->opq_align_realloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee.
    [[nodiscard]]
    constexpr auto opq_align_xrealloc_to(auto& allocator, mem auto& handle,
                                         uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_align_xalloc<T, T>, false,
            false>(allocator, handle, alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee.
    auto opq_align_xrealloc(mem auto& handle, uword alignment) {
        return this->opq_align_xrealloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee.
    [[nodiscard]]
    constexpr auto opq_unalign_realloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_unalign_alloc<T, T>, true,
            false>(allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee.
    [[nodiscard]]
    constexpr auto opq_unalign_realloc(mem auto& handle) {
        return this->opq_unalign_realloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee.
    [[nodiscard]]
    constexpr auto opq_unalign_xrealloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_unalign_xalloc<T, T>, false,
            false>(allocator, handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee.
    auto opq_unalign_xrealloc(mem auto& handle) {
        return this->opq_unalign_xrealloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee.
    [[nodiscard]]
    constexpr auto align_realloc_to(auto& allocator, auto* p_handle,
                                    uword alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::align_alloc<T, T>, true, false>(
            allocator, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee.
    [[nodiscard]]
    constexpr auto align_realloc(auto* p_handle, uword alignment) {
        return this->align_realloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee.
    [[nodiscard]]
    constexpr auto align_xrealloc_to(auto& allocator, auto* p_handle,
                                     uword alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::align_xalloc<T, T>, false,
            false>(allocator, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee.
    auto align_xrealloc(auto* p_handle, uword alignment) {
        return this->align_xrealloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee.
    [[nodiscard]]
    constexpr auto unalign_realloc_to(auto& allocator, auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::unalign_alloc<T, T>, true,
            false>(allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee.
    [[nodiscard]]
    constexpr auto unalign_realloc(auto* p_handle) {
        return this->unalign_realloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee.
    [[nodiscard]]
    constexpr auto unalign_xrealloc_to(auto& allocator, auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::unalign_xalloc<T, T>, false,
            false>(allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee.
    auto unalign_xrealloc(auto* p_handle) {
        return this->unalign_xrealloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another.
    [[nodiscard]]
    constexpr auto opq_realloc_multi_to(auto& allocator, mem auto& handle,
                                        idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_alloc_multi<T>, true,
            false>(allocator, handle, new_count);
    }

    // Try to move an array memory handle from this allocator into itself.
    [[nodiscard]]
    constexpr auto opq_realloc_multi(mem auto& handle, idx new_count) {
        return this->opq_realloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another.
    template <typename T>
    [[nodiscard]]
    constexpr auto realloc_multi_to(auto& allocator, T* p_handle, idx old_count,
                                    idx new_count) {
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::alloc_multi<T>, true, false>(
            allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself.
    template <typename T>
    [[nodiscard]]
    constexpr auto realloc_multi(T* p_handle, idx old_count, idx new_count) {
        return this->realloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another.
    [[nodiscard]]
    constexpr auto opq_xrealloc_multi_to(auto& allocator, mem auto& handle,
                                         idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_xalloc_multi<T>, false,
            false>(allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself.
    [[nodiscard]]
    constexpr auto opq_xrealloc_multi(mem auto& handle, idx new_count) {
        return this->opq_xrealloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrealloc_multi_to(auto& allocator, T* p_handle,
                                     idx old_count, idx new_count) {
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::xalloc_multi<T>, false, false>(
            allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrealloc_multi(T* p_handle, idx old_count, idx new_count) {
        return this->xrealloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another.
    [[nodiscard]]
    constexpr auto opq_align_realloc_multi_to(auto& allocator, mem auto& handle,
                                              uword alignment, idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_align_alloc_multi<T>, true,
            false>(allocator, handle, new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee.
    [[nodiscard]]
    constexpr auto opq_align_realloc_multi(mem auto& handle, uword alignment,
                                           idx new_count) {
        return this->opq_align_realloc_multi_to(*this, handle, alignment,
                                                new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee.
    [[nodiscard]]
    constexpr auto opq_align_xrealloc_multi_to(auto& allocator,
                                               mem auto& handle,
                                               uword alignment, idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_align_xalloc_multi<T>,
            false, false>(allocator, handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee.
    auto opq_align_xrealloc_multi(mem auto& handle, uword alignment,
                                  idx new_count) {
        return this->opq_align_xrealloc_multi_to(*this, handle, alignment,
                                                 new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee.
    [[nodiscard]]
    constexpr auto opq_unalign_realloc_multi_to(auto& allocator,
                                                mem auto& handle,
                                                idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_unalign_alloc_multi<T>,
            true, false>(allocator, handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee.
    [[nodiscard]]
    constexpr auto opq_unalign_realloc_multi(mem auto& handle, idx new_count) {
        return this->opq_unalign_realloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee.
    [[nodiscard]]
    constexpr auto opq_unalign_xrealloc_multi_to(auto& allocator,
                                                 mem auto& handle,
                                                 idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_unalign_xalloc_multi<T>,
            false, false>(allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee.
    auto opq_unalign_xrealloc_multi(mem auto& handle, idx new_count) {
        return this->opq_unalign_xrealloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee.
    [[nodiscard]]
    constexpr auto align_realloc_multi_to(auto& allocator, auto* p_handle,
                                          uword alignment, idx old_count,
                                          idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::align_alloc_multi<T>, true,
            false>(allocator, p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee.
    [[nodiscard]]
    constexpr auto align_realloc_multi(auto* p_handle, uword alignment,
                                       idx old_count, idx new_count) {
        return this->align_realloc_multi_to(*this, p_handle, alignment,
                                            old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee.
    [[nodiscard]]
    constexpr auto align_xrealloc_multi_to(auto& allocator, auto* p_handle,
                                           uword alignment, idx old_count,
                                           idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::align_xalloc_multi<T>, false,
            false>(allocator, p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee.
    auto align_xrealloc_multi(auto* p_handle, uword alignment, idx old_count,
                              idx new_count) {
        return this->align_xrealloc_multi_to(*this, p_handle, alignment,
                                             old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee.
    [[nodiscard]]
    constexpr auto unalign_realloc_multi_to(auto& allocator, auto* p_handle,
                                            idx old_count, idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::unalign_alloc_multi<T>, true,
            false>(allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee.
    [[nodiscard]]
    constexpr auto unalign_realloc_multi(auto* p_handle, idx old_count,
                                         idx new_count) {
        return this->unalign_realloc_multi_to(*this, p_handle, old_count,
                                              new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee.
    [[nodiscard]]
    constexpr auto unalign_xrealloc_multi_to(auto& allocator, auto* p_handle,
                                             idx old_count, idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::unalign_xalloc_multi<T>, false,
            false>(allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee.
    auto unalign_xrealloc_multi(auto* p_handle, idx old_count, idx new_count) {
        return this->unalign_xrealloc_multi_to(*this, p_handle, old_count,
                                               new_count);
    }

    // Try to move a memory handle from this allocator into another, and
    // zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_recalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_calloc<T, T>, true, false>(
            allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself, and zero-out
    // the allocated memory.
    [[nodiscard]]
    constexpr auto opq_recalloc(mem auto& handle) {
        return this->opq_recalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto recalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<
            &allocator_interface<derived_type>::calloc<T, T>, true, false>(
            allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself, and
    // zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto recalloc(T* p_handle) {
        return this->recalloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another, and zero-out the
    // allocated memory.
    [[nodiscard]]
    constexpr auto opq_xrecalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_xcalloc<T, T>, false,
            false>(allocator, handle);
    }

    // Move a memory handle from this allocator into itself, and zero-out the
    // allocated memory.
    [[nodiscard]]
    constexpr auto opq_xrecalloc(mem auto& handle) {
        return this->opq_xrecalloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrecalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<
            &allocator_interface<derived_type>::xcalloc<T, T>, false, false>(
            allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself, and zero-out the
    // allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrecalloc(T* p_handle) {
        return this->xrecalloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_align_recalloc_to(auto& allocator, mem auto& handle,
                                         uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_align_calloc<T, T>, true,
            false>(allocator, handle, alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_align_recalloc(mem auto& handle, uword alignment) {
        return this->opq_align_recalloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_align_xrecalloc_to(auto& allocator, mem auto& handle,
                                          uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_align_xcalloc<T, T>, false,
            false>(allocator, handle, alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee, and zero-out the allocated memory.
    auto opq_align_xrecalloc(mem auto& handle, uword alignment) {
        return this->opq_align_xrecalloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_unalign_recalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_unalign_calloc<T, T>, true,
            false>(allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_unalign_recalloc(mem auto& handle) {
        return this->opq_unalign_recalloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_unalign_xrecalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_unalign_xcalloc<T, T>,
            false, false>(allocator, handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee, and zero-out the allocated memory.
    auto opq_unalign_xrecalloc(mem auto& handle) {
        return this->opq_unalign_xrecalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto align_recalloc_to(auto& allocator, auto* p_handle,
                                     uword alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::align_calloc<T, T>, true,
            false>(allocator, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto align_recalloc(auto* p_handle, uword alignment) {
        return this->align_recalloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto align_xrecalloc_to(auto& allocator, auto* p_handle,
                                      uword alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::align_xcalloc<T, T>, false,
            false>(allocator, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee, and zero-out the allocated memory.
    auto align_xrecalloc(auto* p_handle, uword alignment) {
        return this->align_xrecalloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto unalign_recalloc_to(auto& allocator, auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::unalign_calloc<T, T>, true,
            false>(allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto unalign_recalloc(auto* p_handle) {
        return this->unalign_recalloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto unalign_xrecalloc_to(auto& allocator, auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::unalign_xcalloc<T, T>, false,
            false>(allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee, and zero-out the allocated memory.
    auto unalign_xrecalloc(auto* p_handle) {
        return this->unalign_xrecalloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another, and
    // zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_recalloc_multi_to(auto& allocator, mem auto& handle,
                                         idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_calloc_multi<T>, true,
            false>(allocator, handle, new_count);
    }

    // Try to move an array memory handle from this allocator into itself, and
    // zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_recalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_recalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto recalloc_multi_to(auto& allocator, T* p_handle,
                                     idx old_count, idx new_count) {
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::calloc_multi<T>, true, false>(
            allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself, and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto recalloc_multi(T* p_handle, idx old_count, idx new_count) {
        return this->recalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_xrecalloc_multi_to(auto& allocator, mem auto& handle,
                                          idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_xcalloc_multi<T>, false,
            false>(allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself,
    // and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_xrecalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_xrecalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another,
    // and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrecalloc_multi_to(auto& allocator, T* p_handle,
                                      idx old_count, idx new_count) {
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::xcalloc_multi<T>, false, false>(
            allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself,
    // and zero-out the allocated memory.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrecalloc_multi(T* p_handle, idx old_count, idx new_count) {
        return this->xrecalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_align_recalloc_multi_to(auto& allocator,
                                               mem auto& handle,
                                               uword alignment, idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_align_calloc_multi<T>, true,
            false>(allocator, handle, new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_align_recalloc_multi(mem auto& handle, uword alignment,
                                            idx new_count) {
        return this->opq_align_recalloc_multi_to(*this, handle, alignment,
                                                 new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_align_xrecalloc_multi_to(auto& allocator,
                                                mem auto& handle,
                                                uword alignment,
                                                idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_align_xcalloc_multi<T>,
            false, false>(allocator, handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee, and zero-out the allocated memory.
    auto opq_align_xrecalloc_multi(mem auto& handle, uword alignment,
                                   idx new_count) {
        return this->opq_align_xrecalloc_multi_to(*this, handle, alignment,
                                                  new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_unalign_recalloc_multi_to(auto& allocator,
                                                 mem auto& handle,
                                                 idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_unalign_calloc_multi<T>,
            true, false>(allocator, handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_unalign_recalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_unalign_recalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto opq_unalign_xrecalloc_multi_to(auto& allocator,
                                                  mem auto& handle,
                                                  idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_unalign_xcalloc_multi<T>,
            false, false>(allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee, and zero-out the allocated memory.
    auto opq_unalign_xrecalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_unalign_xrecalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto align_recalloc_multi_to(auto& allocator, auto* p_handle,
                                           uword alignment, idx old_count,
                                           idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::align_calloc_multi<T>, true,
            false>(allocator, p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto align_recalloc_multi(auto* p_handle, uword alignment,
                                        idx old_count, idx new_count) {
        return this->align_recalloc_multi_to(*this, p_handle, alignment,
                                             old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto align_xrecalloc_multi_to(auto& allocator, auto* p_handle,
                                            uword alignment, idx old_count,
                                            idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::align_xcalloc_multi<T>, false,
            false>(allocator, p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee, and zero-out the allocated memory.
    auto align_xrecalloc_multi(auto* p_handle, uword alignment, idx old_count,
                               idx new_count) {
        return this->align_xrecalloc_multi_to(*this, p_handle, alignment,
                                              old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto unalign_recalloc_multi_to(auto& allocator, auto* p_handle,
                                             idx old_count, idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::unalign_calloc_multi<T>, true,
            false>(allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto unalign_recalloc_multi(auto* p_handle, idx old_count,
                                          idx new_count) {
        return this->unalign_recalloc_multi_to(*this, p_handle, old_count,
                                               new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto unalign_xrecalloc_multi_to(auto& allocator, auto* p_handle,
                                              idx old_count, idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::unalign_xcalloc_multi<T>, false,
            false>(allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee, and zero-out the allocated memory.
    auto unalign_xrecalloc_multi(auto* p_handle, idx old_count, idx new_count) {
        return this->unalign_xrecalloc_multi_to(*this, p_handle, old_count,
                                                new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another.
    [[nodiscard]]
    constexpr auto inline_realloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_alloc<T, T>, true,
            false>(allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself.
    [[nodiscard]]
    constexpr auto inline_realloc(mem auto& handle) {
        return this->inline_realloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another.
    [[nodiscard]]
    constexpr auto inline_xrealloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_xalloc<T, T>, false,
            false>(allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself.
    [[nodiscard]]
    constexpr auto inline_xrealloc(mem auto& handle) {
        return this->inline_xrealloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_align_realloc_to(auto& allocator, mem auto& handle,
                                           uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_align_alloc<T, T>, true,
            false>(allocator, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_align_realloc(mem auto& handle, uword alignment) {
        return this->inline_align_realloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_align_xrealloc_to(auto& allocator, mem auto& handle,
                                            uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_align_xalloc<T, T>,
            false, false>(allocator, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee.
    auto inline_align_xrealloc(mem auto& handle, uword alignment) {
        return this->inline_align_xrealloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_unalign_realloc_to(auto& allocator,
                                             mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_unalign_alloc<T, T>,
            true, false>(allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_unalign_realloc(mem auto& handle) {
        return this->inline_unalign_realloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_unalign_xrealloc_to(auto& allocator,
                                              mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_unalign_xalloc<T, T>,
            false, false>(allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee.
    auto inline_unalign_xrealloc(mem auto& handle) {
        return this->inline_unalign_xrealloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another.
    [[nodiscard]]
    constexpr auto inline_realloc_multi_to(auto& allocator, mem auto& handle,
                                           idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_alloc_multi<T>, true,
            false>(allocator, handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself.
    [[nodiscard]]
    constexpr auto inline_realloc_multi(mem auto& handle, idx new_count) {
        return this->opq_realloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another.
    [[nodiscard]]
    constexpr auto inline_xrealloc_multi_to(auto& allocator, mem auto& handle,
                                            idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_xalloc_multi<T>, false,
            false>(allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself.
    [[nodiscard]]
    constexpr auto inline_xrealloc_multi(mem auto& handle, idx new_count) {
        return this->inline_xrealloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another.
    [[nodiscard]]
    constexpr auto inline_align_realloc_multi_to(auto& allocator,
                                                 mem auto& handle,
                                                 uword alignment,
                                                 idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_align_alloc_multi<T>,
            true, false>(allocator, handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_align_realloc_multi(mem auto& handle, uword alignment,
                                              idx new_count) {
        return this->inline_align_realloc_multi_to(*this, handle, alignment,
                                                   new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_align_xrealloc_multi_to(auto& allocator,
                                                  mem auto& handle,
                                                  uword alignment,
                                                  idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_align_xalloc_multi<T>,
            false, false>(allocator, handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee.
    auto inline_align_xrealloc_multi(mem auto& handle, uword alignment,
                                     idx new_count) {
        return this->inline_align_xrealloc_multi_to(*this, handle, alignment,
                                                    new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_unalign_realloc_multi_to(auto& allocator,
                                                   mem auto& handle,
                                                   idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_unalign_alloc_multi<T>,
            true, false>(allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_unalign_realloc_multi(mem auto& handle,
                                                idx new_count) {
        return this->inline_unalign_realloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee.
    [[nodiscard]]
    constexpr auto inline_unalign_xrealloc_multi_to(auto& allocator,
                                                    mem auto& handle,
                                                    idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_unalign_xalloc_multi<T>,
            false, false>(allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee.
    auto inline_unalign_xrealloc_multi(mem auto& handle, idx new_count) {
        return this->inline_unalign_xrealloc_multi_to(*this, handle, new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_recalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_calloc<T, T>, true, false>(
            allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_recalloc(mem auto& handle) {
        return this->inline_recalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another, and
    // zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_xrecalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_xcalloc<T, T>, false,
            false>(allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself, and
    // zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_xrecalloc(mem auto& handle) {
        return this->inline_xrecalloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_align_recalloc_to(auto& allocator, mem auto& handle,
                                            uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_align_calloc<T, T>, true,
            false>(allocator, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_align_recalloc(mem auto& handle, uword alignment) {
        return this->inline_align_recalloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_align_xrecalloc_to(auto& allocator, mem auto& handle,
                                             uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_align_xcalloc<T, T>,
            false, false>(allocator, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee, and zero-out the allocated memory.
    auto inline_align_xrecalloc(mem auto& handle, uword alignment) {
        return this->inline_align_xrecalloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_unalign_recalloc_to(auto& allocator,
                                              mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_unalign_calloc<T, T>,
            true, false>(allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_unalign_recalloc(mem auto& handle) {
        return this->inline_unalign_recalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_unalign_xrecalloc_to(auto& allocator,
                                               mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_unalign_xcalloc<T, T>,
            false, false>(allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee, and zero-out the allocated memory.
    auto inline_unalign_xrecalloc(mem auto& handle) {
        return this->inline_unalign_xrecalloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_recalloc_multi_to(auto& allocator, mem auto& handle,
                                            idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_calloc_multi<T>, true,
            false>(allocator, handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_recalloc_multi(mem auto& handle, idx new_count) {
        return this->inline_recalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_xrecalloc_multi_to(auto& allocator, mem auto& handle,
                                             idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_xcalloc_multi<T>, false,
            false>(allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_xrecalloc_multi(mem auto& handle, idx new_count) {
        return this->inline_xrecalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and zero-out the allocated memory.
    [[nodiscard]]
    constexpr auto inline_align_recalloc_multi_to(auto& allocator,
                                                  mem auto& handle,
                                                  uword alignment,
                                                  idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_align_calloc_multi<T>,
            true, false>(allocator, handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]]
    constexpr auto inline_align_recalloc_multi(mem auto& handle,
                                               uword alignment, idx new_count) {
        return this->inline_align_recalloc_multi_to(*this, handle, alignment,
                                                    new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]]
    constexpr auto inline_align_xrecalloc_multi_to(auto& allocator,
                                                   mem auto& handle,
                                                   uword alignment,
                                                   idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_align_xcalloc_multi<T>,
            false, false>(allocator, handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee, and zero-out the
    // allocated memory.
    auto inline_align_xrecalloc_multi(mem auto& handle, uword alignment,
                                      idx new_count) {
        return this->inline_align_xrecalloc_multi_to(*this, handle, alignment,
                                                     new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]]
    constexpr auto inline_unalign_recalloc_multi_to(auto& allocator,
                                                    mem auto& handle,
                                                    idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_unalign_calloc_multi<T>,
            true, false>(allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]]
    constexpr auto inline_unalign_recalloc_multi(mem auto& handle,
                                                 idx new_count) {
        return this->inline_unalign_recalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee, and zero-out the
    // allocated memory.
    [[nodiscard]]
    constexpr auto inline_unalign_xrecalloc_multi_to(auto& allocator,
                                                     mem auto& handle,
                                                     idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_unalign_xcalloc_multi<T>,
            false, false>(allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee, and zero-out the
    // allocated memory.
    auto inline_unalign_xrecalloc_multi(mem auto& handle, idx new_count) {
        return this->inline_unalign_xrecalloc_multi_to(*this, handle,
                                                       new_count);
    }

    // Try to move a memory handle from this allocator into another, and return
    // the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_resalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_salloc<T, T>, true, true>(
            allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself, and return
    // the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_resalloc(mem auto& handle) {
        return this->opq_resalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto resalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<
            &allocator_interface<derived_type>::salloc<T, T>, true, true>(
            allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself, and return
    // the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto resalloc(T* p_handle) {
        return this->resalloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_xresalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_xalloc<T, T>, false, true>(
            allocator, handle);
    }

    // Move a memory handle from this allocator into itself, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_xresalloc(mem auto& handle) {
        return this->opq_xresalloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another, and return the
    // number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto xresalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<
            &allocator_interface<derived_type>::xsalloc<T, T>, false, true>(
            allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself, and return the
    // number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto xresalloc(T* p_handle) {
        return this->xresalloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_align_resalloc_to(auto& allocator, mem auto& handle,
                                         uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_align_salloc<T, T>, true,
            true>(allocator, handle, alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_align_resalloc(mem auto& handle, uword alignment) {
        return this->opq_align_resalloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_align_xresalloc_to(auto& allocator, mem auto& handle,
                                          uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_align_xalloc<T, T>, false,
            true>(allocator, handle, alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee, and return the number of bytes that were allocated.
    auto opq_align_xresalloc(mem auto& handle, uword alignment) {
        return this->opq_align_xresalloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_resalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_unalign_salloc<T, T>, true,
            true>(allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_resalloc(mem auto& handle) {
        return this->opq_unalign_resalloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_xresalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_unalign_xalloc<T, T>, false,
            true>(allocator, handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee, and return the number of bytes that were allocated.
    auto opq_unalign_xresalloc(mem auto& handle) {
        return this->opq_unalign_xresalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto align_resalloc_to(auto& allocator, auto* p_handle,
                                     uword alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::align_salloc<T, T>, true, true>(
            allocator, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto align_resalloc(auto* p_handle, uword alignment) {
        return this->align_resalloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto align_xresalloc_to(auto& allocator, auto* p_handle,
                                      uword alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::align_xsalloc<T, T>, false,
            true>(allocator, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee, and return the number of bytes that were allocated.
    auto align_xresalloc(auto* p_handle, uword alignment) {
        return this->align_xresalloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto unalign_resalloc_to(auto& allocator, auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::unalign_salloc<T, T>, true,
            true>(allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto unalign_resalloc(auto* p_handle) {
        return this->unalign_resalloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto unalign_xresalloc_to(auto& allocator, auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::unalign_xsalloc<T, T>, false,
            true>(allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee, and return the number of bytes that were allocated.
    auto unalign_xresalloc(auto* p_handle) {
        return this->unalign_xresalloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another, and return
    // the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_resalloc_multi_to(auto& allocator, mem auto& handle,
                                         idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_salloc_multi<T>, true,
            true>(allocator, handle, new_count);
    }

    // Try to move an array memory handle from this allocator into itself, and
    // return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_resalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_resalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto resalloc_multi_to(auto& allocator, T* p_handle,
                                     idx old_count, idx new_count) {
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::salloc_multi<T>, true, true>(
            allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto resalloc_multi(T* p_handle, idx old_count, idx new_count) {
        return this->resalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_xresalloc_multi_to(auto& allocator, mem auto& handle,
                                          idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_xsalloc_multi<T>, false,
            true>(allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_xresalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_xresalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another,
    // and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto xresalloc_multi_to(auto& allocator, T* p_handle,
                                      idx old_count, idx new_count) {
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::xsalloc_multi<T>, false, true>(
            allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself,
    // and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto xresalloc_multi(T* p_handle, idx old_count, idx new_count) {
        return this->xresalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_align_resalloc_multi_to(auto& allocator,
                                               mem auto& handle,
                                               uword alignment, idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_align_salloc_multi<T>, true,
            true>(allocator, handle, new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto opq_align_resalloc_multi(mem auto& handle, uword alignment,
                                            idx new_count) {
        return this->opq_align_resalloc_multi_to(*this, handle, alignment,
                                                 new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto opq_align_xresalloc_multi_to(auto& allocator,
                                                mem auto& handle,
                                                uword alignment,
                                                idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_align_xsalloc_multi<T>,
            false, true>(allocator, handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    auto opq_align_xresalloc_multi(mem auto& handle, uword alignment,
                                   idx new_count) {
        return this->opq_align_xresalloc_multi_to(*this, handle, alignment,
                                                  new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_resalloc_multi_to(auto& allocator,
                                                 mem auto& handle,
                                                 idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_unalign_salloc_multi<T>,
            true, true>(allocator, handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_resalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_unalign_resalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_xresalloc_multi_to(auto& allocator,
                                                  mem auto& handle,
                                                  idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_unalign_xsalloc_multi<T>,
            false, true>(allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    auto opq_unalign_xresalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_unalign_xresalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto align_resalloc_multi_to(auto& allocator, auto* p_handle,
                                           uword alignment, idx old_count,
                                           idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::align_salloc_multi<T>, true,
            true>(allocator, p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto align_resalloc_multi(auto* p_handle, uword alignment,
                                        idx old_count, idx new_count) {
        return this->align_resalloc_multi_to(*this, p_handle, alignment,
                                             old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto align_xresalloc_multi_to(auto& allocator, auto* p_handle,
                                            uword alignment, idx old_count,
                                            idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::align_xsalloc_multi<T>, false,
            true>(allocator, p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    auto align_xresalloc_multi(auto* p_handle, uword alignment, idx old_count,
                               idx new_count) {
        return this->align_xresalloc_multi_to(*this, p_handle, alignment,
                                              old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto unalign_resalloc_multi_to(auto& allocator, auto* p_handle,
                                             idx old_count, idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::unalign_salloc_multi<T>, true,
            true>(allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto unalign_resalloc_multi(auto* p_handle, idx old_count,
                                          idx new_count) {
        return this->unalign_resalloc_multi_to(*this, p_handle, old_count,
                                               new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto unalign_xresalloc_multi_to(auto& allocator, auto* p_handle,
                                              idx old_count, idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::unalign_xsalloc_multi<T>, false,
            true>(allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    auto unalign_xresalloc_multi(auto* p_handle, idx old_count, idx new_count) {
        return this->unalign_xresalloc_multi_to(*this, p_handle, old_count,
                                                new_count);
    }

    // Try to move a memory handle from this allocator into another, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_rescalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_scalloc<T, T>, true, true>(
            allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_rescalloc(mem auto& handle) {
        return this->opq_rescalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto rescalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<
            &allocator_interface<derived_type>::scalloc<T, T>, true, true>(
            allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto rescalloc(T* p_handle) {
        return this->rescalloc_to(*this, p_handle);
    }

    // Move a memory handle from this allocator into another, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_xrescalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_xscalloc<T, T>, false,
            true>(allocator, handle);
    }

    // Move a memory handle from this allocator into itself, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_xrescalloc(mem auto& handle) {
        return this->opq_xrescalloc_to(*this, handle);
    }

    // Move a pointer handle from this allocator into another, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrescalloc_to(auto& allocator, T* p_handle) {
        return this->meta_realloc<
            &allocator_interface<derived_type>::xscalloc<T, T>, false, true>(
            allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrescalloc(T* p_handle) {
        return this->xrescalloc_to(*this, p_handle);
    }

    // Try to move a memory handle from this allocator into another with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_align_rescalloc_to(auto& allocator, mem auto& handle,
                                          uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_align_scalloc<T, T>, true,
            true>(allocator, handle, alignment);
    }

    // Try to move a memory handle from this allocator into itself with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_align_rescalloc(mem auto& handle, uword alignment) {
        return this->opq_align_rescalloc_to(*this, handle, alignment);
    }

    // Move a memory handle from this allocator into another with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_align_xrescalloc_to(auto& allocator, mem auto& handle,
                                           uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_align_xscalloc<T, T>, false,
            true>(allocator, handle, alignment);
    }

    // Move a memory handle from this allocator into itself with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto opq_align_xrescalloc(mem auto& handle, uword alignment) {
        return this->opq_align_xrescalloc_to(*this, handle, alignment);
    }

    // Try to move a memory handle from this allocator into another with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_rescalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_unalign_scalloc<T, T>, true,
            true>(allocator, handle);
    }

    // Try to move a memory handle from this allocator into itself with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_rescalloc(mem auto& handle) {
        return this->opq_unalign_rescalloc_to(*this, handle);
    }

    // Move a memory handle from this allocator into another with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_xrescalloc_to(auto& allocator,
                                             mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_unalign_xscalloc<T, T>,
            false, true>(allocator, handle);
    }

    // Move a memory handle from this allocator into itself with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto opq_unalign_xrescalloc(mem auto& handle) {
        return this->opq_unalign_xrescalloc_to(*this, handle);
    }

    // Try to move a pointer handle from this allocator into another with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto align_rescalloc_to(auto& allocator, auto* p_handle,
                                      uword alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::align_scalloc<T, T>, true,
            true>(allocator, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into itself with an
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto align_rescalloc(auto* p_handle, uword alignment) {
        return this->align_rescalloc_to(*this, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into another with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]]
    constexpr auto align_xrescalloc_to(auto& allocator, auto* p_handle,
                                       uword alignment) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::align_xscalloc<T, T>, false,
            true>(allocator, p_handle, alignment);
    }

    // Move a pointer handle from this allocator into itself with an alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto align_xrescalloc(auto* p_handle, uword alignment) {
        return this->align_xrescalloc_to(*this, p_handle, alignment);
    }

    // Try to move a pointer handle from this allocator into another with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto unalign_rescalloc_to(auto& allocator, auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::unalign_scalloc<T, T>, true,
            true>(allocator, p_handle);
    }

    // Try to move a pointer handle from this allocator into itself with no
    // alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto unalign_rescalloc(auto* p_handle) {
        return this->unalign_rescalloc_to(*this, p_handle);
    }

    // Move a pointer handle from this allocator into another with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]]
    constexpr auto unalign_xrescalloc_to(auto& allocator, auto* p_handle) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::unalign_xscalloc<T, T>, false,
            true>(allocator, p_handle);
    }

    // Move a pointer handle from this allocator into itself with no alignment
    // guarantee, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    auto unalign_xrescalloc(auto* p_handle) {
        return this->unalign_xrescalloc_to(*this, p_handle);
    }

    // Move an array memory handle from this allocator into another, zero-out
    // the allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_rescalloc_multi_to(auto& allocator, mem auto& handle,
                                          idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_scalloc_multi<T>, true,
            true>(allocator, handle, new_count);
    }

    // Try to move an array memory handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto opq_rescalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_rescalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto rescalloc_multi_to(auto& allocator, T* p_handle,
                                      idx old_count, idx new_count) {
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::scalloc_multi<T>, true, true>(
            allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize array pointer handle from this allocator into
    // itself, zero-out the allocated memory, and return the number of bytes
    // that were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto rescalloc_multi(T* p_handle, idx old_count, idx new_count) {
        return this->rescalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto opq_xrescalloc_multi_to(auto& allocator, mem auto& handle,
                                           idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_xscalloc_multi<T>, false,
            true>(allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto opq_xrescalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_xrescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrescalloc_multi_to(auto& allocator, T* p_handle,
                                       idx old_count, idx new_count) {
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::xscalloc_multi<T>, false, true>(
            allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    template <typename T>
    [[nodiscard]]
    constexpr auto xrescalloc_multi(T* p_handle, idx old_count, idx new_count) {
        return this->xrescalloc_multi_to(*this, p_handle, old_count, new_count);
    }

    // Move and resize an array memory handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto opq_align_rescalloc_multi_to(auto& allocator,
                                                mem auto& handle,
                                                uword alignment,
                                                idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_align_scalloc_multi<T>,
            true, true>(allocator, handle, new_count, alignment);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_align_rescalloc_multi(mem auto& handle, uword alignment,
                                             idx new_count) {
        return this->opq_align_rescalloc_multi_to(*this, handle, alignment,
                                                  new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_align_xrescalloc_multi_to(auto& allocator,
                                                 mem auto& handle,
                                                 uword alignment,
                                                 idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_align_xscalloc_multi<T>,
            false, true>(allocator, handle, new_count, alignment);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto opq_align_xrescalloc_multi(mem auto& handle, uword alignment,
                                    idx new_count) {
        return this->opq_align_xrescalloc_multi_to(*this, handle, alignment,
                                                   new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // another with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_rescalloc_multi_to(auto& allocator,
                                                  mem auto& handle,
                                                  idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_unalign_scalloc_multi<T>,
            true, true>(allocator, handle, new_count);
    }

    // Try to move and resize an array memory handle from this allocator into
    // itself with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_rescalloc_multi(mem auto& handle,
                                               idx new_count) {
        return this->opq_unalign_rescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into another
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto opq_unalign_xrescalloc_multi_to(auto& allocator,
                                                   mem auto& handle,
                                                   idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::opq_unalign_xscalloc_multi<T>,
            false, true>(allocator, handle, new_count);
    }

    // Move and resize an array memory handle from this allocator into itself
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto opq_unalign_xrescalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_unalign_xrescalloc_multi_to(*this, handle, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto align_rescalloc_multi_to(auto& allocator, auto* p_handle,
                                            uword alignment, idx old_count,
                                            idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::align_scalloc_multi<T>, true,
            true>(allocator, p_handle, old_count, new_count, alignment);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto align_rescalloc_multi(auto* p_handle, uword alignment,
                                         idx old_count, idx new_count) {
        return this->align_rescalloc_multi_to(*this, p_handle, alignment,
                                              old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto align_xrescalloc_multi_to(auto& allocator, auto* p_handle,
                                             uword alignment, idx old_count,
                                             idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::align_xscalloc_multi<T>, false,
            true>(allocator, p_handle, old_count, new_count, alignment);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto align_xrescalloc_multi(auto* p_handle, uword alignment, idx old_count,
                                idx new_count) {
        return this->align_xrescalloc_multi_to(*this, p_handle, alignment,
                                               old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // another with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto unalign_rescalloc_multi_to(auto& allocator, auto* p_handle,
                                              idx old_count, idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::unalign_scalloc_multi<T>, true,
            true>(allocator, p_handle, old_count, new_count);
    }

    // Try to move and resize an array pointer handle from this allocator into
    // itself with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto unalign_rescalloc_multi(auto* p_handle, idx old_count,
                                           idx new_count) {
        return this->unalign_rescalloc_multi_to(*this, p_handle, old_count,
                                                new_count);
    }

    // Move and resize an array pointer handle from this allocator into another
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto unalign_xrescalloc_multi_to(auto& allocator, auto* p_handle,
                                               idx old_count, idx new_count) {
        using T = typeof(this->get(p_handle));  // `typeof` is a decaying alias.
        return this->meta_realloc_multi<
            &allocator_interface<derived_type>::unalign_xscalloc_multi<T>,
            false, true>(allocator, p_handle, old_count, new_count);
    }

    // Move and resize an array pointer handle from this allocator into itself
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    auto unalign_xrescalloc_multi(auto* p_handle, idx old_count,
                                  idx new_count) {
        return this->unalign_xrescalloc_multi_to(*this, p_handle, old_count,
                                                 new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_resalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_salloc<T, T>, true,
            true>(allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_resalloc(mem auto& handle) {
        return this->inline_resalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another, and
    // return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_xresalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_xalloc<T, T>, false,
            true>(allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself, and
    // return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_xresalloc(mem auto& handle) {
        return this->inline_xresalloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto inline_align_resalloc_to(auto& allocator, mem auto& handle,
                                            uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_align_salloc<T, T>, true,
            true>(allocator, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto inline_align_resalloc(mem auto& handle, uword alignment) {
        return this->inline_align_resalloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto inline_align_xresalloc_to(auto& allocator, mem auto& handle,
                                             uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_align_xalloc<T, T>,
            false, true>(allocator, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee, and return the number of bytes that were
    // allocated.
    auto inline_align_xresalloc(mem auto& handle, uword alignment) {
        return this->inline_align_xresalloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee, and return the number of bytes that
    // were allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_resalloc_to(auto& allocator,
                                              mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_unalign_salloc<T, T>,
            true, true>(allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_resalloc(mem auto& handle) {
        return this->inline_unalign_resalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_xresalloc_to(auto& allocator,
                                               mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_unalign_xalloc<T, T>,
            false, true>(allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee, and return the number of bytes that were
    // allocated.
    auto inline_unalign_xresalloc(mem auto& handle) {
        return this->inline_unalign_xresalloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_resalloc_multi_to(auto& allocator, mem auto& handle,
                                            idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_salloc_multi<T>, true,
            true>(allocator, handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto inline_resalloc_multi(mem auto& handle, idx new_count) {
        return this->opq_resalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto inline_xresalloc_multi_to(auto& allocator, mem auto& handle,
                                             idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_xsalloc_multi<T>, false,
            true>(allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto inline_xresalloc_multi(mem auto& handle, idx new_count) {
        return this->inline_xresalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto inline_align_resalloc_multi_to(auto& allocator,
                                                  mem auto& handle,
                                                  uword alignment,
                                                  idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_align_salloc_multi<T>,
            true, true>(allocator, handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_align_resalloc_multi(mem auto& handle,
                                               uword alignment, idx new_count) {
        return this->inline_align_resalloc_multi_to(*this, handle, alignment,
                                                    new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee, and return the number
    // of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_align_xresalloc_multi_to(auto& allocator,
                                                   mem auto& handle,
                                                   uword alignment,
                                                   idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_align_xsalloc_multi<T>,
            false, true>(allocator, handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee, and return the number
    // of bytes that were allocated.
    auto inline_align_xresalloc_multi(mem auto& handle, uword alignment,
                                      idx new_count) {
        return this->inline_align_xresalloc_multi_to(*this, handle, alignment,
                                                     new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_resalloc_multi_to(auto& allocator,
                                                    mem auto& handle,
                                                    idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_unalign_salloc_multi<T>,
            true, true>(allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_resalloc_multi(mem auto& handle,
                                                 idx new_count) {
        return this->inline_unalign_resalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee, and return the number
    // of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_xresalloc_multi_to(auto& allocator,
                                                     mem auto& handle,
                                                     idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_unalign_xsalloc_multi<T>,
            false, true>(allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee, and return the number
    // of bytes that were allocated.
    auto inline_unalign_xresalloc_multi(mem auto& handle, idx new_count) {
        return this->inline_unalign_xresalloc_multi_to(*this, handle,
                                                       new_count);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_rescalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::opq_scalloc<T, T>, true, true>(
            allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // itself, zero-out the allocated memory, and return the number of bytes
    // that were allocated.
    [[nodiscard]]
    constexpr auto inline_rescalloc(mem auto& handle) {
        return this->inline_rescalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another,
    // zero-out the allocated memory, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto inline_xrescalloc_to(auto& allocator, mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_xscalloc<T, T>, false,
            true>(allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself,
    // zero-out the allocated memory, and return the number of bytes that were
    // allocated.
    [[nodiscard]]
    constexpr auto inline_xrescalloc(mem auto& handle) {
        return this->inline_xrescalloc_to(*this, handle);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with an alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_align_rescalloc_to(auto& allocator, mem auto& handle,
                                             uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_align_scalloc<T, T>,
            true, true>(allocator, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with an alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_align_rescalloc(mem auto& handle, uword alignment) {
        return this->inline_align_rescalloc_to(*this, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into another with
    // an alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_align_xrescalloc_to(auto& allocator, mem auto& handle,
                                              uword alignment) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_align_xscalloc<T, T>,
            false, true>(allocator, handle, alignment);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // an alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    auto inline_align_xrescalloc(mem auto& handle, uword alignment) {
        return this->inline_align_xrescalloc_to(*this, handle, alignment);
    }

    // Try to move a small-size optimized handle from this allocator into
    // another with no alignment guarantee, zero-out the allocated memory,
    // and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_rescalloc_to(auto& allocator,
                                               mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_unalign_scalloc<T, T>,
            true, true>(allocator, handle);
    }

    // Try to move a small-size optimized handle from this allocator into itself
    // with no alignment guarantee, zero-out the allocated memory, and
    // return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_rescalloc(mem auto& handle) {
        return this->inline_unalign_rescalloc_to(*this, handle);
    }

    // Move a small-size optimized handle from this allocator into another with
    // no alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_xrescalloc_to(auto& allocator,
                                                mem auto& handle) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->meta_realloc<
            &allocator_interface<derived_type>::inline_unalign_xscalloc<T, T>,
            false, true>(allocator, handle);
    }

    // Move a small-size optimized handle from this allocator into itself with
    // no alignment guarantee, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    auto inline_unalign_xrescalloc(mem auto& handle) {
        return this->inline_unalign_xrescalloc_to(*this, handle);
    }

    // Move a small-size optimized array memory handle from this allocator into
    // another, zero-out the allocated memory, and return the number of
    // bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_rescalloc_multi_to(auto& allocator, mem auto& handle,
                                             idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_scalloc_multi<T>, true,
            true>(allocator, handle, new_count);
    }

    // Try to move a small-size optimized array memory handle from this
    // allocator into itself, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_rescalloc_multi(mem auto& handle, idx new_count) {
        return this->inline_rescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_xrescalloc_multi_to(auto& allocator, mem auto& handle,
                                              idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_xscalloc_multi<T>, false,
            true>(allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_xrescalloc_multi(mem auto& handle, idx new_count) {
        return this->inline_xrescalloc_multi_to(*this, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another, zero-out the allocated memory, and return the
    // number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_align_rescalloc_multi_to(auto& allocator,
                                                   mem auto& handle,
                                                   uword alignment,
                                                   idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_align_scalloc_multi<T>,
            true, true>(allocator, handle, new_count, alignment);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with an alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_align_rescalloc_multi(mem auto& handle,
                                                uword alignment,
                                                idx new_count) {
        return this->inline_align_rescalloc_multi_to(*this, handle, alignment,
                                                     new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with an alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_align_xrescalloc_multi_to(auto& allocator,
                                                    mem auto& handle,
                                                    uword alignment,
                                                    idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_align_xscalloc_multi<T>,
            false, true>(allocator, handle, new_count, alignment);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with an alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    auto inline_align_xrescalloc_multi(mem auto& handle, uword alignment,
                                       idx new_count) {
        return this->inline_align_xrescalloc_multi_to(*this, handle, alignment,
                                                      new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into another with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_rescalloc_multi_to(auto& allocator,
                                                     mem auto& handle,
                                                     idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this->opq_meta_realloc_multi<
            &allocator_interface<derived_type>::inline_unalign_scalloc_multi<T>,
            true, true>(allocator, handle, new_count);
    }

    // Try to move and resize a small-size optimized array memory handle from
    // this allocator into itself with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_rescalloc_multi(mem auto& handle,
                                                  idx new_count) {
        return this->inline_unalign_rescalloc_multi_to(*this, handle,
                                                       new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into another with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    [[nodiscard]]
    constexpr auto inline_unalign_xrescalloc_multi_to(auto& allocator,
                                                      mem auto& handle,
                                                      idx new_count) {
        using T = typeof(this->get(handle));  // `typeof` is a decaying alias.
        return this
            ->opq_meta_realloc_multi<&allocator_interface<derived_type>::
                                         inline_unalign_xscalloc_multi<T>,
                                     false, true>(allocator, handle, new_count);
    }

    // Move and resize a small-size optimized array memory handle from this
    // allocator into itself with no alignment guarantee, zero-out the
    // allocated memory, and return the number of bytes that were allocated.
    auto inline_unalign_xrescalloc_multi(mem auto& handle, idx new_count) {
        return this->inline_unalign_xrescalloc_multi_to(*this, handle,
                                                        new_count);
    }

    // Invalidate any memory handle, invoking its data's destructor.
    template <mem T>
    void free(T const& handle) {
        using allocation_type = T::allocation_type const;

        // If this is not a small-size optimized handle:
        if (!handle.is_inline()) {
            allocation_type const* p_memory;
            if constexpr (T::is_multi_handle) {
                // Get the pointer from a span produced by the
                // allocator.
                p_memory = this->get(handle).data();
            } else {
                // Get the pointer from the allocator.
                p_memory = addressof(this->get(handle));
            }

// Poison memory region.
#ifdef __SANITIZE_ADDRESS__
            //         if !consteval {
            __asan_poison_memory_region(
                static_cast<void const volatile*>(p_memory),
                sizeof(allocation_type));
//         }
#endif

            // if constexpr (is_destructible<allocation_type>) {
            for (uword i = 0u; i < handle.size(); ++i) {
                p_memory[i.raw].~allocation_type();
            }
            // }
            this->self().deallocate(static_cast<void const*>(p_memory),
                                    handle.raw_size());
        }
        // If this is not small-size optimized, it will be freed at the
        // end of the stack frame, so this function call is no-op.
    };

    // TODO: This needs unit tests.
    // Invalidate a pointer handle to a `T`, and call its destructor.
    template <typename T>
    constexpr void free(T* p_memory) {
        // Poison memory region.
#ifdef __SANITIZE_ADDRESS__
        if !consteval {
            __asan_poison_memory_region(
                static_cast<void const volatile*>(p_memory), sizeof(T));
        }
#endif

        if constexpr (detail::has_max_allocation_bytes<derived_type>) {
            static_assert(sizeof(T) <= derived_type::max_allocation_bytes,
                          "This allocation is too large for this allocator!");
        }

        if consteval {
            delete p_memory;
        } else {
            // if constexpr (is_destructible<T>) {
            p_memory->~T();
            // }
            this->self().deallocate(static_cast<void const*>(p_memory),
                                    sizeof(T));
        }
    }

    // Invalidate a pointer handle to an array of `T`, and call its
    // destructors.
    template <typename T>
    constexpr void free_multi(T* p_memory, idx count) {
        if constexpr (detail::has_max_allocation_bytes<derived_type>) {
            static_assert(sizeof(T) <= derived_type::max_allocation_bytes,
                          "This allocation is too large for this allocator!");
            assert((count * sizeof(T)) <= derived_type::max_allocation_bytes,
                   "This allocation is too large for this allocator!");
        }

        // Poison memory region.
#ifdef __SANITIZE_ADDRESS__
        if !consteval {
            __asan_poison_memory_region(
                static_cast<void const volatile*>(p_memory),
                sizeof(T) * make_unsigned(count));
        }
#endif

        if consteval {
            // if (count > 0) {
            delete[] p_memory;
            // }
        } else {
            // if constexpr (is_destructible<T>) {
            for (uword i = 0u; i < count; ++i) {
                p_memory[i.raw].~T();
            }
            // }
            this->self().deallocate(static_cast<void const*>(p_memory),
                                    count * sizeof(T));
        }
    }

    template <mem T>
    constexpr void cfree(T& handle) {
        free(handle);
        zero_memory_explicit(addressof(this->get(handle)), handle.raw_size());
    }

    template <typename T>
    constexpr void cfree(T* p_handle) {
        free(p_handle);
        zero_memory_explicit(p_handle, sizeof(T));
    }

    template <typename T>
    constexpr void cfree_multi(T* p_handle, idx count) {
        free_multi(p_handle, count);
        zero_memory_explicit(p_handle, count * sizeof(T));
    }

    template <typename T>
    constexpr void free(span<T> handle) {
        free_multi(handle.data(), handle.size());
    }

    template <typename T>
    constexpr void cfree(span<T> handle) {
        cfree_multi(handle.data(), handle.size());
    }

    // Get a non-`const` handle to the data in any memory handle. If that
    // memory handle is to a multi-allocation, this returns a `span`.
    template <mem T>
    [[nodiscard]]
    constexpr auto get(T& handle) & -> decltype(auto) {
        using allocation_type = T::allocation_type;
        if constexpr (T::is_inline_handle) {
            // Get small-size optimized data:
            if (handle.is_inline()) {
                if constexpr (T::is_multi_handle) {
                    return span<allocation_type>{addressof(handle.get_inline()),
                                                 handle.size()};
                } else {
                    return handle.get_inline();
                }
            }
        }

        // Get non-small-size optimized data:
        if constexpr (T::is_multi_handle) {
            return span<allocation_type>(
                this->self().template access<allocation_type>(handle.get()),
                handle.size());
        } else {
            return *(
                this->self().template access<allocation_type>(handle.get()));
        }
    }

    // Get a `const` handle to the data in any memory handle. If that memory
    // handle is to a multi-allocation, this returns a `span`.
    template <mem T>
    [[nodiscard]]
    constexpr auto get(T const& memory) & -> decltype(auto) {
        return unconst(this)->get(unconst(memory));
    }

    // Get a non-`const` reference to the data in any pointer handle.
    template <typename T>
    [[nodiscard]]
    constexpr auto get(T* p_handle) & -> T& {
        return *p_handle;
    }

    // Get a `const` reference to the data in any pointer handle.
    template <typename T>
    [[nodiscard]]
    constexpr auto get(T const* p_handle) & -> T& {
        return *p_handle;
    }

    // Get a pointer to an allocated non-`const` `mem`.
    template <mem T>
        requires(derived_type::has_pointer_stability)
    [[nodiscard]]
    constexpr auto p_get(T& memory) -> auto {
        decltype(auto) ref = this->get(memory);
        using handle_type = decltype(this->get(memory));
        if constexpr (is_reference<handle_type>) {
            return addressof(ref);
        } else {
            return ref.data();
        }
    }

    // Get a `const` pointer to an allocated `mem`.
    template <mem T>
        requires(derived_type::has_pointer_stability)
    [[nodiscard]]
    constexpr auto p_get(T const& memory) -> auto {
        decltype(auto) ref = this->get(memory);
        using handle_type = decltype(this->get(memory));
        if constexpr (is_reference<handle_type>) {
            return addressof(ref);
        } else {
            return ref.data();
        }
    }

    // If the allocator does not over-ride a `.reset()` method, produce a
    // no-op.
    constexpr void reset() {
    }

  private:
    constexpr auto self() -> derived_type& {
        return static_cast<derived_type&>(*this);
    }

    template <typename T, bool is_inline, bool is_fail_safe, bool is_aligned,
              bool is_multiple, bool is_stable, bool is_zeroed,
              bool has_feedback, typename... Args>
        requires(
            // Inline allocations cannot produce pointers.
            !(is_inline && is_stable)
            // Multi-allocations must be default-constructed.
            && (!is_multiple || (sizeof...(Args) <= 0))
            // TODO: Zeroed-out allocations should not have arguments.
            // Zeroed-out allocations must be trivial.
            && (!is_zeroed || is_trivial<T>))
    [[gnu::optimize(R"(-fno-tree-loop-distribute-patterns)"),
      gnu::no_sanitize_address]]
    constexpr auto meta_alloc(uword allocation_alignment, idx allocation_count,
                              Args&&... constructor_args) {
        if constexpr (detail::has_max_allocation_bytes<derived_type>) {
            static_assert(sizeof(T) <= derived_type::max_allocation_bytes,
                          "This allocation is too large for this allocator!");
            assert((allocation_count * sizeof(T)) <=
                       derived_type::max_allocation_bytes,
                   "This allocation is too larger for this allocator!");
        }

        idx const allocation_bytes = idx(allocation_count * sizeof(T));

        // Produce a basic handle for this memory type.

        using underlying_handle =
            decltype(this->self().template make_handle<T>(declval<T*>()));

        // Get the return value of a user-supplied `.allocate()`. This must
        // be some kind of `maybe`. It holds some data that can pass into a
        // `handle_type`'s constructor.
        using maybe_allocation =
            conditional<has_feedback, maybe_sized_allocation<void*>,
                        maybe_ptr<void>>;

        // Produce an appropriate handle type for this allocation.
        using handle_type = conditional<
            is_multiple,
            detail::multi_memory_handle<conditional<
                is_inline,
                // If this an array of small-size optimized `T`:
                detail::inline_memory_handle<underlying_handle>,
                // If this is an array of not small-size optimized `T`:
                underlying_handle>>,
            conditional<is_inline,
                        // If this a small-size optimized `T`:
                        detail::inline_memory_handle<underlying_handle>,
                        // If this is not a small-size optimized `T`:
                        underlying_handle>>;

        using return_handle = conditional<
            is_fail_safe,
            conditional<is_stable,
                        conditional<has_feedback,
                                    conditional<is_multiple,
                                                // tuple of a span with size
                                                // feedback.
                                                maybe<tuple<span<T>, idx>>,
                                                // Failsafe pointer with size.
                                                maybe_sized_allocation<T*>>,

                                    conditional<is_multiple,
                                                // TODO: Use a
                                                // `maybe_span<T>`. span.
                                                maybe<span<T>>,
                                                // Failsafe pointer w/out
                                                // size.
                                                maybe_ptr<T>>>,

                        // Not a pointer:
                        conditional<has_feedback,
                                    // Failsafe opaque handle with size.
                                    maybe_sized_allocation<handle_type>,
                                    // Failsafe opaque handle w/out size.
                                    maybe<handle_type>>>,

            // Not fail-safe:
            conditional<is_stable,
                        conditional<has_feedback,
                                    conditional<is_multiple,
                                                // Unsafe tuple of a span
                                                // with size.
                                                tuple<span<T>, idx>,
                                                // Unsafe pointer with size.
                                                sized_allocation<T*>>,

                                    conditional<is_multiple,
                                                // Unsafe span.
                                                span<T>,
                                                // Unsafe pointer w/out
                                                // size.
                                                T*>>,

                        conditional<has_feedback,
                                    // Unsafe opaque handle with size.
                                    sized_allocation<handle_type>,
                                    // Unsafe opaque memory handle w/out
                                    // size.
                                    handle_type>>>;

        // In `constexpr` code, unconditionally make an allocation.
        if consteval {
            if constexpr (is_stable) {
                T* p_allocation = nullptr;

                // Construct one or multiple `T`s.
                if constexpr (is_multiple) {
                    p_allocation =
                        new (std::align_val_t(allocation_alignment.raw))
                            T[allocation_count.raw];
                } else {
                    p_allocation =
                        new (std::align_val_t(allocation_alignment.raw))
                            T(constructor_args...);
                }

                // Data must be default-constructed in `constexpr` code.
                for (unsigned long i = 0u; i < allocation_count; ++i) {
                    construct_at(p_allocation + i);
                }

                if constexpr (has_feedback) {
                    if constexpr (is_multiple) {
                        return return_handle(
                            tuple{span<T>(p_allocation, allocation_count),
                                  allocation_count * sizeof(T)});
                    } else {
                        return return_handle(sized_allocation<T*>{
                            p_allocation, allocation_count * sizeof(T)});
                    }
                } else {
                    // No size feedback.
                    if constexpr (is_multiple) {
                        return return_handle(
                            span<T>(p_allocation, allocation_count));
                    } else {
                        return return_handle(p_allocation);
                    }
                }
            } else {
                // TODO: Opaque constexpr allocations.
                __builtin_unreachable();
            }
        } else {
            // Non-constexpr code.
            if constexpr (is_inline) {
                if (allocation_bytes < inline_buffer_size) {
                    // Allocate memory on this stack frame.
                    handle_type stack_handle;
                    stack_handle.set_inlined(true);
                    stack_handle.set_count(allocation_count);

                    if constexpr (is_zeroed) {
                        zero_memory(addressof(stack_handle),
                                    inline_buffer_size);
                    }

                    if constexpr (is_multiple) {
                        for (unsigned long i = 0u; i < allocation_count; ++i) {
                            construct_at(static_cast<T*>(static_cast<void*>(
                                             &stack_handle)) +
                                         i);
                        }
                    } else {
                        stack_handle.set_inline_storage(
                            T(forward<Args>(constructor_args)...));
                    }

                    // Return here to skip error handling, because an
                    // on-stack allocation cannot fail.
                    if constexpr (has_feedback) {
                        return return_handle(sized_allocation<handle_type>{
                            move(stack_handle), inline_buffer_size});
                    } else {
                        return return_handle(move(stack_handle));
                    }
                }
            }

            // If this allocation is not small-size optimized, or is larger
            // than `inline_buffer_size`:

            // Make an allocation.
            maybe_allocation maybe_memory;

            if constexpr (is_aligned) {
                if constexpr (has_feedback) {
                    if constexpr (detail::has_aligned_allocate_feedback<
                                      derived_type>) {
                        // Call `.aligned_allocate_feedback()` function for
                        // optimized size-feedback.
                        maybe_memory = this->self().aligned_allocate_feedback(
                            allocation_alignment, allocation_bytes);
                    } else {
                        if constexpr (detail::has_allocation_bytes<
                                          derived_type>) {
                            // If a `.aligned_allocate_feedback()` is not
                            // provided, use `.allocation_bytes()`.
                            maybe actual_allocation_bytes =
                                this->self().allocation_bytes(
                                    allocation_alignment, allocation_bytes);

                            if (actual_allocation_bytes.has_value()) {
                                void* p_allocation =
                                    this->self()
                                        .aligned_allocate(
                                            allocation_alignment,
                                            actual_allocation_bytes.value())
                                        // If `.allocation_bytes()` succeeded,
                                        // this will not fail.
                                        .value();

                                maybe_memory = maybe_sized_allocation<void*>{
                                    sized_allocation<void*>{
                                                            p_allocation, actual_allocation_bytes.value()}
                                };
                            } else {
                                maybe_memory = nullopt;
                            }
                        } else {
                            // If a `.allocation_bytes()` is not provided,
                            // simply assume that it allocates
                            // `allocation_bytes`.
                            maybe temp_memory = this->self().aligned_allocate(
                                allocation_alignment, allocation_bytes);
                            if (temp_memory.has_value()) {
                                maybe_memory = maybe_sized_allocation<void*>{
                                    sized_allocation<void*>{temp_memory.value(),
                                                            allocation_bytes}
                                };
                            } else {
                                maybe_memory = nullopt;
                            }
                        };
                    }
                } else {
                    if constexpr (detail::has_aligned_allocate<derived_type>) {
                        maybe_memory = this->self().aligned_allocate(
                            allocation_alignment, allocation_bytes);
                    } else {
                        // If a `.aligned_allocate()` is not provided, ensure
                        // alignment with a runtime check.
                        maybe_memory = this->self().allocate(allocation_bytes);
                        if (maybe_memory.has_value()) {
                            assert(cat::is_aligned(maybe_memory.value(),
                                                   allocation_alignment),
                                   "allocation_type is misaligned!");
                        }
                    }
                }
            } else {
                if constexpr (has_feedback) {
                    if constexpr (detail::has_allocate_feedback<derived_type>) {
                        // Call `.allocate_feedback()` function for
                        // optimized size-feedback.
                        maybe_memory =
                            this->self().allocate_feedback(allocation_bytes);
                    } else {
                        if constexpr (detail::has_aligned_allocate_feedback<
                                          derived_type>) {
                            // If `.allocate_feedback()` is not provided,
                            // but `.aligned_allocate_feedback()` is, fall back
                            // to that with alignment of `1u`.
                            maybe_memory =
                                this->self().aligned_allocate_feedback(
                                    1u, allocation_bytes);
                        } else if constexpr (detail::has_allocation_bytes<
                                                 derived_type>) {
                            // If a `.aligned_allocate_feedback()` is not
                            // provided, use `.allocation_bytes`().
                            maybe size = this->self().allocation_bytes(
                                1u, allocation_bytes);

                            if (size.has_value()) {
                                maybe_memory = maybe_sized_allocation<void*>{
                                    // If `.allocation_bytes()` succeeded, this
                                    // will not fail.
                                    this->self()
                                        .allocate(allocation_bytes)
                                        .value(),
                                    size.value()};
                            } else {
                                maybe_memory = nullopt;
                            }
                        } else {
                            // If a `.allocation_bytes()` is also not
                            // provided, simply assume that it allocates
                            // `allocation_bytes`.
                            auto temp_memory = this->self().aligned_allocate(
                                allocation_alignment, allocation_bytes);
                            if (temp_memory.has_value()) {
                                maybe_memory = maybe_sized_allocation<void*>{
                                    sized_allocation<void*>{temp_memory.value(),
                                                            allocation_bytes}
                                };
                            } else {
                                maybe_memory = nullopt;
                            }
                        };
                    }
                } else {
                    // Otherwise, make an allocation without size feedback.
                    if constexpr (detail::has_allocate<derived_type>) {
                        maybe_memory = this->self().allocate(allocation_bytes);
                    } else {
                        // If `.allocate` is not provided, implement it in
                        // terms of
                        // `.aligned_allocate()`.
                        maybe_memory =
                            this->self().aligned_allocate(1u, allocation_bytes);
                    }
                }
            }

            // Short circuit failed allocations.
            if constexpr (is_fail_safe) {
                if (!maybe_memory.has_value()) {
                    // Return an empty maybe if this failed to allocate.
                    return return_handle(nullopt);
                }
            }

            T* p_allocation;
            if constexpr (has_feedback) {
                // The `.first()` element of the `sized_allocation` tuple is
                // a `void*`.
                p_allocation = static_cast<T*>(maybe_memory.value().first());
            } else {
                p_allocation = static_cast<T*>(maybe_memory.value());
            }

            // Permit addressing this memory.
#ifdef __SANITIZE_ADDRESS__
            __asan_unpoison_memory_region(
                static_cast<void const volatile*>(p_allocation),
                make_unsigned(allocation_bytes));
#endif

            // Possibly zero-out the allocation.
            if constexpr (is_zeroed) {
                zero_memory(p_allocation, allocation_bytes);
            }

            // Construct the `T`s inside the allocator.
            for (unsigned long i = 0u; i < allocation_count; ++i) {
                construct_at(p_allocation + i,
                             forward<Args>(constructor_args)...);
            }

            // If this allocation has size feedback, store it.
            idx size_feedback;
            if constexpr (has_feedback) {
                size_feedback = maybe_memory.value().second();
            }

            if constexpr (is_stable) {
                if constexpr (has_feedback) {
                    if constexpr (is_multiple) {
                        return return_handle(
                            tuple{span<T>(p_allocation, allocation_count),
                                  size_feedback});
                    } else {
                        return return_handle(
                            sized_allocation<T*>{p_allocation, size_feedback});
                    }
                } else {
                    // No size feedback.
                    if constexpr (is_multiple) {
                        return return_handle(
                            span<T>{p_allocation, allocation_count});
                    } else {
                        return return_handle(p_allocation);
                    }
                }
            } else {
                underlying_handle const raw_handle =
                    this->self().template make_handle<T>(p_allocation);
                handle_type handle(move(raw_handle));

                if constexpr (is_inline) {
                    handle.set_inlined(false);
                }

                if constexpr (is_multiple) {
                    handle.set_count(allocation_count);
                }

                if constexpr (has_feedback) {
                    return return_handle(sized_allocation<handle_type>{
                        move(handle), size_feedback});
                } else {
                    return return_handle(move(handle));
                }
            }
        }
    }

    // Take a generic allocation method, invoke it on an allocator with a
    // generic memory handle, and free the original handle if that
    // allocation suceeded.
    template <auto alloc_function, bool is_fail_safe, bool has_feedback,
              typename... Args>
    constexpr auto meta_realloc(auto& allocator, auto& old_handle,
                                Args&&... arguments) {
        auto allocation = (allocator.*alloc_function)(
            // Possible alignment and/or count arguments.
            forward<Args>(arguments)...,
            // Move the data from this handle.
            move(this->get(old_handle)));

        if constexpr (is_fail_safe) {
            if (!allocation.has_value()) {
                return allocation;
            }
        }

        this->free(old_handle);
        return allocation;
    }

    // Copy data from `handle` into `allocation`.
    constexpr void relocate_opq_handle(mem auto& handle, auto allocation) {
        if constexpr (is_trivially_relocatable<int>) {
            copy_memory(addressof(this->get(handle)), addressof(allocation),
                        handle.raw_size());
        } else {
            for (idx i = 0u; i < handle.size(); ++i) {
                *(addressof(this->get(allocation)) + i) =
                    move(*(addressof(this->get(handle)) + i));
            }
        }
    }

    // Copy data from `p_old_handle` into `p_new_handle`.
    template <typename T>
    constexpr void relocate_ptr_handle(T* p_old_handle, T* p_new_handle,
                                       idx old_count) {
        // TODO: Use a `relocate()` function to streamline this.
        if !consteval {
            assert(p_new_handle != nullptr);
            if constexpr (is_trivially_relocatable<T>) {
                copy_memory(p_old_handle, p_new_handle, old_count);
            }
            return;
        }
        for (idx i = 0u; i < old_count; ++i) {
            *(p_new_handle + i) = move(*(p_old_handle + i));
        }
    }

    // Copy data from `p_old_handle` into `allocation`.
    // This `span` overload exists to simplify calling this with the output of
    // both `_multi` and non-`_multi` functions.
    template <typename T>
    constexpr void relocate_ptr_handle(auto* p_old_handle, span<T> new_handle,
                                       idx old_count) {
        // TODO: Use a `relocate()` function to streamline this.
        if !consteval {
            assert(new_handle.data() != nullptr);

#ifdef __SANITIZE_ADDRESS__
            // TODO: Why does this fix asan error in vector test?
            __asan_unpoison_memory_region(
                static_cast<void const volatile*>(p_old_handle),
                make_unsigned(old_count) + sizeof(T) + 8u);
#endif

            if constexpr (is_trivially_relocatable<T>) {
                copy_memory(p_old_handle, new_handle.data(), old_count);
            }
            return;
        }
        for (idx i = 0u; i < old_count; ++i) {
            new_handle[i] = move(*(p_old_handle + i.raw));
        }
    }

    // Reallocate opaque memory handles.
    template <auto alloc_function, bool is_fail_safe, bool has_feedback,
              typename... Args>
        requires(sizeof...(Args) <= 1)
    constexpr auto opq_meta_realloc_multi(auto& allocator, mem auto& old_handle,
                                          idx new_count,
                                          Args&&... maybe_alignment) {
        // `maybe_alignment` expands into zero or one arguments.
        auto new_handle = (allocator.*alloc_function)(
            forward<Args>(maybe_alignment)..., new_count);

        if constexpr (is_fail_safe) {
            if (!new_handle.has_value()) {
                return new_handle;
            }

            if constexpr (has_feedback) {
                this->relocate_opq_handle(old_handle,
                                          new_handle.value().first());
            } else {
                this->relocate_opq_handle(old_handle, new_handle.value());
            }
        } else {
            if constexpr (has_feedback) {
                this->relocate_opq_handle(old_handle, new_handle.first());
            } else {
                this->relocate_opq_handle(old_handle, new_handle);
            }
        }

        // This can be an opaque handle.
        this->free(old_handle);
        return new_handle;
    }

    // Reallocate pointer memory handles.
    template <auto alloc_function, bool is_fail_safe, bool has_feedback,
              typename... Args>
        requires(sizeof...(Args) <= 1)
    constexpr auto meta_realloc_multi(auto& allocator, auto* p_old_handle,
                                      idx old_count, idx new_count,
                                      Args&&... maybe_alignment) {
        // `maybe_alignment` expands into zero or one arguments.
        auto new_handle = (allocator.*alloc_function)(
            forward<Args>(maybe_alignment)..., new_count);

        if constexpr (is_fail_safe) {
            if (!new_handle.has_value()) {
                return new_handle;
            }

            if constexpr (has_feedback) {
                this->relocate_ptr_handle(
                    p_old_handle, new_handle.value().first(), old_count);
            } else {
                this->relocate_ptr_handle(p_old_handle, new_handle.value(),
                                          old_count);
            }
        } else {
            if constexpr (has_feedback) {
                this->relocate_ptr_handle(p_old_handle, new_handle.first(),
                                          old_count);
            } else {
                this->relocate_ptr_handle(p_old_handle, new_handle, old_count);
            }
        }

        this->free_multi(p_old_handle, old_count);
        return new_handle;
    }
};

}  // namespace cat
