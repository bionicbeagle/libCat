// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

// Iterator adaptors need access to `protected` copy-constructors, which are
// marked `[[deprecated]]`.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#include <cat/maybe>

namespace cat {
namespace detail {
    template <typename T>
    concept has_increment = requires(T it) { it.increment(); };

    template <typename T>
    concept has_decrement = requires(T it) { it.decrement(); };

    template <typename T>
    concept has_distance_to = requires(T it) { it.distance_to(it); };

    template <typename T>
    concept has_equal_to = requires(T it) {
                               { it.equal_to(it) } -> is_convertible<bool>;
                           };

    template <typename>
    struct infer_difference_trait {
        using type = iword;
    };

    // TODO: Get this working:
    // Case when `T` provides `.distance_to()`
    /*
template <detail::has_distance_to T>
struct infer_difference_trait<T> {
    static T const& it;
    using type = decltype(it.distance_to(it));
};
    */

    template <typename T>
    concept has_advance = requires(
        T it, infer_difference_trait<T>::type offset) { it.advance(offset); };

    template <typename T>
    concept has_advance_to = requires(T it) { it.advance_to(T()); };

    template <typename T>
    concept has_random_access = has_advance<T> && has_distance_to<T>;

    template <typename T>
    concept has_bidirectional = has_random_access<T> || has_decrement<T>;

    template <typename T>
    concept has_single_pass = bool(T::SinglePassiterator_type);

    template <typename Iter, typename T>
    concept has_sentinel = is_same<T, typename T::sentinel>;

    template <typename Argument, typename iterator_type>
    concept is_difference_type =
        is_convertible<Argument,
                       typename infer_difference_trait<iterator_type>::type>;
}  // namespace detail

template <typename T>
using infer_difference_type = detail::infer_difference_trait<T>::type;

template <typename...>
class iterator_interface;

// Generate iterator operators automatically.
// TODO: Document this more thoroughly.
// Every `iterator_interface` satisfies 'is_indirectly_writable'.
template <typename derived_type>
class iterator_interface<derived_type> {
  public:
    // `type` is needed for reversing this iterator.
    // TODO: Add more type members.
    using type = derived_type;
    using difference_type = infer_difference_type<derived_type>;

    // TODO: Does this work with the reverse iterator adapter?
    // If `derived_type` does not have `.advance_to()`, generate it.
    constexpr auto advance_to(derived_type const& other_iterator)
        -> derived_type const&
    // requires(!detail::has_advance_to<derived_type>)
    {
        if (other_iterator > this->self()) {
            while (other_iterator > this->self()) {
                ++(*this);
            }
        } else if (other_iterator < (this->self())) {
            while (other_iterator < this->self()) {
                --(*this);
            }
        }
        return this->self();
    }

    constexpr auto operator*() -> decltype(auto) {
        return this->self().dereference();
    }

    constexpr auto operator*() const -> decltype(auto) {
        return this->self().dereference();
    }

    constexpr auto operator->() const {
        decltype(auto) reference = **this;
        if constexpr (is_reference<decltype(reference)>) {
            // If `reference` is actually a reference type, return its
            // address.
            return addressof(reference);
        } else {
            return arrow_proxy(move(reference));
        }
    }

    constexpr friend auto operator<=>(
        derived_type const& left,
        derived_type const&
            right) /* requires(detail::has_distance_to<derived_type>) */ {
        return (left - right) <=> 0;
    }

    constexpr friend auto operator==(derived_type const& left,
                                     derived_type const& right)
        -> bool /* requires(detail::has_equal_to<derived_type> ||
                                   detail::has_distance_to<derived_type>) */
    {
        if constexpr (detail::has_equal_to<derived_type>) {
            return left.equal_to(right);
        } else if constexpr (detail::has_distance_to<derived_type>) {
            return left.distance_to(right) == 0;
        }
        __builtin_unreachable();
    }

    constexpr friend auto operator!=(derived_type const& left,
                                     derived_type const& right) -> bool {
        return !(left == right);
    }

    // constexpr friend auto operator==(derived_type const& self,
    //                                  detail::has_sentinel<derived_type> auto)
    //     -> bool {
    //     return self.at_end();
    // }

    constexpr friend auto operator+(
        derived_type const& left,
        detail::is_difference_type<derived_type> auto offset) -> derived_type {
        derived_type new_iterator = left;
        if constexpr (detail::has_advance<derived_type>) {
            new_iterator.advance(offset);
        } else {
            for (iword i = 0; i < offset; ++i) {
                ++new_iterator;
            }
        }
        return new_iterator;
    }

    constexpr friend auto operator+=(
        derived_type& left,
        detail::is_difference_type<derived_type> auto offset) -> derived_type& {
        if constexpr (detail::has_advance<derived_type>) {
            left.advance(static_cast<int>(offset));
        } else {
            for (iword i = 0; i < offset; ++i) {
                left.increment();
            }
        }
        return left;
    }

    // Increment or advance forwards with prefix notation.
    constexpr auto operator++() -> derived_type& {
        if constexpr (detail::has_increment<derived_type>) {
            this->self().increment();
        } else {
            this->self().advance(1);
        }
        return this->self();
    }

    // Increment or advance forwards with postfix notation.
    constexpr auto operator++(int) -> derived_type {
        auto copy = this->self();
        ++(*this);
        return copy;
    }

    constexpr friend auto operator-(
        derived_type const& left,
        detail::is_difference_type<derived_type> auto offset) -> derived_type {
        derived_type new_iterator = left;
        if constexpr (detail::has_advance<derived_type>) {
            return new_iterator - offset;
        } else {
            for (iword i = 0; i < offset; ++i) {
                --new_iterator;
            }
        }
        return new_iterator;
    }

    constexpr friend auto operator-=(
        derived_type& left,
        detail::is_difference_type<derived_type> auto offset) -> derived_type& {
        if constexpr (detail::has_advance<derived_type>) {
            left.advance(-offset);
        } else {
            for (iword i = 0; i < offset; ++i) {
                --left;
            }
        }
        return left;
    }

    // Get the distance between two iterators.
    constexpr friend auto operator-(derived_type const& left,
                                    derived_type const& right) -> iword
    /* requires(detail::has_distance_to<derived_type>) */ {
        return right.distance_to(left);
    }

    // Decrement or advance backwards with prefix notation.
    constexpr auto operator--() -> derived_type& {
        if constexpr (detail::has_decrement<derived_type>) {
            this->self().decrement();
        } else {
            this->self().advance(-1);
        }
        return this->self();
    }

    // Decrement or advance backwards with postfix notation.
    constexpr auto operator--(int) -> derived_type& {
        auto copy = this->self();
        --(*this);
        return copy;
    }

    // TODO: This seems incorrect.
    // Random-access.
    constexpr auto operator[](
        detail::is_difference_type<derived_type> auto offset) -> decltype(auto)
        requires(detail::has_advance<derived_type>)
    {
        return *(this->self() + offset);
    }

  private:
    constexpr auto self() -> derived_type& {
        return static_cast<derived_type&>(*this);
    }

    constexpr auto self() const -> derived_type const& {
        return static_cast<derived_type const&>(*this);
    }
};

// If an element type is provided, then the `iterator_interface` can provide
// type aliases automatically.
template <typename derived_type, typename T>
class iterator_interface<derived_type, T>
    : public iterator_interface<derived_type> {
  public:
    using value_type = T;
    using reference = T&;
    // TODO: Add more members.
};

struct random_access_iterator_tag {};

struct bidirectional_iterator_tag {};

struct forward_iterator_tag {};

struct input_iterator_tag {};

struct output_iterator_tag {};

struct contiguous_iterator_tag {};

template <typename T>
    requires(is_base_of<iterator_interface<T>, T>)
struct iterator_traits {
    static T const& iterator;
    using value = remove_reference<decltype(*iterator)>;
    using reference = decltype(*iterator);
    using pointer = decltype(iterator.operator->());
    using difference = infer_difference_type<T>;
    using category = conditional<
        // If this can be a random access iterator, it always will be.
        detail::has_random_access<T>, random_access_iterator_tag,
        conditional<
            // If this has a `++` and a `--` operator, this is a
            // bidirectional iterator.
            detail::has_bidirectional<T>, bidirectional_iterator_tag,
            conditional<detail::has_single_pass<T>,
                        // If it is single-pass, this is a forward
                        // iterator.
                        input_iterator_tag,
                        // Default to a forward iterator.
                        forward_iterator_tag>>>;
    // using iterator_type_concept = category;
};

// `element_type` may or may not be provided to this CRTP class.
template <typename iterator_type, typename... element_type>
    requires(sizeof...(element_type) <= 1)
class reverse_iterator_adaptor
    : public iterator_interface<
          reverse_iterator_adaptor<iterator_type, element_type...>,
          element_type...> {
  private:
    using self_type = reverse_iterator_adaptor<iterator_type, element_type...>;

  public:
    // Forward any constructor to the `internal_iterator`.
    template <typename... Args>
    constexpr reverse_iterator_adaptor(Args&&... args)
        : internal_iterator(forward<Args>(args)...) {
    }

    constexpr auto dereference() {
        return this->internal_iterator.dereference();
    }

    constexpr auto dereference() const {
        return this->internal_iterator.dereference();
    }

    constexpr void advance(int offset)
        requires(detail::has_advance<iterator_type>)
    {
        this->internal_iterator.advance(-offset);
    }

    constexpr void increment() {
        --internal_iterator;
    }

    constexpr void decrement() {
        ++internal_iterator;
    }

    constexpr auto distance_to(self_type other) const -> iword {
        // Reverse the polarity of `distance_to()`.
        return -this->internal_iterator.distance_to(other.internal_iterator);
    }

  private:
    iterator_type internal_iterator;
};

// TODO: More iterable related `concept`s.
template <typename T>
concept is_iterable = requires(T it) {
                          it.begin();
                          it.end();
                      };

template <typename T>
concept is_bidi_iterable = requires(T it) {
                               it.begin();
                               it.end();
                               it.rbegin();
                               it.rend();
                           };

template <typename T>
concept is_weakly_incrementable = requires(T it) {
                                      // TODO: Make this `is_movable`.
                                      { ++it } -> is_same<T&>;
                                      it++;
                                  };

template <typename T>
concept is_incrementable = requires(T it) {
                               // TODO: Make this `is_regular` and `is_movable`.
                               { ++it } -> is_same<T&>;
                               { it++ } -> is_same<T&>;
                           };

template <typename T>
concept is_random_access_iterator =
    is_same<typename iterator_traits<T>::category, random_access_iterator_tag>;

template <typename T>
concept is_bidirectional_iterator =
    is_same<typename iterator_traits<T>::category, bidirectional_iterator_tag>;

template <typename T>
concept is_forward_iterator =
    is_same<typename iterator_traits<T>::category, forward_iterator_tag>;

// clang-format off
template <typename T>
concept is_input_or_output_iterator = requires(T it) {
    *it;
} && is_weakly_incrementable<T>;
// clang-format on

template <typename T>
using iterator_reference = decltype(*declval<T&>());

template <typename outputter_type, typename T>
concept is_indirectly_writable =
    requires(outputter_type&& output_iterator, T&& value) {
        *output_iterator = forward<T>(value);
        *forward<outputter_type>(output_iterator) = forward<T>(value);
        const_cast<iterator_reference<outputter_type> const&&>(
            *output_iterator) = forward<T>(value);
        const_cast<iterator_reference<outputter_type> const&&>(
            *forward<outputter_type>(output_iterator)) = forward<T>(value);
    };

template <typename output_iterator, typename T>
concept is_output_iterator =
    is_input_or_output_iterator<output_iterator> &&
    is_indirectly_writable<output_iterator, T> &&
    requires(output_iterator it, T&& value) { *it++ = forward<T>(value); };

// With a similar syntax to `as_const()`, this adaptor take an iterable
// container and inverts its iterator's forwards and backwards movement.
template <is_bidi_iterable T>
struct as_reverse : T {
    constexpr as_reverse(T const& base) : T(base) {
    }

    constexpr as_reverse(T&& base) : T(move(base)) {
    }

    constexpr auto begin() {
        return static_cast<T*>(this)->rbegin();
    }

    constexpr auto end() {
        return static_cast<T*>(this)->rend();
    }

    constexpr auto begin() const {
        return static_cast<T*>(this)->rbegin();
    }

    constexpr auto end() const {
        return static_cast<T*>(this)->rend();
    }

    constexpr auto cbegin() const {
        return static_cast<T*>(this)->crbegin();
    }

    constexpr auto cend() const {
        return static_cast<T*>(this)->crend();
    }

    constexpr auto rbegin() {
        return static_cast<T*>(this)->begin();
    }

    constexpr auto rend() {
        return static_cast<T*>(this)->end();
    }

    constexpr auto rbegin() const {
        return static_cast<T*>(this)->cbegin();
    }

    constexpr auto rend() const {
        return static_cast<T*>(this)->cend();
    }

    constexpr auto crbegin() const {
        return static_cast<T*>(this)->cbegin();
    }

    constexpr auto crend() const {
        return static_cast<T*>(this)->cend();
    }
};

// With a similar syntax to `as_const()`, this adaptor take an iterable
// container, makes its iterator `const`, and inverts its forwards and backwards
// movement.
template <is_bidi_iterable T>
struct as_const_reverse : T {
    constexpr as_const_reverse(T const& base) : T(base) {
    }

    constexpr as_const_reverse(T&& base) : T(move(base)) {
    }

    constexpr auto begin() const {
        return static_cast<T const*>(this)->rbegin();
    }

    constexpr auto end() const {
        return static_cast<T const*>(this)->rend();
    }

    constexpr auto cbegin() const {
        return static_cast<T const*>(this)->crbegin();
    }

    constexpr auto cend() const {
        return static_cast<T const*>(this)->crend();
    }

    constexpr auto rbegin() const {
        return static_cast<T const*>(this)->cbegin();
    }

    constexpr auto rend() const {
        return static_cast<T const*>(this)->cend();
    }

    constexpr auto crbegin() const {
        return static_cast<T const*>(this)->cbegin();
    }

    constexpr auto crend() const {
        return static_cast<T const*>(this)->cend();
    }
};

// TODO: Add an `it_enumerate` iterator adapter.

}  // namespace cat

#pragma GCC diagnostic pop
