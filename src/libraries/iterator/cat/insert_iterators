// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/allocator>
#include <cat/iterator>

namespace cat {

template <is_iterable T>
class back_insert_iterator
    : public iterator_interface<back_insert_iterator<T>> {
  public:
    using container_type = T;

    constexpr explicit back_insert_iterator(T& input_iterable)
        : iterable(input_iterable) {
    }

    template <typename U>
    constexpr auto operator=(U& value) = delete;

    // `.insert()` is used instead of an overloaded `=` because it might
    // need to take an allocator parameter.

    template <typename U>
    constexpr auto insert(/* allocator */ auto& allocator, U& value)
        -> maybe<back_insert_iterator<T>&> {
        maybe result = this->iterable.push_back(allocator, value);
        if (!result.has_value()) {
            return nullopt;
        }
        return *this;
    }

    template <typename U>
    constexpr auto insert(U& value) -> back_insert_iterator<T>& {
        this->iterable.push_back(value);
        return *this;
    }

    template <typename U>
    constexpr auto insert(/* allocator */ auto& allocator, U const& value)
        -> maybe<back_insert_iterator<T>&> {
        maybe result = this->iterable.push_back(allocator, value);
        if (!result.has_value()) {
            return nullopt;
        }
        return *this;
    }

    template <typename U>
    constexpr auto insert(U const& value) -> back_insert_iterator<T>& {
        this->iterable.push_back(value);
        return *this;
    }

    template <typename U>
    constexpr auto operator=(U const& value) -> back_insert_iterator<T>& {
        this->iterable.push_back(value);
        return *this;
    }

    template <typename U>
    constexpr auto insert(/* allocator */ auto& allocator, U&& value)
        -> maybe<back_insert_iterator<T>&> {
        maybe result = this->iterable.push_back(allocator, forward<U>(value));
        if (!result.has_value()) {
            return nullopt;
        }
        return *this;
    }

    template <typename U>
    constexpr auto insert(U&& value) -> back_insert_iterator<T>& {
        this->iterable.push_back(forward<U>(value));
        return *this;
    }

    template <typename U>
    constexpr auto operator=(U&& value) -> back_insert_iterator<T>& {
        this->iterable.push_back(forward<U>(value));
        return *this;
    }

    // Dereference operator is no-op.
    constexpr auto dereference() -> back_insert_iterator<T>& {
        return *this;
    }

    // Increment operators are no-op.
    constexpr auto increment() -> back_insert_iterator<T>& {
        return *this;
    }

  private:
    T& iterable;
};

template <is_iterable T>
class front_insert_iterator
    : public iterator_interface<front_insert_iterator<T>> {
  public:
    using container_type = T;

    constexpr explicit front_insert_iterator(T& input_iterable)
        : iterable(input_iterable) {
    }

    template <typename U>
    constexpr auto operator=(U& value) = delete;

    // `.insert()` is used instead of an overloaded `=` because it might
    // need to take an allocator parameter.

    template <typename U>
    constexpr auto insert(/* allocator */ auto& allocator, U& value)
        -> maybe<front_insert_iterator<T>&> {
        maybe result = this->iterable.push_front(allocator, value);
        if (!result.has_value()) {
            return nullopt;
        }
        return *this;
    }

    template <typename U>
    constexpr auto insert(U& value) -> front_insert_iterator<T>& {
        this->iterable.push_front(value);
        return *this;
    }

    template <typename U>
    constexpr auto insert(/* allocator */ auto& allocator, U const& value)
        -> maybe<front_insert_iterator<T>&> {
        maybe result = this->iterable.push_front(allocator, value);
        if (!result.has_value()) {
            return nullopt;
        }
        return *this;
    }

    template <typename U>
    constexpr auto insert(U const& value) -> front_insert_iterator<T>& {
        this->iterable.push_front(value);
        return *this;
    }

    template <typename U>
    constexpr auto operator=(U const& value) -> front_insert_iterator<T>& {
        this->iterable.push_front(value);
        return *this;
    }

    template <typename U>
    constexpr auto insert(/* allocator */ auto& allocator, U&& value)
        -> maybe<front_insert_iterator<T>&> {
        maybe result = this->iterable.push_front(allocator, forward<U>(value));
        if (!result.has_value()) {
            return nullopt;
        }
        return *this;
    }

    template <typename U>
    constexpr auto insert(U&& value) -> front_insert_iterator<T>& {
        this->iterable.push_front(forward<U>(value));
        return *this;
    }

    template <typename U>
    constexpr auto operator=(U&& value) -> front_insert_iterator<T>& {
        this->iterable.push_front(forward<U>(value));
        return *this;
    }

    // Dereference operator is no-op.
    constexpr auto dereference() -> front_insert_iterator<T>& {
        return *this;
    }

    // Increment operators are no-op.
    constexpr auto increment() -> front_insert_iterator<T>& {
        return *this;
    }

  private:
    T& iterable;
};

}  // namespace cat
