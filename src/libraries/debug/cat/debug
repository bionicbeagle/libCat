// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/format>
#include <cat/linear_allocator>
#include <cat/linux>

namespace std {

// NOLINTNEXTLINE This must be snake_case.
class source_location {
  public:
    static constexpr auto current(
        decltype(__builtin_source_location()) p_call_site_location =
            __builtin_source_location()) -> source_location {
        source_location current_location;
        current_location.p_location =
            static_cast<__impl const*>(p_call_site_location);
        return current_location;
    }

    constexpr auto line() const -> unsigned long {
        return (this->p_location != nullptr) ? this->p_location->_M_line : 0u;
    }

    constexpr auto column() const -> unsigned long {
        return (this->p_location != nullptr) ? this->p_location->_M_column : 0u;
    }

    constexpr auto file_name() const -> char const* {
        return (this->p_location != nullptr) ? this->p_location->_M_file_name
                                             : "";
    }

    constexpr auto function_name() const -> char const* {
        return (this->p_location != nullptr)
                   ? this->p_location->_M_function_name
                   : "";
    }

  private:
    // GCC requires these names be exactly what they are.
    struct __impl {                    // NOLINT
        char const* _M_file_name;      // NOLINT
        char const* _M_function_name;  // NOLINT
        unsigned long _M_line;         // NOLINT
        unsigned long _M_column;       // NOLINT
    };

    __impl const* p_location = nullptr;
};

}  // namespace std

namespace cat {

using SourceLocation = std::source_location;

void breakpoint() {
    // TODO: Arm and Windows support.
#ifdef __x86_64__
    // For x86-64, insert a breakpoint interrupt instruction.
    asm volatile("int3");
#else
    // Without hardware support, raise SIGILL, which breaks in a debugger.
    nix::raise_here(nix::Signal::illegal_instruction);
#endif
}

namespace detail {
    void print_assert_location(
        SourceLocation const& callsite = SourceLocation::current()) {
        Array<Byte, 128> buffer;
        LinearAllocator allocator{buffer.p_data(), buffer.size()};
        _ = eprint(format(allocator, "assert failed on line {}, in:\n    ",
                          callsite.line())
                       // This `format()` call cannot possibly fail.
                       .value());
        // TODO: Truncate to only the last one or two directories.
        _ = eprint(callsite.file_name());
        _ = eprint("\ncalled from:\n    ");
        _ = eprintln(callsite.function_name());
    }

    void default_assert_handler(SourceLocation const& callsite) {
        detail::print_assert_location(callsite);

        // TODO: Colorize this input prompt.
        _ = print("Press: 1 (Continue), 2 (Debug), 3 (Abort)\n");

        while (true) {
            char input = nix::read_char().or_exit();
            if (input >= '1' && input <= '3') {
                // ASCII trick that converts an inputted char to a digit.
                uint1 digit = input - 49_u1;

                // The value of `digit` is one less than what was inputted.
                switch (digit.raw) {
                    case 0:
                        // Ignore the assert failure.
                        return;
                    case 1:
                        // Break in a debugger.
                        breakpoint();
                        return;
                    case 2:
                        // Abort the program.
                        _ = eprint("Program aborted!\n");
                        exit(1);
                    default:
                        __builtin_unreachable();
                }

                return;
            }
            _ = eprint("Invalid input!\n");
        }
    }
}  // namespace detail

// Check that an expression holds true in all builds. If it holds false, invoke
// an assert handler.
void verify(bool invariant_expression,
            void (*p_assert_handler)(SourceLocation const&) =
                detail::default_assert_handler,
            SourceLocation const& callsite = SourceLocation::current()) {
    if (invariant_expression) [[likely]] {
        return;
    }

    p_assert_handler(callsite);
    __builtin_unreachable();
}

// Check that an expression holds true in all builds. If it holds false, print
// `error_string` and invoke an assert handler.
void verify(bool invariant_expression, String const error_string,
            void (*p_assert_handler)(SourceLocation const&) =
                detail::default_assert_handler,
            SourceLocation const& callsite = SourceLocation::current()) {
    if (invariant_expression) [[likely]] {
        return;
    }
    _ = eprint("\n");
    _ = eprintln(error_string);

    p_assert_handler(callsite);
    __builtin_unreachable();
}

// Because `assert()`'s arguments are not passed into `verify()` when `NDEBUG`
// is defined, the compiler should not warn when they are unused.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

// Check that an expression holds true when `NDEBUG` is not defined. If it holds
// false, invoke an assert handler.
void assert(bool invariant_expression,
            void (*p_assert_handler)(SourceLocation const&) =
                detail::default_assert_handler,
            SourceLocation const& callsite = SourceLocation::current()) {
#ifndef NDEBUG
    verify(invariant_expression, p_assert_handler, callsite);
#endif
}

// Check that an expression holds true when `NDEBUG` is not defined. If it
// holds false, print `error_string` and invoke an assert handler.
void assert(bool invariant_expression, String const error_string,
            void (*p_assert_handler)(SourceLocation const&) =
                detail::default_assert_handler,
            SourceLocation const& callsite = SourceLocation::current()) {
#ifndef NDEBUG
    verify(invariant_expression, error_string, p_assert_handler, callsite);
#endif
}

#pragma GCC diagnostic pop

}  // namespace cat
