// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

namespace std {

// NOLINTNEXTLINE This must be snake_case.
class source_location {
  public:
    static constexpr auto current(
        decltype(__builtin_source_location()) p_call_site_location =
            __builtin_source_location()) -> source_location {
        source_location current_location;
        current_location.p_location =
            static_cast<__impl const*>(p_call_site_location);
        return current_location;
    }

    constexpr auto line() const -> unsigned long {
        return (this->p_location != nullptr) ? this->p_location->_M_line : 0u;
    }

    constexpr auto column() const -> unsigned long {
        return (this->p_location != nullptr) ? this->p_location->_M_column : 0u;
    }

    constexpr auto file_name() const -> char const* {
        return (this->p_location != nullptr) ? this->p_location->_M_file_name
                                             : "";
    }

    constexpr auto function_name() const -> char const* {
        return (this->p_location != nullptr)
                   ? this->p_location->_M_function_name
                   : "";
    }

  private:
    // GCC requires these names be exactly what they are.
    struct __impl {                    // NOLINT
        char const* _M_file_name;      // NOLINT
        char const* _M_function_name;  // NOLINT
        unsigned long _M_line;         // NOLINT
        unsigned long _M_column;       // NOLINT
    };

    __impl const* p_location = nullptr;
};

}  // namespace std

namespace cat {

class String;
using SourceLocation = std::source_location;

void breakpoint();

// TODO: Allow `assert()` and `verify()` in a `constexpr` context, and make them
// throw if their invariant holds false.

void assert_handler(SourceLocation const& callsite);

// Check that an expression holds true in all builds. If it holds false, invoke
// an assert handler.
void verify(bool invariant_expression,
            void (*p_assert_handler)(SourceLocation const&) = assert_handler,
            SourceLocation const& callsite = SourceLocation::current());

// Check that an expression holds true in all builds. If it holds false, print
// `error_string` and invoke an assert handler.
void verify(bool invariant_expression, String const error_string,
            void (*p_assert_handler)(SourceLocation const&) = assert_handler,
            SourceLocation const& callsite = SourceLocation::current());

// Check that an expression holds true when `NDEBUG` is not defined. If it holds
// false, invoke an assert handler.
void assert(bool invariant_expression,
            void (*p_assert_handler)(SourceLocation const&) = assert_handler,
            SourceLocation const& callsite = SourceLocation::current());

// Check that an expression holds true when `NDEBUG` is not defined. If it
// holds false, print `error_string` and invoke an assert handler.
void assert(bool invariant_expression, String const error_string,
            void (*p_assert_handler)(SourceLocation const&) = assert_handler,
            SourceLocation const& callsite = SourceLocation::current());

}  // namespace cat

using cat::assert;
using cat::verify;
