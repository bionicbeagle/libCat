// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/compare>
#include <cat/limits>

// `Arithmetic` and `ArithmeticPtr` are containers for numeric data types which
// prevents unsafe implicit type casts.
//
// All of their conversion operators, is_arithmetic operators and constructors
// are generic with constraints. Because these methods are constrained, it
// is possible that the compiler will fail to resolve any satisfying
// overloads for an invocation of an operator or constructor, and thus prevent
// compilation.
//
// Constraints such as "the operand's size must be less than or equal to my
// own size" guarantee that an unwanted overload cannot be resolved.
// This solution is concise, because any constraint broadly applies to all
// possible type conversions.

namespace cat {

// These policies control the overflow semantics of `Arithmetic`s.
enum class OverflowPolicies {
    undefined,
    wrap,
    saturate,
    trap,
    wrap_member,
    saturate_member,
    trap_member,
};

template <typename T>
inline constexpr bool is_arithmetic_ptr = requires {
    T::Ptr;
};

template <typename T>
constexpr auto to_raw_numeral(T value) {
    if constexpr (requires { value.raw; }) {
        return value.raw;
    } else {
        return value;
    }
}

template <typename T>
using ToRawArithmetic = decltype(to_raw_numeral(T(0)));

template <typename T>
concept is_raw_numeral = is_same<T, ToRawArithmetic<T>>;

template <typename T>
concept is_raw_integral = is_integral<T> && is_raw_numeral<T>;

template <typename T>
concept rawFloating = is_floating_point<T> && is_raw_numeral<T>;

template <is_integral T>
constexpr auto make_signed(T value) -> MakeSigned<T> {
    // return __builtin_bit_cast(MakeSigned<T>, value);
    return static_cast<MakeSigned<T>>(value);
}

template <is_integral T>
constexpr auto make_unsigned(T value) -> MakeUnsigned<T> {
    // return __builtin_bit_cast(MakeUnsigned<T>, value);
    return static_cast<MakeUnsigned<T>>(value);
}

template <is_integral Sign, is_integral T>
constexpr auto make_sign_from(T value) -> CopySignFrom<Sign, T> {
    return static_cast<CopySignFrom<Sign, T>>(value);
}

template <is_integral Sign, is_integral T>
constexpr auto make_sign_from(Sign, T value) -> CopySignFrom<Sign, T> {
    return static_cast<CopySignFrom<Sign, T>>(value);
}

// These macros are defined by the GCC compiler.
using int1 = Arithmetic<__INT8_TYPE__, OverflowPolicies::undefined>;  // NOLINT
using uint1 =
    Arithmetic<__UINT8_TYPE__, OverflowPolicies::undefined>;           // NOLINT
using int2 = Arithmetic<__INT16_TYPE__, OverflowPolicies::undefined>;  // NOLINT
using uint2 =
    Arithmetic<__UINT16_TYPE__, OverflowPolicies::undefined>;          // NOLINT
using int4 = Arithmetic<__INT32_TYPE__, OverflowPolicies::undefined>;  // NOLINT
using uint4 =
    Arithmetic<__UINT32_TYPE__, OverflowPolicies::undefined>;          // NOLINT
using int8 = Arithmetic<__INT64_TYPE__, OverflowPolicies::undefined>;  // NOLINT
using uint8 =
    Arithmetic<__UINT64_TYPE__, OverflowPolicies::undefined>;  // NOLINT
// using i128 = Arithmetic<int128_t, OverflowPolicies::undefined>; // NOLINT
// using u128 = Arithmetic<uint128_t, OverflowPolicies::undefined>; // NOLINT

using float4 = Arithmetic<float, OverflowPolicies::undefined>;   // NOLINT
using float8 = Arithmetic<double, OverflowPolicies::undefined>;  // NOLINT

using wrap_int1 = Arithmetic<__INT8_TYPE__, OverflowPolicies::wrap>;  // NOLINT
using wrap_uint1 =
    Arithmetic<__UINT8_TYPE__, OverflowPolicies::wrap>;                // NOLINT
using wrap_int2 = Arithmetic<__INT16_TYPE__, OverflowPolicies::wrap>;  // NOLINT
using wrap_uint2 =
    Arithmetic<__UINT16_TYPE__, OverflowPolicies::wrap>;               // NOLINT
using wrap_int4 = Arithmetic<__INT32_TYPE__, OverflowPolicies::wrap>;  // NOLINT
using wrap_uint4 =
    Arithmetic<__UINT32_TYPE__, OverflowPolicies::wrap>;               // NOLINT
using wrap_int8 = Arithmetic<__INT64_TYPE__, OverflowPolicies::wrap>;  // NOLINT
using wrap_uint8 =
    Arithmetic<__UINT64_TYPE__, OverflowPolicies::wrap>;  // NOLINT

// NOLINTNEXTLINE
using sat_int1 = Arithmetic<__INT8_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_uint1 = Arithmetic<__UINT8_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_int2 = Arithmetic<__INT16_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_uint2 = Arithmetic<__UINT16_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_int4 = Arithmetic<__INT32_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_uint4 = Arithmetic<__UINT32_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_int8 = Arithmetic<__INT64_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_uint8 = Arithmetic<__UINT64_TYPE__, OverflowPolicies::saturate>;

// NOLINTNEXTLINE
using usize = Arithmetic<__SIZE_TYPE__, OverflowPolicies::undefined>;
// NOLINTNEXTLINE
using ssize =
    Arithmetic<MakeSigned<__SIZE_TYPE__>, OverflowPolicies::undefined>;

template <typename From, typename To>
concept is_safe_arithmetic_comparison =
    // `ToRawArithmetic` is needed here to prevent a recursive constraint
    // in evaluating the `<` operator.
    ((is_signed<ToRawArithmetic<From>> == is_signed<ToRawArithmetic<To>>)) &&
    (is_floating_point<From> == is_floating_point<To>);

// Any numeral can safely convert to a type larger than itself, but not
// smaller than itself.
template <typename From, typename To>
concept is_safe_arithmetic_conversion =
    (sizeof(From) <= sizeof(To)) && (is_safe_arithmetic_comparison<From, To>);

namespace detail {
    template <typename T, typename U>
    consteval auto promoted_numeral() {
        if constexpr (is_arithmetic_ptr<T>) {
            return T();
        } else if constexpr (is_arithmetic_ptr<U>) {
            return U();
        } else {
            if constexpr (sizeof(T) >= sizeof(U)) {
                return Arithmetic<ToRawArithmetic<T>,
                                  OverflowPolicies::undefined>{};
            } else {
                return Arithmetic<ToRawArithmetic<U>,
                                  OverflowPolicies::undefined>{};
            }
        }
    }

    template <typename T, typename U>
        requires((is_signed<T> == is_signed<U>)&&(is_floating_point<T> ==
                                                  is_floating_point<U>))
    using PromotedArithmetic = decltype(promoted_numeral<T, U>());
}  // namespace detail

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_leading_zeros(T value) -> ssize;

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_trailing_zeros(T value) -> ssize;

// Overflow intrinsics optimize fairly well in GCC.
// `[[gnu::optimize(2)]]` is required because the codegen is awful by default.

// Add two integers with saturating overflow.
template <is_raw_integral T>
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_add(T lhs, T rhs) -> T {
    T sum;
    bool overflow = __builtin_add_overflow(lhs, rhs, &sum);
    if (overflow) {
        return Limits<T>::max();
    }
    return sum;
}

// Erase redundant type information for `sat_add()`.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]] constexpr auto sat_add(T lhs, U rhs)
    -> detail::PromotedArithmetic<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using Type = ToRawArithmetic<Larger<T, U>>;
    return sat_add(static_cast<Type>(lhs), static_cast<Type>(rhs));
}

// Add two integers with wrapping overflow.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]] constexpr auto wrap_add(T lhs, U rhs)
    -> detail::PromotedArithmetic<T, U> {
    // Cast to a raw, unsigned, integer to guarantee wrapping semantics.
    using Type = ToRawArithmetic<MakeUnsigned<Larger<T, U>>>;
    return detail::PromotedArithmetic<T, U>{static_cast<Type>(lhs) +
                                            static_cast<Type>(rhs)};
}

// Subtract two integers with saturating overflow.
template <is_raw_integral T>
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_sub(T lhs, T rhs) -> T {
    T sum;
    bool overflow = __builtin_sub_overflow(lhs, rhs, &sum);
    if (overflow) {
        return Limits<T>::min();
    }
    return sum;
}

// Erase redundant type information for `sat_sub()`.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]] constexpr auto sat_sub(T lhs, U rhs)
    -> detail::PromotedArithmetic<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using Type = ToRawArithmetic<Larger<T, U>>;
    return sat_sub(static_cast<Type>(lhs), static_cast<Type>(rhs));
}

// Subtract two integers with wrapping overflow.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]] constexpr auto wrap_sub(T lhs, U rhs)
    -> detail::PromotedArithmetic<T, U> {
    // Cast to a raw, unsigned, integer to guarantee wrapping semantics.
    using Type = ToRawArithmetic<MakeUnsigned<Larger<T, U>>>;
    return detail::PromotedArithmetic<T, U>{static_cast<Type>(lhs) -
                                            static_cast<Type>(rhs)};
}

// Subtract two integers with saturating overflow.
template <is_raw_integral T>
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_mul(T lhs, T rhs) -> T {
    T sum;
    bool overflow = __builtin_mul_overflow(lhs, rhs, &sum);
    if (overflow) {
        return Limits<T>::max();
    }
    return sum;
}

// Erase redundant type information for `sat_mul()`.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]] constexpr auto sat_mul(T lhs, U rhs)
    -> detail::PromotedArithmetic<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using Type = ToRawArithmetic<Larger<T, U>>;
    return sat_mul(static_cast<Type>(lhs), static_cast<Type>(rhs));
}

// Multiply two integers with wrapping overflow.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]] constexpr auto wrap_mul(T lhs, U rhs)
    -> detail::PromotedArithmetic<T, U> {
    // Cast to a raw, unsigned, integer to guarantee wrapping semantics.
    using Type = ToRawArithmetic<MakeUnsigned<Larger<T, U>>>;
    return detail::PromotedArithmetic<T, U>{static_cast<Type>(lhs) *
                                            static_cast<Type>(rhs)};
}

// Subtract two integers with saturating overflow.
template <is_raw_integral T>
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_div(T lhs, T rhs) -> T {
    if constexpr (is_signed<T>) {
        lhs += !((rhs + 1) | (make_unsigned(lhs) + Limits<T>::max()));
    }
    // Unsigned integer division cannot overflow.
    return lhs / rhs;
}

// Erase redundant type information for `sat_mul()`.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]] constexpr auto sat_div(T lhs, U rhs)
    -> detail::PromotedArithmetic<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using Type = ToRawArithmetic<Larger<T, U>>;
    return sat_div(static_cast<Type>(lhs), static_cast<Type>(rhs));
}

// Divide two integers with wrapping overflow.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]] constexpr auto wrap_div(T lhs, U rhs)
    -> detail::PromotedArithmetic<T, U> {
    // Cast to a raw, unsigned, integer to guarantee wrapping semantics.
    using Type = ToRawArithmetic<MakeUnsigned<Larger<T, U>>>;
    return detail::PromotedArithmetic<T, U>{static_cast<Type>(lhs) /
                                            static_cast<Type>(rhs)};
}

// Left bit-shifting two unsigned integers with saturating overflow.
template <is_raw_integral T, is_raw_integral U>
    // TODO: Figure out signed saturating shift semantics.
    requires(is_unsigned<T>)
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_shl(T value, U bits) {
    // TODO: Try `cat::count_trailing_zeros()`.
    if (bits >= Limits<T>::bits - __builtin_ctz(value)) {
        return Limits<T>::max();
    }
    return value << bits;
}

// Erase redundant type information for `sat_shl()`.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]] constexpr auto sat_shl(T value, U bits)
    -> detail::PromotedArithmetic<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using Type = ToRawArithmetic<Larger<T, U>>;
    return sat_shl(static_cast<Type>(value), static_cast<Type>(bits));
}

template <is_raw_integral T, is_raw_integral U>
    // TODO: Figure out signed saturating shift semantics.
    requires(is_unsigned<T>)
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_shr(T value, U bits) {
    // TODO: Try `cat::count_leading_zeros()`.
    if (bits >= Limits<T>::bits - __builtin_clz(value)) {
        return Limits<T>::min();
    }
    return value >> bits;
}

// Erase redundant type information for `sat_shr()`.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]] constexpr auto sat_shr(T value, U bits)
    -> detail::PromotedArithmetic<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using Type = ToRawArithmetic<Larger<T, U>>;
    return sat_shr(static_cast<Type>(value), static_cast<Type>(bits));
}

namespace detail {
    template <typename T, OverflowPolicies>
    struct ArithmeticStorage {
        // This is the fallback when `T` is a floating point type.
        // Floats can't have sensible overflow semantics, except in some very
        // special cases.
        T raw;
    };

    // To prevent `Arithmetic` holding a member of its own type, only undefined
    // overflow can access other overflow semantics.

    template <is_integral T>
    struct ArithmeticStorage<T, OverflowPolicies::undefined> {
        auto operator<=>(ArithmeticStorage<T, OverflowPolicies::undefined>) =
            delete;
        auto operator==(ArithmeticStorage<T, OverflowPolicies::undefined>) =
            delete;

        union {
            T raw;
            Arithmetic<T, OverflowPolicies::wrap_member> wrap;
            Arithmetic<T, OverflowPolicies::saturate_member> sat;
            Arithmetic<T, OverflowPolicies::trap_member> trap;
        };
    };

    template <is_integral T>
    struct ArithmeticStorage<T, OverflowPolicies::wrap> {
        union {
            T raw;
            Arithmetic<T, OverflowPolicies::saturate_member> sat;
            Arithmetic<T, OverflowPolicies::trap_member> trap;
        };
    };

    template <is_integral T>
    struct ArithmeticStorage<T, OverflowPolicies::saturate> {
        union {
            T raw;
            Arithmetic<T, OverflowPolicies::wrap_member> wrap;
            Arithmetic<T, OverflowPolicies::trap_member> trap;
        };
    };

    template <is_integral T>
    struct ArithmeticStorage<T, OverflowPolicies::trap> {
        union {
            T raw;
            Arithmetic<T, OverflowPolicies::wrap_member> wrap;
            Arithmetic<T, OverflowPolicies::saturate_member> sat;
        };
    };

    template <is_integral T>
    struct ArithmeticStorage<T, OverflowPolicies::wrap_member> {
        T raw;
    };

    template <is_integral T>
    struct ArithmeticStorage<T, OverflowPolicies::saturate_member> {
        T raw;
    };

    template <is_integral T>
    struct ArithmeticStorage<T, OverflowPolicies::trap_member> {
        T raw;
    };
}  // namespace detail

// `Arithmetic` can represent an integer or floating point value. It prevents
// unsafe casts or operations. This is a trivial `struct` so it can be used as a
// non-type template parameter.
template <typename T, OverflowPolicies policy = OverflowPolicies::undefined>
struct Arithmetic : detail::ArithmeticStorage<T, policy> {
    using Raw = T;

    // This constraint doesn't need to be SFINAE friendly, and it isn't obvious
    // how to refactor this so it is.
    static_assert(is_integral<T> || (policy == OverflowPolicies::undefined));

    constexpr Arithmetic() = default;

    // Constructing with safe conversions is implicit, but constructing with
    // unsafe conversions is explicit.
    template <is_arithmetic U>
    constexpr explicit(!is_safe_arithmetic_conversion<U, T>)
        Arithmetic(U other) {
        this->raw = to_raw_numeral(other);
    }

    template <typename U>
    constexpr explicit operator U() const {
        return static_cast<U>(this->raw);
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator<=>(Arithmetic<T, policy> lhs,
                                                    U rhs) {
        return lhs.raw <=> to_raw_numeral(rhs);
    }

    // A `!=` operator is not generated by `<=>`, but overloading `!=` prevents
    // generating `==`. Instead, `==` is explicitly provided to generate `!=`.
    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator==(Arithmetic<T, policy> lhs,
                                                   U rhs) -> bool {
        return lhs.raw == to_raw_numeral(rhs);
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    constexpr auto operator=(U operand) {
        this->raw = to_raw_numeral(operand);
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator+(Arithmetic<T, policy> self,
                                                  U operand)
        -> detail::PromotedArithmetic<T, U> {
        using enum OverflowPolicies;
        if constexpr (policy == undefined) {
            // Make signed to guarantee undefined semantics (unless the
            // is_arithmetic is floating point).
            return detail::PromotedArithmetic<T, U>{
                make_signed(self.raw) + make_signed(to_raw_numeral(operand))};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_add(to_raw_numeral(self), to_raw_numeral(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_add(to_raw_numeral(self), to_raw_numeral(operand));
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator+(U* p_operand,
                                                  Arithmetic<T, policy> numeral)
        -> U* {
        return p_operand + numeral.raw;
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator+(Arithmetic<T, policy> numeral,
                                                  U* p_operand) -> U* {
        return numeral.raw + p_operand;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator+=(Arithmetic<T, policy>& self, U operand)
        -> Arithmetic& {
        self = self + to_raw_numeral(operand);
        return self;
    }

    [[nodiscard]] friend constexpr auto operator+(Arithmetic<T, policy> self)
        -> Arithmetic {
        return +(self.raw);
    }

    friend constexpr auto operator++(Arithmetic<T, policy>& self)
        -> Arithmetic& {
        self += static_cast<T>(1);
        return self;
    }

    friend constexpr auto operator++(Arithmetic<T, policy>& self, int)
        -> Arithmetic& {
        self += static_cast<T>(1);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator-(Arithmetic<T, policy> self,
                                                  U operand)
        -> detail::PromotedArithmetic<T, U> {
        using enum OverflowPolicies;
        if constexpr (policy == undefined) {
            // TODO: See if using `[[assume()]]` actually optimizes this.
            if constexpr (is_unsigned<T>) {
                // NOLINTNEXTLINE This is a C++23 feature.
                [[assume(self >= operand)]];
            }
            // Making this signed for optimizations causes various problems.
            return detail::PromotedArithmetic<T, U>{self.raw -
                                                    to_raw_numeral(operand)};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_sub(to_raw_numeral(self), to_raw_numeral(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_sub(to_raw_numeral(self), to_raw_numeral(operand));
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator-(U* p_operand,
                                                  Arithmetic<T, policy> self)
        -> U* {
        return p_operand - self.raw;
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator-(Arithmetic<T, policy> numeral,
                                                  U* p_operand) -> U* {
        return numeral.raw - p_operand;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    friend constexpr auto operator-=(Arithmetic<T, policy>& self, U operand)
        -> Arithmetic& {
        self = self - to_raw_numeral(operand);
        return self;
    }

    [[nodiscard]] friend constexpr auto operator-(Arithmetic<T, policy> self)
        -> Arithmetic requires(is_signed<T>) {
        return -(self.raw);
    }

    friend constexpr auto operator--(Arithmetic<T, policy>& self)
        -> Arithmetic& {
        self -= static_cast<T>(1);
        return self;
    }

    friend constexpr auto operator--(Arithmetic<T, policy>& self, int)
        -> Arithmetic& {
        self -= static_cast<T>(1);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator*(Arithmetic<T, policy> self,
                                                  U operand)
        -> detail::PromotedArithmetic<T, U> {
        using enum OverflowPolicies;
        if constexpr (policy == OverflowPolicies::undefined) {
            // TODO: See if using `[[assume()]]` actually optimizes this.
            if constexpr (is_unsigned<T>) {
                // NOLINTNEXTLINE This is a C++23 feature.
                [[assume(self >= operand)]];
            }
            // Making this signed for optimizations causes various problems.
            return detail::PromotedArithmetic<T, U>{self.raw *
                                                    to_raw_numeral(operand)};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_mul(to_raw_numeral(self), to_raw_numeral(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_mul(to_raw_numeral(self), to_raw_numeral(operand));
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator*(U* p_operand,
                                                  Arithmetic<T, policy> self)
        -> U* {
        return p_operand * self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator*(Arithmetic<T, policy> self,
                                                  U* p_operand) -> U* {
        return p_operand * self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator*=(Arithmetic<T, policy>& self, U operand)
        -> Arithmetic& {
        self = self * to_raw_numeral(operand);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator/(Arithmetic<T, policy> self,
                                                  U operand)
        -> detail::PromotedArithmetic<T, U> {
        using enum OverflowPolicies;
        if constexpr (policy == undefined) {
            // TODO: See if using `[[assume()]]` actually optimizes this.
            if constexpr (is_unsigned<T>) {
                // NOLINTNEXTLINE This is a C++23 feature.
                [[assume(self >= operand)]];
            }
            // Making this signed for optimizations causes various problems.
            return detail::PromotedArithmetic<T, U>{self.raw /
                                                    to_raw_numeral(operand)};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_mul(to_raw_numeral(self), to_raw_numeral(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_mul(to_raw_numeral(self), to_raw_numeral(operand));
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator/(U* p_operand,
                                                  Arithmetic<T, policy> self)
        -> U* {
        return p_operand / self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator/(Arithmetic<T, policy> self,
                                                  U* p_operand) -> U* {
        return p_operand / self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator/=(Arithmetic<T, policy>& self, U operand)
        -> Arithmetic& {
        self = self / to_raw_numeral(operand);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator%(Arithmetic<T, policy> self,
                                                  U operand)
        -> detail::PromotedArithmetic<T, U> {
        return detail::PromotedArithmetic<T, U>{self.raw %
                                                to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator%(U* p_operand,
                                                  Arithmetic<T, policy> self)
        -> U* {
        return p_operand % self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator%(Arithmetic<T, policy> self,
                                                  U* p_operand) -> U* {
        return p_operand % self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator%=(Arithmetic<T, policy>& self, U operand)
        -> Arithmetic& {
        self.raw %= to_raw_numeral(operand);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator&(Arithmetic<T, policy> self,
                                                  U operand)
        -> detail::PromotedArithmetic<T, U> {
        return detail::PromotedArithmetic<T, U>{self.raw &
                                                to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator&(U* p_operand,
                                                  Arithmetic<T, policy> self)
        -> U* {
        return p_operand & self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator&(Arithmetic<T, policy> self,
                                                  U* p_operand) -> U* {
        return p_operand & self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator&=(Arithmetic<T, policy>& self, U operand)
        -> Arithmetic& {
        self.raw &= to_raw_numeral(operand);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    [[nodiscard]] friend constexpr auto operator|(Arithmetic<T, policy> self,
                                                  U operand)
        -> detail::PromotedArithmetic<T, U> {
        return detail::PromotedArithmetic<T, U>{self.raw |
                                                to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator|(U* p_operand,
                                                  Arithmetic<T, policy> self)
        -> U* {
        return p_operand | self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator|(Arithmetic<T, policy> self,
                                                  U* p_operand) -> U* {
        return p_operand | self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator|=(Arithmetic<T, policy>& self, U operand)
        -> Arithmetic& {
        self.raw |= to_raw_numeral(operand);
        return self;
    }

    template <typename U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator<<(Arithmetic<T, policy> self,
                                                   U operand) -> Arithmetic<T> {
        if constexpr (policy == OverflowPolicies::saturate) {
            return sat_shl(to_raw_numeral(self), to_raw_numeral(operand));
        } else {
            return self.raw << to_raw_numeral(operand);
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator<<(U* p_operand,
                                                   Arithmetic<T, policy> self)
        -> U* {
        return p_operand << self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator<<(Arithmetic<T, policy> self,
                                                   U* p_operand) -> U* {
        return p_operand << self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator<<=(Arithmetic<T, policy>& self, U operand)
        -> Arithmetic& {
        self = self << to_raw_numeral(operand);
        return self;
    }

    template <typename U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator>>(Arithmetic<T, policy> self,
                                                   U operand) -> Arithmetic<T> {
        if constexpr (policy == OverflowPolicies::saturate) {
            return sat_shr(to_raw_numeral(self), to_raw_numeral(operand));
        } else {
            return self.raw >> to_raw_numeral(operand);
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator>>(U* p_operand,
                                                   Arithmetic<T, policy> self)
        -> U* {
        return p_operand >> self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator>>(Arithmetic<T, policy> self,
                                                   U* p_operand) -> U* {
        return p_operand >> self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator>>=(Arithmetic<T, policy>& self, U operand)
        -> Arithmetic& {
        self = self >> to_raw_numeral(operand);
        return self;
    }

    [[nodiscard]] friend constexpr auto operator~(Arithmetic<T, policy> self)
        -> Arithmetic requires(is_integral<T>) {
        return ~(self.raw);
    }

    // Member functions for all numerals.

    [[nodiscard]] constexpr auto count_leading_zeros() const -> ssize
        requires(is_integral<T>) {
        return cat::count_leading_zeros(this->raw);
    }

    [[nodiscard]] constexpr auto count_trailing_zeros() const -> ssize
        requires(is_integral<T>) {
        return cat::count_trailing_zeros(this->raw);
    }

    // Making these `auto` solves a clang-tidy false diagnostic.
    // TODO: These should be type `Arithmetic<T>`.
    static constexpr auto min = Limits<Raw>::min();
    static constexpr auto max = Limits<Raw>::max();

    // `Arithmetic` derives public storage from `detail::ArithmeticStorage`.
};

// `ArithmeticPtr` can be constructed from any integer type or any pointer.
// It can only convert into `T*`, but it is otherwise interchangeable with
// integers. It satisfies the `is_integral` type trait and
// `is_integral` concept.
template <typename T, typename Storage,
          auto policy = OverflowPolicies::undefined>
class ArithmeticPtr : public Arithmetic<Storage, policy> {
  public:
    using Raw = Storage;
    using Ptr = T*;

    constexpr ArithmeticPtr() = default;
    constexpr ArithmeticPtr(ArithmeticPtr<T, Storage, policy> const&) = default;
    constexpr ArithmeticPtr(ArithmeticPtr<T, Storage, policy>&&) = default;

    template <is_integral U>
        requires(is_safe_arithmetic_conversion<U, Storage>)
    constexpr ArithmeticPtr(U other)
        : Arithmetic<Storage, policy>(to_raw_numeral(other)) {
    }

    constexpr ArithmeticPtr(T* p_input)
        : Arithmetic<Storage, policy>(reinterpret_cast<Storage>(p_input)) {
    }

    // Allow explicitly constructing from another `ArithmeticPtr` with the same
    // `T`.
    template <is_arithmetic U, OverflowPolicies other_policy>
    constexpr explicit ArithmeticPtr(ArithmeticPtr<T, U, other_policy> other)
        : Arithmetic<Storage, policy>(to_raw_numeral(other)) {
    }

    // Only allow casting back into the original pointer type.
    explicit constexpr operator T*() {
        return reinterpret_cast<T*>(this->raw);
    }

    // Only allow casting back into the original pointer type.
    explicit constexpr operator T*() const {
        return reinterpret_cast<T const*>(this->raw);
    }

    // TODO: GCC 13 does not short-circuit this operator when `T` is `void`, so
    // this workaround using `Conditional` is needed.

    [[nodiscard]] constexpr auto operator*()
        -> Conditional<is_void<T>, int, T>& requires(!is_void<T>) {
        return *(reinterpret_cast<T*>(this->raw));
    }

    [[nodiscard]] constexpr auto operator->() -> T* requires(!is_void<T>) {
        return reinterpret_cast<T*>(this->raw);
    }

    // TODO: Streamline out all of these operators by implementing
    // `Arithmetic`'s with "deducing this".

    // TODO: Cat assignment be `default`?
    // TODO: This redundant assignment operator is required by GCC.
    constexpr auto operator=(ArithmeticPtr<T, Storage, policy> operand)
        -> ArithmeticPtr& {
        this->raw = operand.raw;
        return *this;
    }

    template <is_integral U>
        requires(is_safe_arithmetic_conversion<U, Storage>)
    constexpr auto operator=(U operand) -> ArithmeticPtr& {
        this->raw = to_raw_numeral(operand);
        return *this;
    }

    template <typename U>
        requires(is_safe_arithmetic_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator<=>(
        ArithmeticPtr<T, Storage, policy> lhs, U rhs) {
        return lhs.raw <=> to_raw_numeral(rhs);
    }

    // A `!=` operator is not generated by `<=>`, but overloading `!=`
    // prevents generating `==`. Instead, `==` is explicitly provided to
    // generate `!=`.
    template <typename U>
        requires(is_safe_arithmetic_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator==(
        ArithmeticPtr<T, Storage, policy> lhs, U rhs) -> bool {
        return lhs.raw == to_raw_numeral(rhs);
    }

    // TODO: `requires` constraints on these operators makes GCC 13's argument
    // dependant lookup become ambiguous for some reason.

    template <is_integral U>
    [[nodiscard]] friend constexpr auto operator+(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw + to_raw_numeral(operand);
    }

    template <is_integral U>
    constexpr auto operator+=(U operand) {
        this->raw += to_raw_numeral(operand);
        return *this;
    }

    [[nodiscard]] friend constexpr auto operator+(
        ArithmeticPtr<T, Storage, policy> self) -> ArithmeticPtr {
        return +(self.raw);
    }

    friend constexpr auto operator++(ArithmeticPtr<T, Storage, policy>& self)
        -> ArithmeticPtr {
        return ++(self.raw);
    }

    friend constexpr auto operator++(ArithmeticPtr<T, Storage, policy>& self,
                                     int) -> ArithmeticPtr {
        return (self.raw)++;
    }

    template <is_integral U>
    [[nodiscard]] friend constexpr auto operator-(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw - to_raw_numeral(operand);
    }

    // TODO: Make this `friend`.
    template <typename U>
    constexpr auto operator-=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw - to_raw_numeral(operand);
        return *this;
    }

    [[nodiscard]] friend constexpr auto operator-(
        ArithmeticPtr<T, Storage, policy> self) -> ArithmeticPtr {
        return -(self.raw);
    }

    friend constexpr auto operator--(ArithmeticPtr<T, Storage, policy>& self)
        -> ArithmeticPtr& {
        return --(self.raw);
    }

    friend constexpr auto operator--(ArithmeticPtr<T, Storage, policy>& self,
                                     int) -> ArithmeticPtr& {
        return (self.raw)--;
    }

    template <is_integral U>
    [[nodiscard]] friend constexpr auto operator*(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw * to_raw_numeral(operand);
    }

    template <typename U>
    constexpr auto operator*=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw * to_raw_numeral(operand);
        return *this;
    }

    template <is_integral U>
    [[nodiscard]] friend constexpr auto operator/(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw / to_raw_numeral(operand);
    }

    template <typename U>
    constexpr auto operator/=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw / to_raw_numeral(operand);
        return *this;
    }

    template <is_integral U>
    [[nodiscard]] friend constexpr auto operator%(
        ArithmeticPtr<T, Storage, policy> self, U operand)
        -> ArithmeticPtr<T, Storage, policy> {
        return self.raw % to_raw_numeral(operand);
    }

    template <typename U>
    constexpr auto operator%=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw % to_raw_numeral(operand);
        return *this;
    }

    template <is_integral U>
    [[nodiscard]] friend constexpr auto operator&(
        ArithmeticPtr<T, Storage, policy> self, U operand)
        -> ArithmeticPtr<T, Storage, policy> {
        return self.raw & to_raw_numeral(operand);
    }

    template <typename U>
    constexpr auto operator&=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw & to_raw_numeral(operand);
        return *this;
    }

    template <is_integral U>
    [[nodiscard]] friend constexpr auto operator|(
        ArithmeticPtr<T, Storage, policy> self, U operand)
        -> ArithmeticPtr<T, Storage, policy> {
        return self.raw | to_raw_numeral(operand);
    }

    // TODO: Make more of these hidden `friend`s.

    template <typename U>
    constexpr auto operator|=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw | to_raw_numeral(operand);
        return *this;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator<<(U operand) const
        -> ArithmeticPtr<T, Storage, policy> {
        return static_cast<Storage>(this->raw << to_raw_numeral(operand));
    }

    template <typename U>
    constexpr auto operator<<=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw << to_raw_numeral(operand);
        return *this;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator>>(U operand) const
        -> ArithmeticPtr<T, Storage, policy> {
        return static_cast<Storage>(this->raw >> to_raw_numeral(operand));
    }

    template <typename U>
    constexpr auto operator>>=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw >> to_raw_numeral(operand);
        return *this;
    }

    [[nodiscard]] constexpr auto operator~() -> ArithmeticPtr {
        return ~(this->raw);
    }
};

// `__INTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using intptr = ArithmeticPtr<T, __INTPTR_TYPE__>;  // NOLINT

// `__UINTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using uintptr = cat::ArithmeticPtr<T, __UINTPTR_TYPE__>;  // NOLINT

// Add and assign a `Arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator+=(T* p_lhs, Arithmetic<U> rhs) -> T* {
    p_lhs += rhs.raw;
    return p_lhs;
}

// Subtract and assign a `Arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator-=(T* p_lhs, Arithmetic<U> rhs) -> T* {
    p_lhs -= rhs.raw;
    return p_lhs;
}

// Multiply and assign a `Arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator*=(T* p_lhs, Arithmetic<U> rhs) -> T* {
    p_lhs *= rhs.raw;
    return p_lhs;
}

// Divide and assign a `Arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator/=(T* p_lhs, Arithmetic<U> rhs) -> T* {
    p_lhs /= rhs.raw;
    return p_lhs;
}

// Bitwise shift left and assign a `Arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator<<=(T* p_lhs, Arithmetic<U> rhs) -> T* {
    p_lhs <<= rhs.raw;
    return p_lhs;
}

// Bitwise shift right and assign a `Arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator>>=(T* p_lhs, Arithmetic<U> rhs) -> T* {
    p_lhs >>= rhs.raw;
    return p_lhs;
}

// Bitwise modulo and assign a `Arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator%=(T* p_lhs, Arithmetic<U> rhs) -> T* {
    p_lhs %= rhs.raw;
    return p_lhs;
}

// Bitwise and and assign a `Arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator&=(T* p_lhs, Arithmetic<U> rhs) -> T* {
    p_lhs &= rhs.raw;
    return p_lhs;
}

// Bitwise or and assign a `Arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator|=(T* p_lhs, Arithmetic<U> rhs) -> T* {
    p_lhs |= rhs.raw;
    return p_lhs;
}

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_leading_zeros(T value) -> ssize {
    auto raw_value = to_raw_numeral(value);
    return ssize{__builtin_clz(raw_value)};
}

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_trailing_zeros(T value) -> ssize {
    auto raw_value = to_raw_numeral(value);
    return ssize{__builtin_ctz(raw_value)};
}

template <ssize bytes>
    requires(bytes <= 8 && bytes > 0 &&
             // Is a power of 2:
             ((bytes & (bytes - 1)) == 0))
using IntFixed = Conditional<
    bytes == 1, int1,
    Conditional<bytes == 2, int2, Conditional<bytes == 4, int4, int8>>>;

template <ssize bytes>
    requires(bytes <= 8 && bytes > 0 &&
             // Is a power of 2:
             ((bytes & (bytes - 1)) == 0))
using UintFixed = Conditional<
    bytes == 1, uint1,
    Conditional<bytes == 2, uint2, Conditional<bytes == 4, uint4, uint8>>>;

struct bool2 {  // NOLINT
    using Raw = uint2;
    uint2 raw;
    constexpr bool2() = default;
    constexpr bool2(bool input) : raw(static_cast<unsigned char>(input)) {
    }
    constexpr operator bool() const {
        return this->raw != 0u;
    }
};

struct bool4 {  // NOLINT
    using Raw = uint4;
    uint4 raw;
    constexpr bool4() = default;
    constexpr bool4(bool input) : raw(static_cast<unsigned char>(input)) {
    }
    constexpr bool4(bool2 input) : raw(static_cast<unsigned char>(input)) {
    }
    constexpr operator bool() const {
        return this->raw != 0u;
    }
};

inline constexpr int1 int1_min = Limits<int1>::min();
inline constexpr int1 int1_max = Limits<int1>::max();
inline constexpr uint1 uint1_min = Limits<uint1>::min();
inline constexpr uint1 uint1_max = Limits<uint1>::max();
inline constexpr int2 int2_min = Limits<int2>::min();
inline constexpr int2 int2_max = Limits<int2>::max();
inline constexpr uint2 uint2_min = Limits<uint2>::min();
inline constexpr uint2 uint2_max = Limits<uint2>::max();
inline constexpr int4 int4_min = Limits<int4>::min();
inline constexpr int4 int4_max = Limits<int4>::max();
inline constexpr uint4 uint4_min = Limits<uint4>::min();
inline constexpr uint4 uint4_max = Limits<uint4>::max();
inline constexpr int8 int8_min = Limits<int8>::min();
inline constexpr int8 int8_max = Limits<int8>::max();
inline constexpr uint8 uint8_min = Limits<uint8>::min();
inline constexpr uint8 uint8_max = Limits<uint8>::max();

}  // namespace cat

constexpr auto operator""_i1(unsigned long long input) -> cat::int1 {
    return cat::int1{input};
}

constexpr auto operator""_i2(unsigned long long input) -> cat::int2 {
    return cat::int2{input};
}

constexpr auto operator""_i4(unsigned long long input) -> cat::int4 {
    return cat::int4{input};
}

constexpr auto operator""_i8(unsigned long long input) -> cat::int8 {
    return cat::int8{input};
}

constexpr auto operator""_sz(unsigned long long input) -> cat::ssize {
    return cat::ssize{input};
}

constexpr auto operator""_u1(unsigned long long input) -> cat::uint1 {
    return cat::uint1{input};
}

constexpr auto operator""_u2(unsigned long long input) -> cat::uint2 {
    return cat::uint2{input};
}

constexpr auto operator""_u4(unsigned long long input) -> cat::uint4 {
    return cat::uint4{input};
}

constexpr auto operator""_u8(unsigned long long input) -> cat::uint8 {
    return cat::uint8{input};
}

constexpr auto operator""_uz(unsigned long long input) -> cat::usize {
    return cat::usize{input};
}

constexpr auto operator""_f4(unsigned long long input) -> cat::float4 {
    return cat::float4{input};
}

constexpr auto operator""_f8(unsigned long long input) -> cat::float8 {
    return cat::float8{input};
}

using cat::bool2;
using cat::bool4;
using cat::float4;
using cat::float8;
using cat::int1;
using cat::int2;
using cat::int4;
using cat::int8;
using cat::ssize;
using cat::uint1;
using cat::uint2;
using cat::uint4;
using cat::uint8;
using cat::usize;

template <typename T>
using intptr = cat::intptr<T>;  // NOLINT
template <typename T>
using uintptr = cat::uintptr<T>;  // NOLINT

// `intptr` and `uintptr` are not trivial, but they can be trivially
// relocatable.
template <typename T>
    requires(cat::is_trivial<T> || cat::is_void<T>)
constexpr bool cat::is_trivially_relocatable<cat::intptr<T>> = true;
template <typename T>
    requires(cat::is_trivial<T> || cat::is_void<T>)
constexpr bool cat::is_trivially_relocatable<cat::uintptr<T>> = true;
