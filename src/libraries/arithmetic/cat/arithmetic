// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/compare>
#include <cat/limits>

// `arithmetic` and `arithmetic_ptr` are containers for numeric data types which
// prevents unsafe implicit type casts.
//
// All of their conversion operators, is_arithmetic operators and constructors
// are generic with constraints. Because these methods are constrained, it
// is possible that the compiler will fail to resolve any satisfying
// overloads for an invocation of an operator or constructor, and thus prevent
// compilation.
//
// Constraints such as "the operand's size must be less than or equal to my
// own size" guarantee that an unwanted overload cannot be resolved.
// This solution is concise, because any constraint broadly applies to all
// possible type conversions.

#define ssizeof(argument) cat::ssize(sizeof(argument))

namespace cat {

// These policies control the overflow semantics of `arithmetic`s.
enum class overflow_policies {
    undefined,
    wrap,
    saturate,
    trap,
    wrap_member,
    saturate_member,
    trap_member,
};

template <typename T>
inline constexpr bool is_arithmetic_ptr = requires { T::Ptr; };

template <is_arithmetic T>
constexpr auto to_raw_arithmetic(T value) {
    if constexpr (requires { value.raw; }) {
        return value.raw;
    } else {
        return value;
    }
}

template <is_arithmetic T>
using to_raw_arithmetic_type = decltype(to_raw_arithmetic(T(0)));

// TODO: Update name.
template <typename T>
concept is_raw_arithmetic = is_same<T, to_raw_arithmetic_type<T>>;

template <typename T>
concept is_raw_integral = is_integral<T> && is_raw_arithmetic<T>;

// TODO: Update name.
template <typename T>
concept is_raw_floating_point = is_floating_point<T> && is_raw_arithmetic<T>;

template <is_integral T>
constexpr auto make_signed(T value) -> make_signed_type<T> {
    // return __builtin_bit_cast(make_signed_type<T>, value);
    return static_cast<make_signed_type<T>>(value);
}

template <is_integral T>
constexpr auto make_unsigned(T value) -> make_unsigned_type<T> {
    // return __builtin_bit_cast(make_unsigned_type<T>, value);
    return static_cast<make_unsigned_type<T>>(value);
}

template <is_integral sign_type, is_integral T>
constexpr auto make_sign_from(T value) -> copy_sign_from<sign_type, T> {
    return static_cast<copy_sign_from<sign_type, T>>(value);
}

template <is_integral sign_type, is_integral T>
constexpr auto make_sign_from(sign_type, T value)
    -> copy_sign_from<sign_type, T> {
    return static_cast<copy_sign_from<sign_type, T>>(value);
}

// These macros are defined by the GCC compiler.
using int1 = arithmetic<__INT8_TYPE__, overflow_policies::undefined>;
using uint1 = arithmetic<__UINT8_TYPE__, overflow_policies::undefined>;
using int2 = arithmetic<__INT16_TYPE__, overflow_policies::undefined>;
using uint2 = arithmetic<__UINT16_TYPE__, overflow_policies::undefined>;
using int4 = arithmetic<__INT32_TYPE__, overflow_policies::undefined>;
using uint4 = arithmetic<__UINT32_TYPE__, overflow_policies::undefined>;
using int8 = arithmetic<__INT64_TYPE__, overflow_policies::undefined>;
using uint8 = arithmetic<__UINT64_TYPE__, overflow_policies::undefined>;
// using i128 = arithmetic<int128_t, overflow_policies::undefined>;
// using u128 = arithmetic<uint128_t, overflow_policies::undefined>;

using float4 = arithmetic<float, overflow_policies::undefined>;
using float8 = arithmetic<double, overflow_policies::undefined>;

using wrap_int1 = arithmetic<__INT8_TYPE__, overflow_policies::wrap>;
using wrap_uint1 = arithmetic<__UINT8_TYPE__, overflow_policies::wrap>;
using wrap_int2 = arithmetic<__INT16_TYPE__, overflow_policies::wrap>;
using wrap_uint2 = arithmetic<__UINT16_TYPE__, overflow_policies::wrap>;
using wrap_int4 = arithmetic<__INT32_TYPE__, overflow_policies::wrap>;
using wrap_uint4 = arithmetic<__UINT32_TYPE__, overflow_policies::wrap>;
using wrap_int8 = arithmetic<__INT64_TYPE__, overflow_policies::wrap>;
using wrap_uint8 = arithmetic<__UINT64_TYPE__, overflow_policies::wrap>;

using sat_int1 = arithmetic<__INT8_TYPE__, overflow_policies::saturate>;
using sat_uint1 = arithmetic<__UINT8_TYPE__, overflow_policies::saturate>;
using sat_int2 = arithmetic<__INT16_TYPE__, overflow_policies::saturate>;
using sat_uint2 = arithmetic<__UINT16_TYPE__, overflow_policies::saturate>;
using sat_int4 = arithmetic<__INT32_TYPE__, overflow_policies::saturate>;
using sat_uint4 = arithmetic<__UINT32_TYPE__, overflow_policies::saturate>;
using sat_int8 = arithmetic<__INT64_TYPE__, overflow_policies::saturate>;
using sat_uint8 = arithmetic<__UINT64_TYPE__, overflow_policies::saturate>;

using usize = arithmetic<__SIZE_TYPE__, overflow_policies::undefined>;
using ssize =
    arithmetic<make_signed_type<__SIZE_TYPE__>, overflow_policies::undefined>;

template <typename From, typename To>
concept is_safe_arithmetic_comparison =
    // `to_raw_arithmetic_type` is needed here to prevent a recursive constraint
    // in evaluating the `<` operator inside `is_signed`.
    ((is_signed<to_raw_arithmetic_type<From>> ==
      is_signed<to_raw_arithmetic_type<To>>)) &&
    (is_floating_point<From> == is_floating_point<To>);

// Any numeral can safely convert to a type larger than itself, but not
// smaller than itself.
template <typename From, typename To>
concept is_safe_arithmetic_conversion =
    (sizeof(From) <= sizeof(To)) && (is_safe_arithmetic_comparison<From, To>);

template <typename T>
concept is_safe_arithmetic =
    is_arithmetic<T> && !__is_same(T, to_raw_arithmetic_type<T>);

template <typename T>
concept is_unsafe_arithmetic =
    is_arithmetic<T> && __is_same(T, to_raw_arithmetic_type<T>);

namespace detail {
    template <typename T, typename U>
    consteval auto promoted_arithmetic() {
        if constexpr (is_arithmetic_ptr<T>) {
            return T();
        } else if constexpr (is_arithmetic_ptr<U>) {
            return U();
        } else {
            if constexpr (sizeof(T) >= sizeof(U)) {
                return arithmetic<to_raw_arithmetic_type<T>,
                                  overflow_policies::undefined>{};
            } else {
                return arithmetic<to_raw_arithmetic_type<U>,
                                  overflow_policies::undefined>{};
            }
        }
    }

    template <typename T, typename U>
        requires((is_signed<T> == is_signed<U>) &&
                 (is_floating_point<T> == is_floating_point<U>))
    using promoted_type = decltype(promoted_arithmetic<T, U>());
}  // namespace detail

// Overflow intrinsics optimize fairly well in GCC.
// `[[gnu::optimize(2)]]` is required because the codegen is awful by default.

// Add two integers with saturating overflow.
template <is_raw_integral T>
[[nodiscard,
#ifndef __OPTIMIZED__
  gnu::optimize(2)
#endif
]]
constexpr auto sat_add(T lhs, T rhs) -> T {
    T sum;
    bool overflow = __builtin_add_overflow(lhs, rhs, &sum);
    if (overflow) {
        return limits<T>::max();
    }
    return sum;
}

// Erase redundant type information for `sat_add()`.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]]
constexpr auto sat_add(T lhs, U rhs) -> detail::promoted_type<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using type = to_raw_arithmetic_type<larger_type<T, U>>;
    return sat_add(static_cast<type>(lhs), static_cast<type>(rhs));
}

// Add two integers with wrapping overflow.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]]
constexpr auto wrap_add(T lhs, U rhs) -> detail::promoted_type<T, U> {
    // Cast to a raw, unsigned, integer to guarantee wrapping semantics.
    using type = to_raw_arithmetic_type<make_unsigned_type<larger_type<T, U>>>;
    return detail::promoted_type<T, U>{static_cast<type>(lhs) +
                                       static_cast<type>(rhs)};
}

// Subtract two integers with saturating overflow.
template <is_raw_integral T>
[[nodiscard,
#ifndef __OPTIMIZED__
  gnu::optimize(2)
#endif
]]
constexpr auto sat_sub(T lhs, T rhs) -> T {
    T sum;
    bool overflow = __builtin_sub_overflow(lhs, rhs, &sum);
    if (overflow) {
        return limits<T>::min();
    }
    return sum;
}

// Erase redundant type information for `sat_sub()`.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]]
constexpr auto sat_sub(T lhs, U rhs) -> detail::promoted_type<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using type = to_raw_arithmetic_type<larger_type<T, U>>;
    return sat_sub(static_cast<type>(lhs), static_cast<type>(rhs));
}

// Subtract two integers with wrapping overflow.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]]
constexpr auto wrap_sub(T lhs, U rhs) -> detail::promoted_type<T, U> {
    // Cast to a raw, unsigned, integer to guarantee wrapping semantics.
    using type = to_raw_arithmetic_type<make_unsigned_type<larger_type<T, U>>>;
    return detail::promoted_type<T, U>{static_cast<type>(lhs) -
                                       static_cast<type>(rhs)};
}

// Subtract two integers with saturating overflow.
template <is_raw_integral T>
[[nodiscard,
#ifndef __OPTIMIZED__
  gnu::optimize(2)
#endif
]]
constexpr auto sat_mul(T lhs, T rhs) -> T {
    T sum;
    bool overflow = __builtin_mul_overflow(lhs, rhs, &sum);
    if (overflow) {
        return limits<T>::max();
    }
    return sum;
}

// Erase redundant type information for `sat_mul()`.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]]
constexpr auto sat_mul(T lhs, U rhs) -> detail::promoted_type<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using type = to_raw_arithmetic_type<larger_type<T, U>>;
    return sat_mul(static_cast<type>(lhs), static_cast<type>(rhs));
}

// Multiply two integers with wrapping overflow.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]]
constexpr auto wrap_mul(T lhs, U rhs) -> detail::promoted_type<T, U> {
    // Cast to a raw, unsigned, integer to guarantee wrapping semantics.
    using type = to_raw_arithmetic_type<make_unsigned_type<larger_type<T, U>>>;
    return detail::promoted_type<T, U>{static_cast<type>(lhs) *
                                       static_cast<type>(rhs)};
}

// Subtract two integers with saturating overflow.
template <is_raw_integral T>
[[nodiscard,
#ifndef __OPTIMIZED__
  gnu::optimize(2)
#endif
]]
constexpr auto sat_div(T lhs, T rhs) -> T {
    if constexpr (is_signed<T>) {
        lhs += !((rhs + 1) | (make_unsigned(lhs) + limits<T>::max()));
    }
    // Unsigned integer division cannot overflow.
    return lhs / rhs;
}

// Erase redundant type information for `sat_mul()`.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]]
constexpr auto sat_div(T lhs, U rhs) -> detail::promoted_type<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using type = to_raw_arithmetic_type<larger_type<T, U>>;
    return sat_div(static_cast<type>(lhs), static_cast<type>(rhs));
}

// Divide two integers with wrapping overflow.
template <is_integral T, is_integral U>
    requires(is_safe_arithmetic_comparison<T, U>)
[[nodiscard]]
constexpr auto wrap_div(T lhs, U rhs) -> detail::promoted_type<T, U> {
    // Cast to a raw, unsigned, integer to guarantee wrapping semantics.
    using type = to_raw_arithmetic_type<make_unsigned_type<larger_type<T, U>>>;
    return detail::promoted_type<T, U>{static_cast<type>(lhs) /
                                       static_cast<type>(rhs)};
}

// Left bit-shifting two unsigned integers with saturating overflow.
template <is_raw_integral T, is_raw_integral U>
// TODO: Figure out signed saturating shift semantics.
    requires(is_unsigned<T>)
[[nodiscard,
#ifndef __OPTIMIZED__
  gnu::optimize(2)
#endif
]]
constexpr auto sat_shl(T value, U bits) {
    // TODO: Try `cat::countr_zero()`.
    if (bits >= limits<T>::bits - __builtin_ctz(value)) {
        return limits<T>::max();
    }
    return value << bits;
}

// Erase redundant type information for `sat_shl()`.
template <is_integral T, is_integral U>
[[nodiscard]]
constexpr auto sat_shl(T value, U bits) -> detail::promoted_type<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using type = to_raw_arithmetic_type<larger_type<T, U>>;
    return sat_shl(static_cast<type>(value), static_cast<type>(bits));
}

template <is_raw_integral T, is_raw_integral U>
// TODO: Figure out signed saturating shift semantics.
    requires(is_unsigned<T>)
[[nodiscard,
#ifndef __OPTIMIZED__
  gnu::optimize(2)
#endif
]]
constexpr auto sat_shr(T value, U bits) {
    // TODO: Try `cat::countl_zero()`.
    if (bits >= limits<T>::bits - __builtin_clz(value)) {
        return limits<T>::min();
    }
    return value >> bits;
}

// Erase redundant type information for `sat_shr()`.
template <is_integral T, is_integral U>
[[nodiscard]]
constexpr auto sat_shr(T value, U bits) -> detail::promoted_type<T, U> {
    // Saturating is_arithmetic inputs must be raw and cast to the same size.
    using type = to_raw_arithmetic_type<larger_type<T, U>>;
    return sat_shr(static_cast<type>(value), static_cast<type>(bits));
}

namespace detail {
    template <typename T, overflow_policies>
    struct arithmetic_storage {
        // This is the fallback when `T` is a floating point type.
        // Floats can't have sensible overflow semantics, except in some very
        // special cases.
        T raw;
    };

    // To prevent `arithmetic` holding a member of its own type, only undefined
    // overflow can access other overflow semantics.

    template <is_integral T>
    struct arithmetic_storage<T, overflow_policies::undefined> {
        union {
            T raw;
            arithmetic<T, overflow_policies::wrap_member> wrap;
            arithmetic<T, overflow_policies::saturate_member> sat;
            arithmetic<T, overflow_policies::trap_member> trap;
        };
    };

    template <is_integral T>
    struct arithmetic_storage<T, overflow_policies::wrap> {
        union {
            T raw;
            arithmetic<T, overflow_policies::saturate_member> sat;
            arithmetic<T, overflow_policies::trap_member> trap;
        };
    };

    template <is_integral T>
    struct arithmetic_storage<T, overflow_policies::saturate> {
        union {
            T raw;
            arithmetic<T, overflow_policies::wrap_member> wrap;
            arithmetic<T, overflow_policies::trap_member> trap;
        };
    };

    template <is_integral T>
    struct arithmetic_storage<T, overflow_policies::trap> {
        union {
            T raw;
            arithmetic<T, overflow_policies::wrap_member> wrap;
            arithmetic<T, overflow_policies::saturate_member> sat;
        };
    };

    template <is_integral T>
    struct arithmetic_storage<T, overflow_policies::wrap_member> {
        T raw;
    };

    template <is_integral T>
    struct arithmetic_storage<T, overflow_policies::saturate_member> {
        T raw;
    };

    template <is_integral T>
    struct arithmetic_storage<T, overflow_policies::trap_member> {
        T raw;
    };
}  // namespace detail

// TODO: Implement trapping overflow policy.
// `arithmetic` can represent an integer or floating point value. It prevents
// unsafe casts or operations. This is a trivial `struct` so it can be used as a
// non-type template parameter.
template <typename T, overflow_policies policy = overflow_policies::undefined>
struct arithmetic : detail::arithmetic_storage<T, policy> {
    using raw_type = T;

    // This constraint doesn't need to be SFINAE friendly, and it isn't obvious
    // how to refactor this so it is.
    static_assert(is_integral<T> || (policy == overflow_policies::undefined));

    constexpr arithmetic() = default;

    // Constructing with safe conversions is implicit, but constructing with
    // unsafe conversions is explicit.
    template <is_arithmetic U>
    constexpr explicit(!is_safe_arithmetic_conversion<U, T>)
        arithmetic(U other) {
        this->raw = to_raw_arithmetic(other);
    }

    template <typename U>
    constexpr explicit operator U() const {
        return static_cast<U>(this->raw);
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]]
    friend constexpr auto
    operator<=>(arithmetic<T, policy> lhs, U rhs) {
        return lhs.raw <=> to_raw_arithmetic(rhs);
    }

    // A `!=` operator is not generated by `<=>`, but overloading `!=` prevents
    // generating `==`. Instead, `==` is explicitly provided to generate `!=`.
    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]]
    friend constexpr auto
    operator==(arithmetic<T, policy> lhs, U rhs) -> bool {
        return lhs.raw == to_raw_arithmetic(rhs);
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    constexpr auto operator=(U operand) -> arithmetic& {
        this->raw = to_raw_arithmetic(operand);
        return *this;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]]
    friend constexpr auto
    operator+(arithmetic<T, policy> self, U operand)
        -> detail::promoted_type<T, U> {
        using enum overflow_policies;
        if constexpr (policy == undefined) {
            // Make signed to guarantee undefined semantics (unless the
            // is_arithmetic is floating point).
            return detail::promoted_type<T, U>{
                make_signed(self.raw) +
                make_signed(to_raw_arithmetic(operand))};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_add(to_raw_arithmetic(self),
                            to_raw_arithmetic(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_add(to_raw_arithmetic(self), to_raw_arithmetic(operand));
        }
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator+(U* p_operand, arithmetic<T, policy> numeral) -> U* {
        return p_operand + numeral.raw;
    }

    // Handle left-hand-side raw operands that are larger than this.
    template <is_unsafe_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    [[nodiscard]]
    friend constexpr auto
    operator+(U operand, arithmetic<T, policy> self)
        -> detail::promoted_type<T, U> {
        return cat::arithmetic<U>(operand) + self;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator+(arithmetic<T, policy> numeral, U* p_operand) -> U* {
        return numeral.raw + p_operand;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator+=(arithmetic<T, policy>& self, U operand)
        -> arithmetic& {
        self = self + to_raw_arithmetic(operand);
        return self;
    }

    [[nodiscard]]
    friend constexpr auto
    operator+(arithmetic<T, policy> self) -> arithmetic {
        return +(self.raw);
    }

    friend constexpr auto operator++(arithmetic<T, policy>& self)
        -> arithmetic& {
        self += static_cast<T>(1);
        return self;
    }

    friend constexpr auto operator++(arithmetic<T, policy>& self, int)
        -> arithmetic& {
        self += static_cast<T>(1);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]]
    friend constexpr auto
    operator-(arithmetic<T, policy> self, U operand)
        -> detail::promoted_type<T, U> {
        using enum overflow_policies;
        if constexpr (policy == undefined) {
            // TODO: See if using `[[assume()]]` actually optimizes this.
            if constexpr (is_unsigned<T>) {
                // Assume there is no overflow.
                // NOLINTNEXTLINE This is a C++23 feature.
                [[assume(self >= operand)]];
            }
            return detail::promoted_type<T, U>{self.raw -
                                               to_raw_arithmetic(operand)};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_sub(to_raw_arithmetic(self),
                            to_raw_arithmetic(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_sub(to_raw_arithmetic(self), to_raw_arithmetic(operand));
        }
    }

    // Handle left-hand-side raw operands that are larger than this.
    template <is_unsafe_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    [[nodiscard]]
    friend constexpr auto
    operator-(U operand, arithmetic<T, policy> self)
        -> detail::promoted_type<T, U> {
        return cat::arithmetic<U>(operand) - self;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator-(U* p_operand, arithmetic<T, policy> self) -> U* {
        return p_operand - self.raw;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator-(arithmetic<T, policy> numeral, U* p_operand) -> U* {
        return numeral.raw - p_operand;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    friend constexpr auto operator-=(arithmetic<T, policy>& self, U operand)
        -> arithmetic& {
        self = self - to_raw_arithmetic(operand);
        return self;
    }

    [[nodiscard]]
    friend constexpr auto
    operator-(arithmetic<T, policy> self) -> arithmetic
        requires(is_signed<T>)
    {
        return -(self.raw);
    }

    friend constexpr auto operator--(arithmetic<T, policy>& self)
        -> arithmetic& {
        self -= static_cast<T>(1);
        return self;
    }

    friend constexpr auto operator--(arithmetic<T, policy>& self, int)
        -> arithmetic& {
        self -= static_cast<T>(1);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]]
    friend constexpr auto
    operator*(arithmetic<T, policy> self, U operand)
        -> detail::promoted_type<T, U> {
        using enum overflow_policies;
        if constexpr (policy == overflow_policies::undefined) {
            // TODO: See if using `[[assume()]]` actually optimizes this.
            if constexpr (is_unsigned<T>) {
                // TODO: Figure out this overflow check.
                // Assume there is no overflow.
                // NOLINTNEXTLINE This is a C++23 feature.
                // [[assume(self >= operand)]];
            }
            return detail::promoted_type<T, U>{self.raw *
                                               to_raw_arithmetic(operand)};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_mul(to_raw_arithmetic(self),
                            to_raw_arithmetic(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_mul(to_raw_arithmetic(self), to_raw_arithmetic(operand));
        }
    }

    // Handle left-hand-side raw operands that are larger than this.
    template <is_unsafe_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    [[nodiscard]]
    friend constexpr auto
    operator*(U operand, arithmetic<T, policy> self)
        -> detail::promoted_type<T, U> {
        return cat::arithmetic<U>(operand) * self;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator*(U* p_operand, arithmetic<T, policy> self) -> U* {
        return p_operand * self.raw;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator*(arithmetic<T, policy> self, U* p_operand) -> U* {
        return p_operand * self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator*=(arithmetic<T, policy>& self, U operand)
        -> arithmetic& {
        self = self * to_raw_arithmetic(operand);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]]
    friend constexpr auto
    operator/(arithmetic<T, policy> self, U operand)
        -> detail::promoted_type<T, U> {
        using enum overflow_policies;
        if constexpr (policy == undefined) {
            // TODO: See if using `[[assume()]]` actually optimizes this.
            if constexpr (is_unsigned<T>) {
                // Assume there is no overflow.
                // NOLINTNEXTLINE This is a C++23 feature.
                [[assume(self >= operand)]];
            }
            return detail::promoted_type<T, U>{self.raw /
                                               to_raw_arithmetic(operand)};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_mul(to_raw_arithmetic(self),
                            to_raw_arithmetic(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_mul(to_raw_arithmetic(self), to_raw_arithmetic(operand));
        }
    }

    // Handle left-hand-side raw operands that are larger than this.
    template <is_unsafe_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    [[nodiscard]]
    friend constexpr auto
    operator/(U operand, arithmetic<T, policy> self)
        -> detail::promoted_type<T, U> {
        return cat::arithmetic<U>(operand) / self;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator/(U* p_operand, arithmetic<T, policy> self) -> U* {
        return p_operand / self.raw;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator/(arithmetic<T, policy> self, U* p_operand) -> U* {
        return p_operand / self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator/=(arithmetic<T, policy>& self, U operand)
        -> arithmetic& {
        self = self / to_raw_arithmetic(operand);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]]
    friend constexpr auto
    operator%(arithmetic<T, policy> self, U operand)
        -> detail::promoted_type<T, U> {
        return detail::promoted_type<T, U>{self.raw %
                                           to_raw_arithmetic(operand)};
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator%(U* p_operand, arithmetic<T, policy> self) -> U* {
        return p_operand % self.raw;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator%(arithmetic<T, policy> self, U* p_operand) -> U* {
        return p_operand % self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator%=(arithmetic<T, policy>& self, U operand)
        -> arithmetic& {
        self.raw %= to_raw_arithmetic(operand);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<T, U>)
    [[nodiscard]]
    friend constexpr auto
    operator&(arithmetic<T, policy> self, U operand)
        -> detail::promoted_type<T, U> {
        return detail::promoted_type<T, U>{self.raw &
                                           to_raw_arithmetic(operand)};
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator&(U* p_operand, arithmetic<T, policy> self) -> U* {
        return p_operand & self.raw;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator&(arithmetic<T, policy> self, U* p_operand) -> U* {
        return p_operand & self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator&=(arithmetic<T, policy>& self, U operand)
        -> arithmetic& {
        self.raw &= to_raw_arithmetic(operand);
        return self;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    [[nodiscard]]
    friend constexpr auto
    operator|(arithmetic<T, policy> self, U operand)
        -> detail::promoted_type<T, U> {
        return detail::promoted_type<T, U>{self.raw |
                                           to_raw_arithmetic(operand)};
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator|(U* p_operand, arithmetic<T, policy> self) -> U* {
        return p_operand | self.raw;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator|(arithmetic<T, policy> self, U* p_operand) -> U* {
        return p_operand | self.raw;
    }

    template <is_arithmetic U>
        requires(is_safe_arithmetic_comparison<U, T>)
    friend constexpr auto operator|=(arithmetic<T, policy>& self, U operand)
        -> arithmetic& {
        self.raw |= to_raw_arithmetic(operand);
        return self;
    }

    template <is_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator<<(arithmetic<T, policy> self, U operand) -> arithmetic<T> {
        if constexpr (policy == overflow_policies::saturate) {
            return sat_shl(to_raw_arithmetic(self), to_raw_arithmetic(operand));
        } else {
            return arithmetic<T>{self.raw << to_raw_arithmetic(operand)};
        }
    }

    template <is_raw_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator<<(U lhs, arithmetic<T, policy> rhs) -> U {
        return lhs << rhs.raw;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator<<(U* p_operand, arithmetic<T, policy> self) -> U* {
        return p_operand << self.raw;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator<<(arithmetic<T, policy> self, U* p_operand) -> U* {
        return p_operand << self.raw;
    }

    template <is_integral U>
    friend constexpr auto operator<<=(arithmetic<T, policy>& self, U operand)
        -> arithmetic& {
        self = self << to_raw_arithmetic(operand);
        return self;
    }

    template <is_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator>>(arithmetic<T, policy> self, U operand) -> arithmetic<T> {
        if constexpr (policy == overflow_policies::saturate) {
            return sat_shr(to_raw_arithmetic(self), to_raw_arithmetic(operand));
        } else {
            return arithmetic<T>{self.raw >> to_raw_arithmetic(operand)};
        }
    }

    template <is_raw_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator>>(U lhs, arithmetic<T, policy> rhs) -> U {
        return lhs >> rhs.raw;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator>>(U* p_operand, arithmetic<T, policy> self) -> U* {
        return p_operand >> self.raw;
    }

    template <typename U>
    [[nodiscard]]
    friend constexpr auto
    operator>>(arithmetic<T, policy> self, U* p_operand) -> U* {
        return p_operand >> self.raw;
    }

    template <is_integral U>
    friend constexpr auto operator>>=(arithmetic<T, policy>& self, U operand)
        -> arithmetic& {
        self = self >> to_raw_arithmetic(operand);
        return self;
    }

    [[nodiscard]]
    friend constexpr auto
    operator~(arithmetic<T, policy> self) -> arithmetic
        requires(is_integral<T>)
    {
        return ~(self.raw);
    }

    static constexpr auto min() -> arithmetic<raw_type, policy> {
        return limits<raw_type>::min();
    }

    static constexpr auto max() -> arithmetic<raw_type, policy> {
        return limits<raw_type>::max();
    }

    // `arithmetic` derives public storage from
    // `detail::arithmetic_storage`.
};

// `arithmetic_ptr` can be constructed from any integer type or any pointer.
// It can only convert into `T*`, but it is otherwise interchangeable with
// integers. It satisfies the `is_integral` type trait and
// `is_integral` concept.
template <typename T, typename storage_type,
          auto policy = overflow_policies::undefined>
struct arithmetic_ptr : arithmetic<storage_type, policy> {
  public:
    using raw_type = storage_type;
    using ptr = T*;

    constexpr arithmetic_ptr() = default;
    constexpr arithmetic_ptr(arithmetic_ptr<T, storage_type, policy> const&) =
        default;
    constexpr arithmetic_ptr(arithmetic_ptr<T, storage_type, policy>&&) =
        default;

    template <is_integral U>
        requires(is_safe_arithmetic_conversion<U, storage_type>)
    constexpr arithmetic_ptr(U other)
        : arithmetic<storage_type, policy>(to_raw_arithmetic(other)) {
    }

    constexpr arithmetic_ptr(T* p_input)
        : arithmetic<storage_type, policy>(
              reinterpret_cast<storage_type>(p_input)) {
    }

    // Allow explicitly constructing from another `arithmetic_ptr` with the
    // same `T`.
    template <is_arithmetic U, overflow_policies other_policy>
    constexpr explicit arithmetic_ptr(arithmetic_ptr<T, U, other_policy> other)
        : arithmetic<storage_type, policy>(to_raw_arithmetic(other)) {
    }

    // Only allow casting back into the original pointer type.
    constexpr explicit operator T*() {
        return reinterpret_cast<T*>(this->raw);
    }

    // Only allow casting back into the original pointer type.
    constexpr explicit operator T*() const {
        return reinterpret_cast<T const*>(this->raw);
    }

    constexpr explicit operator T const*() const {
        return reinterpret_cast<T const*>(this->raw);
    }

    // TODO: GCC 13 does not short-circuit this operator when `T` is `void`,
    // so this workaround using `conditional` is needed.

    [[nodiscard]]
    constexpr auto
    operator*() -> conditional<is_void<T>, int, T>&
        requires(!is_void<T>)
    {
        return *(reinterpret_cast<T*>(this->raw));
    }

    [[nodiscard]]
    constexpr auto
    operator->()
        -> T* requires(!is_void<T>) { return reinterpret_cast<T*>(this->raw); }

    // TODO: Streamline out all of these operators by implementing
    // `arithmetic`'s with "deducing this".

    // TODO: Cat assignment be `default`?
    // TODO: This redundant assignment operator is required by GCC.
    constexpr auto
    operator=(arithmetic_ptr<T, storage_type, policy> operand)
        -> arithmetic_ptr& {
        this->raw = operand.raw;
        return *this;
    }

    template <is_integral U>
        requires(is_safe_arithmetic_conversion<U, storage_type>)
    constexpr auto operator=(U operand) -> arithmetic_ptr& {
        this->raw = to_raw_arithmetic(operand);
        return *this;
    }

    template <typename U>
        requires(is_safe_arithmetic_comparison<storage_type, U>)
    [[nodiscard]]
    friend constexpr auto
    operator<=>(arithmetic_ptr<T, storage_type, policy> lhs, U rhs) {
        return lhs.raw <=> to_raw_arithmetic(rhs);
    }

    // A `!=` operator is not generated by `<=>`, but overloading `!=`
    // prevents generating `==`. Instead, `==` is explicitly provided to
    // generate `!=`.
    template <typename U>
        requires(is_safe_arithmetic_comparison<storage_type, U>)
    [[nodiscard]]
    friend constexpr auto
    operator==(arithmetic_ptr<T, storage_type, policy> lhs, U rhs) -> bool {
        return lhs.raw == to_raw_arithmetic(rhs);
    }

    // TODO: `requires` constraints on these operators makes GCC 13's
    // argument dependant lookup become ambiguous for some reason.

    template <is_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator+(arithmetic_ptr<T, storage_type, policy> self, U operand)
        -> arithmetic_ptr {
        return self.raw + to_raw_arithmetic(operand);
    }

    template <is_integral U>
    constexpr auto operator+=(U operand) {
        this->raw += to_raw_arithmetic(operand);
        return *this;
    }

    [[nodiscard]]
    friend constexpr auto
    operator+(arithmetic_ptr<T, storage_type, policy> self) -> arithmetic_ptr {
        return +(self.raw);
    }

    friend constexpr auto operator++(
        arithmetic_ptr<T, storage_type, policy>& self) -> arithmetic_ptr {
        return ++(self.raw);
    }

    friend constexpr auto operator++(
        arithmetic_ptr<T, storage_type, policy>& self, int) -> arithmetic_ptr {
        return (self.raw)++;
    }

    template <is_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator-(arithmetic_ptr<T, storage_type, policy> self, U operand)
        -> arithmetic_ptr {
        return self.raw - to_raw_arithmetic(operand);
    }

    // TODO: Make this `friend`.
    template <typename U>
    constexpr auto operator-=(U operand) -> arithmetic_ptr& {
        this->raw = this->raw - to_raw_arithmetic(operand);
        return *this;
    }

    [[nodiscard]]
    friend constexpr auto
    operator-(arithmetic_ptr<T, storage_type, policy> self) -> arithmetic_ptr {
        return -(self.raw);
    }

    friend constexpr auto operator--(
        arithmetic_ptr<T, storage_type, policy>& self) -> arithmetic_ptr& {
        return --(self.raw);
    }

    friend constexpr auto operator--(
        arithmetic_ptr<T, storage_type, policy>& self, int) -> arithmetic_ptr& {
        return (self.raw)--;
    }

    template <is_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator*(arithmetic_ptr<T, storage_type, policy> self, U operand)
        -> arithmetic_ptr {
        return self.raw * to_raw_arithmetic(operand);
    }

    template <typename U>
    constexpr auto operator*=(U operand) -> arithmetic_ptr& {
        this->raw = this->raw * to_raw_arithmetic(operand);
        return *this;
    }

    template <is_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator/(arithmetic_ptr<T, storage_type, policy> self, U operand)
        -> arithmetic_ptr {
        return self.raw / to_raw_arithmetic(operand);
    }

    template <typename U>
    constexpr auto operator/=(U operand) -> arithmetic_ptr& {
        this->raw = this->raw / to_raw_arithmetic(operand);
        return *this;
    }

    template <is_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator%(arithmetic_ptr<T, storage_type, policy> self, U operand)
        -> arithmetic_ptr<T, storage_type, policy> {
        return self.raw % to_raw_arithmetic(operand);
    }

    template <typename U>
    constexpr auto operator%=(U operand) -> arithmetic_ptr& {
        this->raw = this->raw % to_raw_arithmetic(operand);
        return *this;
    }

    template <is_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator&(arithmetic_ptr<T, storage_type, policy> self, U operand)
        -> arithmetic_ptr<T, storage_type, policy> {
        return self.raw & to_raw_arithmetic(operand);
    }

    template <typename U>
    constexpr auto operator&=(U operand) -> arithmetic_ptr& {
        this->raw = this->raw & to_raw_arithmetic(operand);
        return *this;
    }

    template <is_integral U>
    [[nodiscard]]
    friend constexpr auto
    operator|(arithmetic_ptr<T, storage_type, policy> self, U operand)
        -> arithmetic_ptr<T, storage_type, policy> {
        return self.raw | to_raw_arithmetic(operand);
    }

    // TODO: Make more of these hidden `friend`s.

    template <typename U>
    constexpr auto operator|=(U operand) -> arithmetic_ptr& {
        this->raw = this->raw | to_raw_arithmetic(operand);
        return *this;
    }

    template <is_integral U>
    [[nodiscard]]
    constexpr auto
    operator<<(U operand) const -> arithmetic_ptr<T, storage_type, policy> {
        return static_cast<storage_type>(this->raw
                                         << to_raw_arithmetic(operand));
    }

    template <is_integral U>
    constexpr auto operator<<=(U operand) -> arithmetic_ptr& {
        this->raw = this->raw << to_raw_arithmetic(operand);
        return *this;
    }

    template <is_integral U>
    [[nodiscard]]
    constexpr auto
    operator>>(U operand) const -> arithmetic_ptr<T, storage_type, policy> {
        return static_cast<storage_type>(this->raw >>
                                         to_raw_arithmetic(operand));
    }

    template <is_integral U>
    constexpr auto operator>>=(U operand) -> arithmetic_ptr& {
        this->raw = this->raw >> to_raw_arithmetic(operand);
        return *this;
    }

    [[nodiscard]]
    constexpr auto
    operator~() -> arithmetic_ptr {
        return ~(this->raw);
    }
};

// `__INTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using intptr = arithmetic_ptr<T, __INTPTR_TYPE__>;

// `__UINTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using uintptr = cat::arithmetic_ptr<T, __UINTPTR_TYPE__>;

// Add and assign an `arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator+=(T* p_lhs, arithmetic<U> rhs) -> T* {
    p_lhs += rhs.raw;
    return p_lhs;
}

// Subtract and assign an `arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator-=(T* p_lhs, arithmetic<U> rhs) -> T* {
    p_lhs -= rhs.raw;
    return p_lhs;
}

// Multiply and assign an `arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator*=(T* p_lhs, arithmetic<U> rhs) -> T* {
    p_lhs *= rhs.raw;
    return p_lhs;
}

// Divide and assign an `arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator/=(T* p_lhs, arithmetic<U> rhs) -> T* {
    p_lhs /= rhs.raw;
    return p_lhs;
}

// Bitwise shift left and assign an `arithmetic` to a pointer.
template <typename T, is_integral U>
constexpr auto operator<<=(T* p_lhs, arithmetic<U> rhs) -> T* {
    p_lhs <<= rhs.raw;
    return p_lhs;
}

// Bitwise shift right and assign an `arithmetic` to a pointer.
template <typename T, is_integral U>
constexpr auto operator>>=(T* p_lhs, arithmetic<U> rhs) -> T* {
    p_lhs >>= rhs.raw;
    return p_lhs;
}

// Bitwise modulo and assign an `arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator%=(T* p_lhs, arithmetic<U> rhs) -> T* {
    p_lhs %= rhs.raw;
    return p_lhs;
}

// Bitwise and and assign an `arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator&=(T* p_lhs, arithmetic<U> rhs) -> T* {
    p_lhs &= rhs.raw;
    return p_lhs;
}

// Bitwise or and assign an `arithmetic` to a pointer.
template <typename T, typename U>
constexpr auto operator|=(T* p_lhs, arithmetic<U> rhs) -> T* {
    p_lhs |= rhs.raw;
    return p_lhs;
}

template <ssize bytes>
    requires(bytes <= 8 && bytes > 0 &&
             // Is a power of 2:
             ((bytes & (bytes - 1)) == 0))
using int_fixed = conditional<
    bytes == 1, int1,
    conditional<bytes == 2, int2, conditional<bytes == 4, int4, int8>>>;

template <ssize bytes>
    requires(bytes <= 8 && bytes > 0 &&
             // Is a power of 2:
             ((bytes & (bytes - 1)) == 0))
using uint_fixed = conditional<
    bytes == 1, uint1,
    conditional<bytes == 2, uint2, conditional<bytes == 4, uint4, uint8>>>;

struct bool2 {
    using raw_type = uint2;
    uint2 raw;
    constexpr bool2() = default;

    constexpr bool2(bool input) : raw(static_cast<unsigned char>(input)) {
    }

    constexpr operator bool() const {
        return this->raw != 0u;
    }
};

struct bool4 {
    using raw_type = uint4;
    uint4 raw;
    constexpr bool4() = default;

    constexpr bool4(bool input) : raw(static_cast<unsigned char>(input)) {
    }

    constexpr bool4(bool2 input) : raw(static_cast<unsigned char>(input)) {
    }

    constexpr operator bool() const {
        return this->raw != 0u;
    }
};

inline constexpr int1 int1_min = limits<int1>::min();
inline constexpr int1 int1_max = limits<int1>::max();
inline constexpr uint1 uint1_min = limits<uint1>::min();
inline constexpr uint1 uint1_max = limits<uint1>::max();
inline constexpr int2 int2_min = limits<int2>::min();
inline constexpr int2 int2_max = limits<int2>::max();
inline constexpr uint2 uint2_min = limits<uint2>::min();
inline constexpr uint2 uint2_max = limits<uint2>::max();
inline constexpr int4 int4_min = limits<int4>::min();
inline constexpr int4 int4_max = limits<int4>::max();
inline constexpr uint4 uint4_min = limits<uint4>::min();
inline constexpr uint4 uint4_max = limits<uint4>::max();
inline constexpr int8 int8_min = limits<int8>::min();
inline constexpr int8 int8_max = limits<int8>::max();
inline constexpr uint8 uint8_min = limits<uint8>::min();
inline constexpr uint8 uint8_max = limits<uint8>::max();

inline namespace literals {
    inline namespace arithmetic_literals {
        constexpr auto operator""_i1(unsigned long long input) -> cat::int1 {
            return cat::int1{input};
        }

        constexpr auto operator""_i2(unsigned long long input) -> cat::int2 {
            return cat::int2{input};
        }

        constexpr auto operator""_i4(unsigned long long input) -> cat::int4 {
            return cat::int4{input};
        }

        constexpr auto operator""_i8(unsigned long long input) -> cat::int8 {
            return cat::int8{input};
        }

        constexpr auto operator""_sz(unsigned long long input) -> cat::ssize {
            return cat::ssize{input};
        }

        constexpr auto operator""_u1(unsigned long long input) -> cat::uint1 {
            return cat::uint1{input};
        }

        constexpr auto operator""_u2(unsigned long long input) -> cat::uint2 {
            return cat::uint2{input};
        }

        constexpr auto operator""_u4(unsigned long long input) -> cat::uint4 {
            return cat::uint4{input};
        }

        constexpr auto operator""_u8(unsigned long long input) -> cat::uint8 {
            return cat::uint8{input};
        }

        constexpr auto operator""_uz(unsigned long long input) -> cat::usize {
            return cat::usize{input};
        }

        constexpr auto operator""_f4(unsigned long long input) -> cat::float4 {
            return cat::float4{input};
        }

        constexpr auto operator""_f4(long double input) -> cat::float4 {
            return cat::float4{input};
        }

        constexpr auto operator""_f8(unsigned long long input) -> cat::float8 {
            return cat::float8{input};
        }

        constexpr auto operator""_f8(long double input) -> cat::float8 {
            return cat::float8{input};
        }
    }  // namespace arithmetic_literals
}  // namespace literals
}  // namespace cat

// Arithmetic wrappers should be in the global namespace for convenience.
using cat::bool2;
using cat::bool4;
using cat::float4;
using cat::float8;
using cat::int1;
using cat::int2;
using cat::int4;
using cat::int8;
using cat::ssize;
using cat::uint1;
using cat::uint2;
using cat::uint4;
using cat::uint8;
using cat::usize;

template <typename T>
using intptr = cat::intptr<T>;
template <typename T>
using uintptr = cat::uintptr<T>;

// `intptr` and `uintptr` are not trivial, but they can be trivially
// relocatable.
template <typename T>
    requires(cat::is_trivial<T> || cat::is_void<T>)
constexpr bool cat::is_trivially_relocatable<cat::intptr<T>> = true;
template <typename T>
    requires(cat::is_trivial<T> || cat::is_void<T>)
constexpr bool cat::is_trivially_relocatable<cat::uintptr<T>> = true;
