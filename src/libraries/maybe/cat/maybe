// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/match>
#include <cat/memory>
#include <cat/utility>

namespace cat {
namespace detail {
    // A `nullopt_type` is consumed by an `maybe` constructor to prevent
    // initializing its `value` member.
    struct nullopt_type {};
}  // namespace detail

// `nullopt` is consumed by `maybe` to represent an empty value.
inline constexpr detail::nullopt_type nullopt;

// Forward declarations.
template <typename T>
class maybe;

class string;

// `maybe_value_storage` holds a non-reference, non-pointer, non-`void` type
// `T` and a `bool` flag to represent holding a value or not.
template <typename T>
struct maybe_value_storage {
    using value_type = T;

    constexpr maybe_value_storage() : dummy{} {
    }

    // If `T` is forwarded arguments by the `in_place` `maybe`
    // constructor, then construct it in-place with those arguments.
    template <typename... Args>
    constexpr maybe_value_storage(Args... args) {
        this->construct(args...);
    }

    // If `T` is trivially copy-constructible, use this simple copy constructor.
    constexpr maybe_value_storage(T const& in_value) requires(
        is_trivially_copy_constructible<T>)
        : storage(in_value), has_some(true) {
    }

    // If `T` is not trivially copy-constructible, then manually construct it
    // in-place.
    constexpr maybe_value_storage(T const& in_value) requires(
        is_copy_constructible<T> && !is_trivially_copy_constructible<T>) {
        this->construct(in_value);
    }

    // If `T` is not copy-constructible, delete this copy constructor.
    constexpr maybe_value_storage(T const& in_value) requires(
        !is_copy_constructible<T>) = delete;

    // If `T` is trivially move-constructible, use this simple move constructor.
    constexpr maybe_value_storage(T&& in_value) requires(
        is_trivially_move_constructible<T>)
        : storage(forward<T>(in_value)), has_some(true) {
    }

    // If `T` is not trivially move-constructible, then manually invoke
    // `move` on it.
    constexpr maybe_value_storage(T&& in_value) requires(
        is_move_constructible<T> && !is_trivially_move_constructible<T>) {
        // TODO: Should this be a `move`?
        this->construct(forward<T>(in_value));
        this->has_some = true;
    }

    // If `T` is not move-constructible, delete this move constructor.
    constexpr maybe_value_storage(T&& in_value) requires(
        !is_move_constructible<T>) = delete;

    // `nullopt` initializes this without a value.
    constexpr maybe_value_storage(detail::nullopt_type) : dummy{} {
    }

    // If other destructors are not conditionally specialized by their
    // `requires`, they should be `default` or deleted.
    constexpr ~maybe_value_storage() = default;

    // If `T` is not trivially destructible, then manually invoke its
    // destructor.
    constexpr ~maybe_value_storage() requires(!is_trivially_destructible<T>) {
        if constexpr (requires { this->storage.~T(); }) {
            if (this->has_some) {
                this->storage.~T();
                this->has_some = false;
            }
        }
    }

    // If `T` is trivially copy-assignable, then forward this value.
    constexpr auto operator=(T const& in_value)
        -> maybe_value_storage& requires(is_trivially_copy_assignable<T>) {
        this->storage = in_value;
        this->has_some = true;
        return *this;
    }

    // If `T` is non-trivially copy-assignable, then manually construct it
    // in-place.
    constexpr auto operator=(T const& in_value)
        -> maybe_value_storage& requires(is_copy_assignable<T> &&
                                         !is_trivially_copy_assignable<T>) {
        this->assign(in_value);
        return *this;
    }

    // If `T` is not copy-assignable, delete this assignment operator to prevent
    // ambiguous overload resolution.
    constexpr auto operator=(T const& in_value)
        -> maybe_value_storage& requires(!is_copy_assignable<T>) = delete;

    // If `T` is trivially move-assignable, then forward this value.
    constexpr auto operator=(T&& in_value)
        -> maybe_value_storage& requires(is_trivially_move_assignable<T>) {
        this->storage = forward<T>(in_value);
        this->has_some = true;
        return *this;
    }

    // If `T` is non-trivially move-assignable, then manually invoke
    // `move()` on it.
    constexpr auto operator=(T&& in_value)
        -> maybe_value_storage& requires(is_move_assignable<T> &&
                                         !is_trivially_move_assignable<T>) {
        this->assign(forward<T>(in_value));
        return *this;
    }

    // If `T` is not move-assignable, delete this assignment operator to prevent
    // ambiguous overload resolution.
    constexpr auto operator=(T&& in_value)
        -> maybe_value_storage& requires(!is_move_assignable<T>) = delete;

    // The following methods are homogenous to all `maybe...storage_type` types.
    constexpr auto value() & -> T& {
        return this->storage;
    }

    constexpr auto value() const& -> T const& {
        return this->storage;
    }

    constexpr auto value() && -> T&& {
        return move(this->storage);
    }

    constexpr auto value() const&& -> T&& {
        return move(this->storage);
    }

    constexpr auto has_value() const -> bool {
        return has_some;
    }

    // Destroy the storage unconditionally.
    constexpr void hard_reset() {
        this->storage.~T();
        this->has_some = false;
    }

    // Construct an object at the address of the held `storage`.
    template <typename... Args>
    constexpr void construct(Args&&... args) {
        construct_at(addressof(this->storage), forward<Args>(args)...);
        this->has_some = true;
    }

    // If this is assigned an `maybe` which wraps a type that can be
    // converted to `T` , then convert that storage to this type implicitly.
    template <typename Othermaybe>
    constexpr void assign(Othermaybe&& maybe) {
        if (this->has_value()) {
            if (maybe.has_value()) {
                this->storage = forward<Othermaybe>(maybe).value();
            } else {
                // If the incoming `maybe` is empty, then empty this one.
                this->hard_reset();
            }
        } else {
            if (maybe.has_value()) {
                this->construct(maybe.value());
            }
            // If both `maybe`s are empty, nothing happens.
        }
    }

    // A `union` member will not be default-constructed.
    union {
        // `dummy` is initialized in a `constexpr` context by both the default
        // and the `nullopt` constructors. This prevents `T`'s default
        // constructor from being called there. One member must be initialized
        // in a `constexpr` context. If `T` is trivial, a dummy member is not
        // required.
        monostate_type dummy;
        T storage;
    };
    bool has_some = false;
};

template <typename T>
struct maybe_reference_storage {
    using value_type = T;

    template <typename U>
    constexpr maybe_reference_storage(U& in_value)
        : p_storage(addressof(in_value)) {
    }

    constexpr maybe_reference_storage(detail::nullopt_type)
        : p_storage(nullptr) {
    }

    // Rebind the reference if this is assigned a new value.
    constexpr auto operator=(value_type& option) -> maybe_reference_storage& {
        this->p_storage = addressof(option);
        return *this;
    }

    // The following methods are homogenous to all `maybe...storage_type` types.
    constexpr auto value() & -> value_type {
        return *(this->p_storage);
    }

    constexpr auto value() const& -> value_type {
        return *(this->p_storage);
    }

    constexpr auto value() && -> value_type {
        return *(move(this->p_storage));
    }

    constexpr auto value() const&& -> value_type {
        return *(move(this->p_storage));
    }

    constexpr auto has_value() const -> bool {
        return this->p_storage != nullptr;
    }

    // Destroy the storage unconditionally.
    constexpr void hard_reset() {
        this->p_storage->~remove_reference<value_type>();
        this->p_storage = nullptr;
    }

    // Construct an object at the address of the held `storage`.
    template <typename... Args>
    constexpr void construct(Args&&... args) {
        construct_at(this->p_storage, forward<Args>(args)...);
        cat::assert(this->has_value());
    }

    // If this is assigned an `maybe` which wraps a type that can be
    // converted to `T` , then convert that storage to this type implicitly.
    template <typename Othermaybe>
    constexpr void assign(Othermaybe&& maybe) {
        if (this->has_value()) {
            // If this `maybe` has a value, then empty it.
            this->hard_reset();
        }

        if (maybe.has_value()) {
            this->p_storage = forward<Othermaybe>(maybe).p_value();
        } else {
            // If both `maybe`s are empty, nothing happens.
        }
    }

    remove_reference<T>* p_storage = nullptr;
};

// `T` is a `predicate<type, function, sentinel>`.
template <typename T>
struct maybe_compact_storage {
    using value_type = typename T::type;

    constexpr maybe_compact_storage() = default;

    // Enable copy and move constructors iff `maybe_compact_storage`
    // supports them.

    // If `value_type` is trivially copy-constructible, use this simple copy
    // constructor.
    constexpr maybe_compact_storage(value_type const& in_value) requires(
        is_trivially_copy_constructible<value_type>)
        : storage(in_value) {
    }

    // If `value_type` is not trivially copy-constructible, then manually
    // construct it in-place.
    constexpr maybe_compact_storage(value_type const& in_value) requires(
        is_copy_constructible<value_type> &&
        !is_trivially_copy_constructible<value_type>) {
        this->construct(in_value);
    }

    // If `value_type` is not copy-constructible, delete this copy constructor.
    constexpr maybe_compact_storage(value_type const& in_value) requires(
        !is_copy_constructible<value_type>) = delete;

    // If `value_type` is trivially move-constructible, use this simple move
    // constructor.
    constexpr maybe_compact_storage(value_type&& in_value) requires(
        is_trivially_move_constructible<value_type>)
        : storage(forward<value_type>(in_value)) {
    }

    // If `value_type` is not trivially move-constructible, then manually invoke
    // `move` on it.
    constexpr maybe_compact_storage(value_type&& in_value) requires(
        is_move_constructible<value_type> &&
        !is_trivially_move_constructible<value_type>) {
        this->construct(forward<value_type>(in_value));
    }

    // If `value_type` is not move-constructible, delete this move constructor.
    constexpr maybe_compact_storage(value_type&& in_value) requires(
        !is_move_constructible<value_type>) = delete;

    // If other destructors are not conditionally specialized by their
    // `requires`, they should be `default` or deleted.
    constexpr ~maybe_compact_storage() = default;

    // If `value_type` is not trivially destructible, then manually invoke its
    // destructor.
    constexpr ~maybe_compact_storage() requires(
        !is_trivially_destructible<value_type>) {
        if constexpr (requires { this->storage.~value_type(); }) {
            if (this->has_value()) {
                this->storage.~value_type();
            }
        }
    }

    constexpr maybe_compact_storage(detail::nullopt_type)
        : storage(T::sentinel_value) {
    }

    // If other assignment operators are not conditionally specialized by
    // their `requires`, they should be `default` or deleted.

    // If `value_type` is trivially copy-assignable, then forward this value.
    constexpr auto operator=(value_type const& in_value)
        -> maybe_compact_storage& requires(
            is_trivially_copy_assignable<value_type>) {
        this->storage = in_value;
        return *this;
    }

    // If `value_type` is non-trivially copy-assignable, then manually construct
    // it in-place.
    constexpr auto operator=(value_type const& in_value)
        -> maybe_compact_storage& requires(
            is_copy_assignable<value_type> &&
            !is_trivially_copy_assignable<value_type>) {
        this->assign(in_value);
        return *this;
    }

    // If `value_type` is not copy-assignable, delete this assignment operator
    // to prevent ambiguous overload resolution.
    constexpr auto operator=(value_type const& in_value)
        -> maybe_compact_storage& requires(!is_copy_assignable<value_type>) =
        delete;

    // If `value_type` is trivially move-assignable, then forward this value.
    constexpr auto operator=(value_type&& in_value)
        -> maybe_compact_storage& requires(
            is_trivially_move_assignable<value_type>) {
        this->storage = forward<value_type>(in_value);
        return *this;
    }

    // If `value_type` is non-trivially move-assignable, then manually invoke
    // `move()` on it.
    constexpr auto operator=(value_type&& in_value)
        -> maybe_compact_storage& requires(
            is_move_assignable<value_type> &&
            !is_trivially_move_assignable<value_type>) {
        this->assign(forward<value_type>(in_value));
        return *this;
    }

    // If `value_type` is not move-assignable, delete this assignment operator
    // to prevent ambiguous overload resolution.
    constexpr auto operator=(value_type&& in_value)
        -> maybe_compact_storage& requires(!is_move_assignable<value_type>) =
        delete;

    // The following methods are homogenous to all `maybe...storage_type`
    // types.
    constexpr auto value() & -> value_type& {
        return this->storage;
    }

    constexpr auto value() const& -> value_type const& {
        return this->storage;
    }

    constexpr auto value() && -> value_type&& {
        return move(this->storage);
    }

    constexpr auto value() const&& -> value_type&& {
        return move(this->storage);
    }

    constexpr auto has_value() const -> bool {
        return T::predicate_function(this->storage);
    }

    // Destroy the storage unconditionally.
    constexpr void hard_reset() {
        this->storage.~value_type();
        this->storage = T::sentinel_value;
    }

    // Construct an object at the address of the held `storage`.
    template <typename... Args>
    constexpr void construct(Args&&... args) {
        construct_at(addressof(this->storage), forward<Args>(args)...);
    }

    // If this is assigned an `maybe` which wraps a type that can be
    // converted to `T` , then convert that storage to this type implicitly.
    template <typename Othermaybe>
    constexpr void assign(Othermaybe&& maybe) {
        if (this->has_value()) {
            if (maybe.has_value()) {
                this->storage = forward<Othermaybe>(maybe).value();
            } else {
                // If the incoming `maybe` is empty, then empty this one.
                this->hard_reset();
            }
        } else {
            if (maybe.has_value()) {
                this->construct(maybe.value());
            }
            // If both `maybe`s are empty, nothing happens.
        }
    }

    // A `union` member will not be default-constructed.
    union {
        monostate_type dummy;
        value_type storage;
    };
};

template <typename T>
class maybe {
  private:
    // clang-format off
    // Clang Format 12 does not understand how to format this well:
    using storage_type =
        conditional<is_void<T>,
            // If `T` is `void`:
            maybe_value_storage<monostate_type>,
		conditional<requires {
                   // T::predicate_function(T::type());
                    T::sentinel_value;
                },
                // If `T` is a `predicate`:
                maybe_compact_storage<T>,
		conditional<is_reference<T>,
                    // If `T` is a reference type:
                    maybe_reference_storage<T>,
                    // If `T` is a value type:
                    maybe_value_storage<T>>>>;
    // clang-format on

  public:
    using value_type = typename storage_type::value_type;

    // All `maybe`s are default-constructed as empty.
    constexpr maybe() : storage(nullopt) {
    }

    // `maybe`s can be constructed with `in_place` to have their storage
    // constructed, unless they are reference types. Without this tag, the
    // storage would be uninitialized.
    template <typename... Args>
        requires(!is_reference<value_type>)
    constexpr maybe(in_place_type, Args... args) {
        this->storage.construct(args...);
    }

    // Forward all constructors to the `storage` member.

    // A reference type cannot be copy-constructed, but other types can.
    template <typename U>
        requires(!is_reference<value_type> &&
                 is_implicitly_convertible<U, value_type> &&
                 is_copy_constructible<value_type>)
    constexpr maybe(U& input) : storage(static_cast<value_type>(input)) {
    }

    template <typename U>
        requires(!is_reference<value_type> &&
                 is_implicitly_convertible<U, value_type> &&
                 is_copy_constructible<value_type>)
    constexpr maybe(U const& input) : storage(static_cast<value_type>(input)) {
    }

    // Produce an error message if `value_type` is not copy-constructible.
    template <typename U>
        requires(!is_reference<value_type> &&
                 is_implicitly_convertible<U, value_type> &&
                 !is_copy_constructible<value_type>)
    constexpr maybe(U const& input) = delete;

    // Rebinding converting reference constructor.
    template <typename U>
        requires(is_reference<value_type>&& is_implicitly_convertible<
                 add_lvalue_reference<U>, value_type>)
    constexpr maybe(U& input) : storage(static_cast<value_type>(input)) {
    }

    // Perfect forwarding constructor.
    template <rvalue U>
        requires(!is_reference<value_type> &&
                 is_implicitly_convertible<U, value_type>)
    // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
    constexpr maybe(U&& input) : storage(forward<U>(input)) {
    }

    // `maybe` can be constructed by another `maybe`.
    template <typename U>
        requires(is_implicitly_convertible<U, value_type>)
    constexpr maybe(maybe<U>& input) {
        this->storage.assign(input);
    }

    template <typename U>
        requires(is_implicitly_convertible<U, value_type>)
    constexpr maybe(maybe<U> const& input) {
        this->storage.assign(input);
    }

    template <typename U>
        requires(is_implicitly_convertible<U, value_type>)
    constexpr maybe(maybe<U>&& input) {
        this->storage.assign(move(input));
    }

    // Consuming `nullopt` is forwarded to `storage`.
    constexpr maybe(detail::nullopt_type) : storage(nullopt) {
    }

    // Consuming `monostate` default-initializes the `maybe`.
    constexpr maybe(monostate_type) requires(is_void<value_type>)
        : storage(value_type()) {
    }

    // Any `maybe` can convert into another.
    template <typename U>
        requires(!is_same<U, T> && is_implicitly_convertible<value_type, U>)
    constexpr operator maybe<U>() {
        if (this->has_value()) {
            if constexpr (is_same<U, void>) {
                return monostate;
            } else {
                return maybe<U>{
                    static_cast<typename maybe<U>::value_type>(this->value())};
            }
        }
        return maybe<U>{nullopt};
    }

    // Forward all assignment operators to `storage`, except when assigning
    // `nullopt`. They should convert any implicitly convertible type into
    // `value_type`.

    // Non-reference converting copy assignment operator.
    template <typename U>
        requires(is_implicitly_convertible<U, value_type> &&
                 !is_reference<value_type> && is_copy_assignable<value_type>)
    constexpr auto operator=(U const& value) -> class maybe& {
        this->storage = static_cast<value_type const&>(value);
        return *this;
    }

    // Non-reference converting move assignment operator.
    template <typename U>
        requires(is_implicitly_convertible<U, value_type> &&
                 !is_reference<value_type> && is_move_assignable<value_type>)
    constexpr auto operator=(U&& value) -> class maybe& {
        this->storage = static_cast<value_type&&>(forward<U>(value));
        return *this;
    }

    // Rebinding converting reference assignment operator.
    template <typename U>
        requires(
            (is_implicitly_convertible<add_lvalue_reference<U>,
                                       value_type>)&&is_reference<value_type>)
    constexpr auto operator=(U& value) -> class maybe& {
        this->storage = static_cast<value_type&>(value);
        return *this;
    }

    // Rebinding converting `maybe` copy assignment operator.
    template <typename U>
        requires(is_implicitly_convertible<U, value_type> &&
                 !is_reference<value_type> && !is_reference<U>)
    constexpr auto operator=(maybe<U> const& maybe) -> class maybe& {
        this->storage.assign(maybe);
        return *this;
    }

    // Rebinding converting `maybe` move assignment operator.
    template <typename U>
        requires(is_implicitly_convertible<U, value_type>&&
                     is_move_assignable<value_type>)
    constexpr auto operator=(maybe<U>&& maybe) -> class maybe& {
        this->storage.assign(move(maybe));
        return *this;
    }

    // Rebinding converting `maybe` reference assignment operator.
    template <typename U>
        requires(is_implicitly_convertible<U, value_type>)
    constexpr auto operator=(maybe<U>& maybe) -> class maybe& {
        this->storage.assign(maybe);
        return *this;
    }

    // Assigning `nullopt` destroys any value.
    constexpr auto operator=(detail::nullopt_type) -> class maybe& {
        this->storage.hard_reset();
        return *this;
    }

    [[nodiscard]] constexpr auto has_value() const -> bool {
        return this->storage.has_value();
    }

    // Holds true if this `maybe` currently has some value of the type `T`.
    // This method allows `maybe` to be used in `match` statements.
    template <typename U>
    [[nodiscard]] constexpr auto is() const -> bool {
        // Since this storage can only hold either `value_type` or `nullopt`,
        // this can be expressed in terms of `.has_value()`.
        if constexpr (is_same<U, value_type>) {
            return this->has_value();
        } else {
            return false;
        }
    }

    // Member access syntax pattern matching for `cat::match()`.
    template <typename... Patterns>
        requires(is_specialization<Patterns, detail::pattern_invocable>&&...)
    constexpr void match(Patterns&&... patterns) {
        detail::match_patterns (*this)(forward<Patterns>(patterns)...);
    }

    // Holds true if this `maybe` currently has some value convertible and
    // equivalent to `in_value`. This method allows `maybe` to be used in
    // `match` statements.
    template <typename U>
        requires(is_convertible<U, value_type>)
    [[nodiscard]] constexpr auto is(U&& in_value) const -> bool {
        if (this->has_value()) {
            return static_cast<value_type>(forward<U>(in_value)) ==
                   this->value();
        }
        return false;
    }

    // Special overload for `nullopt`.
    [[nodiscard]] constexpr auto is(detail::nullopt_type) const -> bool {
        return !this->has_value();
    }

    // Get the `storage` unconditionally.
    [[nodiscard]] constexpr auto value() & -> value_type& {
        return this->storage.value();
    }

    // Get the const-qualified `storage` unconditionally.
    [[nodiscard]] constexpr auto value() const& -> value_type const& {
        return this->storage.value();
    }

    // Move the `storage` unconditionally. Reference types cannot be moved.
    [[nodiscard]] constexpr auto value() && -> value_type&& requires(
        !is_reference<value_type>) {
        return move(this->storage.value());
    }

    // Move the const-qualified `storage` unconditionally. Reference types
    // cannot be moved.
    [[nodiscard]] constexpr auto value() const&& -> value_type const&& requires(
        !is_reference<value_type>) {
        return move(this->storage.value());
    }

    // Get the value held by a non-`const`-qualified `maybe`, or a
    // fallback value if it does not hold a value.
    [[nodiscard]] constexpr auto value_or(value_type fallback) & -> value_type {
        if (this->storage.has_value()) {
            return this->storage.value();
        }
        return fallback;
    }

    // Get the value held by a `const`-qualified `maybe`, or a fallback
    // value if it does not hold a value.
    [[nodiscard]] constexpr auto value_or(
        value_type fallback) const& -> value_type {
        if (this->storage.has_value()) {
            return this->storage.value();
        }
        return fallback;
    }

    // Get the value held by a non-`const`-qualified `maybe`, or a
    // fallback value if it does not hold a value.
    [[nodiscard]] constexpr auto value_or(
        value_type&& fallback) && -> value_type&& {
        if (this->storage.has_value()) {
            return move(this->storage).value();
        }
        return move(fallback);
    }

    // Get the value held by a `const`-qualified `maybe`, or a fallback
    // value if it does not hold a value.
    [[nodiscard]] constexpr auto value_or(
        value_type&& fallback) const&& -> value_type&& {
        if (this->storage.has_value()) {
            return move(this->storage).value();
        }
        return move(fallback);
    }

    // Get a pointer to the data owned by this `maybe`. If `maybe`
    // holds a raw pointer, this is equivalent to `.value()`, otherwise this
    // is equivalent to `addressof(maybe.value())`.
    [[nodiscard]] constexpr auto p_value() {
        if constexpr (is_pointer<value_type>) {
            return this->storage.value();
        } else {
            return addressof(this->storage.value());
        }
    }

    // Get a pointer to the data owned by this `maybe`. If `maybe`
    // holds a raw pointer, this is equivalent to `.value()`, otherwise this
    // is equivalent to `addressof(maybe.value())`.
    [[nodiscard]] constexpr auto p_value() const {
        if constexpr (is_pointer<value_type>) {
            return this->storage.value();
        } else {
            return addressof(this->storage.value());
        }
    }

    // TODO: Add `&&` overloads to the `.assert()` and `.verify()` getters.
    // TODO: Make the `.assert()` and `.verify()` getters `constexpr`.
    // TODO: Add overloads which take a `string const` for an error message.

    [[nodiscard]] auto assert(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) & -> value_type& {
        cat::assert(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto assert(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) const& -> value_type const& {
        cat::assert(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto assert(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) && -> value_type {
        cat::assert(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto assert(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) const&& -> value_type {
        cat::assert(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto verify(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) & -> value_type& {
        cat::verify(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto verify(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) const& -> value_type const& {
        cat::verify(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto verify(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) && -> value_type {
        cat::verify(this->has_value(), p_assert_handler, callsite);
        // `move()` is required when there is a deleted copy-constructor.
        return move(this->value());
    }

    [[nodiscard]] auto verify(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) const&& -> value_type {
        cat::verify(this->has_value(), p_assert_handler, callsite);
        // `move()` is required when there is a deleted copy-constructor.
        return move(this->value());
    }

    // Monadic methods:

    // TODO: Use an `invocable` `concept`.

    // If this non-`const`-qualified `maybe` holds a value, transform it
    // by a function. Otherwise, propagate an empty `maybe`.
    template <typename Function>
    [[nodiscard]] constexpr auto transform(Function&& invocable) & {
        using U = decltype(invocable(this->value()));
        static_assert(!is_specialization<U, maybe>);

        if constexpr (is_void<U>) {
            return this->has_value() ? maybe<void>{monostate}
                                     : maybe<void>{nullopt};
        } else {
            if (this->has_value()) {
                return maybe<U>{forward<Function>(invocable)(this->value())};
            }
            return maybe<U>{nullopt};
        }
    }

    // If this `const`-qualified `maybe` holds a value, transform it by a
    // function without side-effects. Otherwise, propagate an empty
    // `maybe`.
    template <typename Function>
    [[nodiscard]] constexpr auto transform(Function&& invocable) const& {
        using U = decltype(invocable(this->value()));
        static_assert(!is_specialization<U, maybe>);

        if constexpr (is_void<U>) {
            return this->has_value() ? maybe<void>{monostate}
                                     : maybe<void>{nullopt};
        } else {
            if (this->storage.has_value()) {
                return maybe<U>{forward<Function>(invocable)(this->value())};
            }
            return maybe<U>{nullopt};
        }
    }

    // If this non-`const`-qualified `maybe` holds a value, transform it
    // by function. Otherwise, propagate an empty `maybe`.
    template <typename Function>
    [[nodiscard]] constexpr auto transform(Function&& invocable) && {
        using U = decltype(invocable(this->value()));
        static_assert(!is_specialization<U, maybe>);

        if constexpr (is_void<U>) {
            return this->has_value() ? maybe<void>{monostate}
                                     : maybe<void>{nullopt};
        } else {
            if (this->has_value()) {
                return maybe<U>{
                    forward<Function>(invocable)(move(this)->value())};
            }
            return maybe<U>{nullopt};
        }
    }

    // If this `const`-qualified `maybe` holds a value, transform it by a
    // function without side-effects. Otherwise, propagate an empty
    // `maybe`.
    template <typename Function>
    [[nodiscard]] constexpr auto transform(Function&& invocable) const&& {
        using U = decltype(invocable(this->value()));
        static_assert(!is_specialization<U, maybe>);

        if constexpr (is_void<U>) {
            return this->has_value() ? maybe<void>{monostate}
                                     : maybe<void>{nullopt};
        } else {
            if (this->has_value()) {
                return maybe<U>{
                    forward<Function>(invocable)(move(this)->value())};
            }
            return maybe<U>{nullopt};
        }
    }

    // Invoke a invocable returning an `maybe` on the value of a
    // `const`-qualified `maybe` and propagate the result, if it holds a
    // value.
    template <typename Function>
    [[nodiscard]] constexpr auto and_then(Function&& invocable) & {
        return this->has_value() ? forward<Function>(invocable)(this->value())
                                 : nullopt;
    }

    // Invoke a invocable returning an `maybe` on the value of a
    // `const`-qualified `maybe` and propagate the result, if it holds a
    // value.
    template <typename Function>
    [[nodiscard]] constexpr auto and_then(Function&& invocable) const& {
        return this->has_value() ? forward<Function>(invocable)(this->value())
                                 : nullopt;
    }

    // Invoke a invocable returning an `maybe` on the value of a
    // non-`const`-qualified `maybe` and propagate the result, if it
    // holds a value.
    template <typename Function>
    [[nodiscard]] constexpr auto and_then(Function&& invocable) && {
        return this->has_value()
                   ? forward<Function>(invocable)(move(this)->value())
                   : nullopt;
    }

    // Invoke a invocable returning an `maybe` on the value of a
    // `const`-qualified `maybe` and propagate the result, if it holds a
    // value.
    template <typename Function>
    [[nodiscard]] constexpr auto and_then(Function&& invocable) const&& {
        return this->has_value()
                   ? forward<Function>(invocable)(move(this)->value())
                   : nullopt;
    }

    // Invoke a invocable iff a non-`const`-qualified `maybe` holds no
    // value. This invocable can return `void` or an `maybe`.
    template <typename Function>
    [[nodiscard]] constexpr auto or_else(Function&& invocable) & {
        using U = decltype(invocable());
        static_assert(is_void<U> || is_specialization<U, maybe>);

        if (!this->storage.has_value()) {
            if constexpr (is_void<U>) {
                forward<Function>(invocable)();
            } else {
                return forward<Function>(invocable)();
            }
        }

        if constexpr (is_void<U>) {
            return;
        } else {
            return U(nullopt);
        }
    }

    // Invoke a invocable iff a `const`-qualified `maybe` holds no value.
    // This invocable can return `void` or an `maybe`.
    template <typename Function>
    [[nodiscard]] constexpr auto or_else(Function&& invocable) const& {
        using U = decltype(invocable());
        static_assert(is_void<U> || is_specialization<U, maybe>);

        if (!this->storage.has_value()) {
            if constexpr (is_void<U>) {
                forward<Function>(invocable)();
            } else {
                return forward<Function>(invocable)();
            }
        }

        if constexpr (is_void<U>) {
            return;
        } else {
            return U(nullopt);
        }
    }

    // Invoke a invocable iff a non-`const`-qualified move-only `maybe`
    // holds no value. This invocable can return `void` or an `maybe`.
    template <typename Function>
    [[nodiscard]] constexpr auto or_else(Function&& invocable) && {
        using U = decltype(invocable());
        static_assert(is_void<U> || is_specialization<U, maybe>);

        if (!this->storage.has_value()) {
            if constexpr (is_void<U>) {
                forward<Function>(invocable)();
            } else {
                return move(forward<Function>(invocable))();
            }
        }

        if constexpr (is_void<U>) {
            return;
        } else {
            return U(nullopt);
        }
    }

    // Invoke a invocable iff a `const`-qualified move-only `maybe` holds
    // no value. This invocable can return `void` or an `maybe`.
    template <typename Function>
    [[nodiscard]] constexpr auto or_else(Function&& invocable) const&& {
        using U = decltype(invocable());
        static_assert(is_void<U> || is_specialization<U, maybe>);

        if (!this->storage.has_value()) {
            if constexpr (is_void<U>) {
                forward<Function>(invocable)();
            } else {
                return move(forward<Function>(invocable))();
            }
        }

        if constexpr (is_void<U>) {
            return;
        } else {
            return U(nullopt);
        }
    }

    // If this `maybe` is empty, terminate the running process
    // immediately. Otherwise, return its value.
    [[nodiscard]] auto or_exit(ssize exit_code = 1) & {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return this->value();
            } else {
                return;
            }
        } else {
            exit(exit_code);
        }
        __builtin_unreachable();  // This prevents a build warning.
    }

    // If this `maybe` is empty, terminate the running process
    // immediately. Otherwise, return its value.
    [[nodiscard]] auto or_exit(ssize exit_code = 1) const& {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return this->value();
            } else {
                return;
            }
        } else {
            exit(exit_code);
        }
        __builtin_unreachable();  // This prevents a build warning.
    }

    // If this `maybe` is empty, terminate the running process
    // immediately. Otherwise, move its value.
    [[nodiscard]] auto or_exit(ssize exit_code = 1) && {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return move(this->value());
            } else {
                return;
            }
        } else {
            exit(exit_code);
        }
        __builtin_unreachable();  // This prevents a build warning.
    }

    // If this `maybe` is empty, terminate the running process
    // immediately. Otherwise, move its value.
    [[nodiscard]] auto or_exit(ssize exit_code = 1) const&& {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return move(this)->value();
            } else {
                return;
            }
        } else {
            exit(exit_code);
        }
        __builtin_unreachable();  // This prevents a build warning.
    }

    // If this `maybe` is empty, print an error message and terminate the
    // running process immediately. Otherwise, return its value.
    // These are implemented in `<cat/string>`.
    [[nodiscard]] auto or_exit(string const error_message,
                               ssize exit_code = 1) &;
    [[nodiscard]] auto or_exit(string const error_message,
                               ssize exit_code = 1) const&;
    [[nodiscard]] auto or_exit(string const error_message,
                               ssize exit_code = 1) &&;
    [[nodiscard]] auto or_exit(string const error_message,
                               ssize exit_code = 1) const&&;

    // Construct the value in-place and destroy the held value iff it
    // exists.
    template <typename... Args>
        requires(!is_void<T>)
    constexpr auto emplace(Args&&... args) -> value_type& {
        *this = nullopt;
        this->storage.construct(forward<Args>(args)...);
        return this->storage.value();
    }

  private:
    storage_type storage;
};

// This deduction guide is required for deducing references.
template <typename T>
maybe(T) -> maybe<T>;

template <typename T>
concept is_maybe = requires(T t) {
    // T::value_type;
    cat::maybe<decltype(t.value())>();
    t = cat::nullopt;
}
&&!requires {
    T::ErrorsList;
};

// TODO: Support `void*`.
// Simplify nullable pointers.
template <typename T>
using maybePtr = maybe<sentinel<T*, nullptr>>;

namespace detail {
    template <is_integral T>
    constexpr auto is_non_negative(T value) -> bool {
        return value >= 0;
    }
}  // namespace detail

// Simplify non-negative signed integers.
template <is_integral T>
using maybeNonNegative =
    // A lambda here causes clangd 14 to crash.
    maybe<compact<T, detail::is_non_negative<T>, -1>>;

// Simplify non-zero numbers.
template <typename T>
using maybe_non_zero = maybe<sentinel<T, 0>>;

}  // namespace cat

using cat::nullopt;
