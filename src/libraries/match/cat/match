// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/scaredy>
#include <cat/tuple>
#include <cat/type_list>

// match(v)(is_a<int>().then([](){
//              print("int");
//          }),
//          is_a(1.f).then([](){
//              print("1.f");
//          }),
//          one_of<int, double>().then([](){
//              print("int or double");
//          }),
//          one_of(2.f, 3).then([](){
//              print("2.f or 3");
//          }),
//          otherwise([](){
//              print("No match.");
//          }));

namespace cat {
namespace detail {
    struct Pattern {};

    // TODO: Can this callback be type erased?
    template <typename Function>
    struct PatternCallback {
        Function callback;

        // This isn't needed in C++20, but it prevents a clangd false
        // diagnostic.
        PatternCallback(Function&& input)
            : callback(forward<Function>(input)){};

        template <typename T>
        constexpr auto operator()(T&& matching) -> decltype(auto) {
            return this->callback(forward<T>(matching));
        }
    };

    template <typename... Ts>
    struct OneOfTypes : Pattern {
        constexpr OneOfTypes() = default;

        template <typename Function>
        constexpr auto then(Function&& callback) {
            return PatternCallback{[&](auto& matching) -> bool {
                // If `matching` currently holds one of `Ts`, then invoke
                // `callback`.
                if (((matching.template is<Ts>()) || ...)) {
                    forward<Function>(callback)();
                    return true;
                }
                return false;
            }};
        }
    };

    template <typename T>
    struct IsAValue : Pattern {
        T value;

        constexpr IsAValue(T&& in_value) : value(forward<T>(in_value)){};

        template <typename Function>
        constexpr auto then(Function&& callback) {
            return PatternCallback{[&](auto& matching) -> bool {
                // If `matching` currently holds a value equivalent to
                // `this->value`, then invoke `callback`.
                if (matching.template is(this->value)) {
                    forward<Function>(callback)();
                    return true;
                }
                return false;
            }};
        }
    };
}  // namespace detail

template <typename... Ts>
constexpr auto one_of() -> detail::OneOfTypes<Ts...> {
    return detail::OneOfTypes<Ts...>{};
}

// TODO: `one_of()` overload taking values instead of types.

template <typename T>
constexpr auto is_a() -> detail::OneOfTypes<T> {
    return detail::OneOfTypes<T>{};
}

template <typename T>
constexpr auto is_a(T&& value) -> detail::IsAValue<T> {
    return detail::IsAValue<T>{forward<T>(value)};
}

template <typename Function>
// NOLINTNEXTLINE Let this be snake_case.
struct otherwise : detail::Pattern {};

template <typename T>
struct MatchPatterns {
    T& matching;

    // This isn't needed in C++20, but it prevents a clangd false diagnostic.
    MatchPatterns(T& input) : matching(input){};

    // Base case.
    template <typename U>
    constexpr void call_pattern(U pattern) {
        !pattern(this->matching);
    }

    // Call every pattern in order.
    template <typename U, typename... Remaining>
        requires(sizeof...(Remaining) > 0)
    constexpr void call_pattern(U pattern, Remaining&&... remaining) {
        if (pattern(this->matching)) {
            // Short circuit the remaining patterns if this one returns true.
            return;
        }
        return call_pattern(forward<Remaining>(remaining)...);
    }

    // Every pattern must be either an `is_a`, `one_of`, or `otherwise`.
    template <typename... Patterns>
        requires(is_specialization<Patterns, detail::PatternCallback>&&...)
    constexpr void operator()(Patterns&&... patterns) {
        // Recurse through `patterns` in order. Invoke the call operator on each
        // of them with `this->matching` as an argument. When one pattern
        // holds true, invoke its callback and stop recursing.
        this->call_pattern(forward<Patterns>(patterns)...);
    }
};

// These lambdas can return void or non-void. The return value of `match` is
// then the `CommonType` of those lambdas' return types, and they are casted to
// that common type.

template <typename T>
constexpr auto match(T& matching) -> MatchPatterns<T> {
    return MatchPatterns{matching};
}

}  // namespace cat

using cat::is_a;
using cat::one_of;
using cat::otherwise;
