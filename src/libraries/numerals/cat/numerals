// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/compare>
#include <cat/limits>

// `Numeral` and `ArithmeticPtr` are containers for numeric data types which
// prevents unsafe implicit type casts.
//
// All of their conversion operators, arithmetic operators and constructors
// are generic with constraints. Because these methods are constrained, it
// is possible that the compiler will fail to resolve any satisfying
// overloads for an invocation of an operator or constructor, and thus prevent
// compilation.
//
// Constraints such as "the operand's size must be less than or equal to my
// own size" guarantee that an unwanted overload cannot be resolved.
// This solution is concise, because any constraint broadly applies to all
// possible type conversions.

namespace cat {

// These policies control the overflow semantics of `Numeral`s.
enum class OverflowPolicies {
    undefined,
    wrap,
    saturate,
    trap,
    wrap_member,
    saturate_member,
    trap_member,
};

template <typename T>
inline constexpr bool is_arithmetic_ptr = requires {
    T::Ptr;
};

template <typename T>
constexpr auto to_raw_numeral(T value) {
    if constexpr (requires { value.raw; }) {
        return value.raw;
    } else {
        return value;
    }
}

template <typename T>
using ToRawNumeral = decltype(to_raw_numeral(T{0}));

template <typename T>
concept rawNumeral = is_same<T, ToRawNumeral<T>>;

template <typename T>
inline constexpr bool is_raw_numeral = is_same<T, ToRawNumeral<T>>;

template <integral T>
constexpr auto make_signed(T value) -> MakeSigned<T> {
    return static_cast<MakeSigned<T>>(value);
}

template <integral T>
constexpr auto make_unsigned(T value) -> MakeUnsigned<T> {
    // Could this use `__builtin_bit_cast()`?
    return static_cast<MakeUnsigned<T>>(value);
}

template <integral From, integral To>
constexpr auto make_sign_from(To value) -> CopySignFrom<From, To> {
    return static_cast<CopySignFrom<From, To>>(value);
}

// These macros are defined by the GCC compiler.
using int1 = Numeral<__INT8_TYPE__, OverflowPolicies::undefined>;     // NOLINT
using uint1 = Numeral<__UINT8_TYPE__, OverflowPolicies::undefined>;   // NOLINT
using int2 = Numeral<__INT16_TYPE__, OverflowPolicies::undefined>;    // NOLINT
using uint2 = Numeral<__UINT16_TYPE__, OverflowPolicies::undefined>;  // NOLINT
using int4 = Numeral<__INT32_TYPE__, OverflowPolicies::undefined>;    // NOLINT
using uint4 = Numeral<__UINT32_TYPE__, OverflowPolicies::undefined>;  // NOLINT
using int8 = Numeral<__INT64_TYPE__, OverflowPolicies::undefined>;    // NOLINT
using uint8 = Numeral<__UINT64_TYPE__, OverflowPolicies::undefined>;  // NOLINT
// using i128 = Numeral<int128_t, OverflowPolicies::undefined>; // NOLINT
// using u128 = Numeral<uint128_t, OverflowPolicies::undefined>; // NOLINT

using float4 = Numeral<float, OverflowPolicies::undefined>;   // NOLINT
using float8 = Numeral<double, OverflowPolicies::undefined>;  // NOLINT

using wrap_int1 = Numeral<__INT8_TYPE__, OverflowPolicies::wrap>;     // NOLINT
using wrap_uint1 = Numeral<__UINT8_TYPE__, OverflowPolicies::wrap>;   // NOLINT
using wrap_int2 = Numeral<__INT16_TYPE__, OverflowPolicies::wrap>;    // NOLINT
using wrap_uint2 = Numeral<__UINT16_TYPE__, OverflowPolicies::wrap>;  // NOLINT
using wrap_int4 = Numeral<__INT32_TYPE__, OverflowPolicies::wrap>;    // NOLINT
using wrap_uint4 = Numeral<__UINT32_TYPE__, OverflowPolicies::wrap>;  // NOLINT
using wrap_int8 = Numeral<__INT64_TYPE__, OverflowPolicies::wrap>;    // NOLINT
using wrap_uint8 = Numeral<__UINT64_TYPE__, OverflowPolicies::wrap>;  // NOLINT

// NOLINTNEXTLINE
using sat_int1 = Numeral<__INT8_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_uint1 = Numeral<__UINT8_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_int2 = Numeral<__INT16_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_uint2 = Numeral<__UINT16_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_int4 = Numeral<__INT32_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_uint4 = Numeral<__UINT32_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_int8 = Numeral<__INT64_TYPE__, OverflowPolicies::saturate>;
// NOLINTNEXTLINE
using sat_uint8 = Numeral<__UINT64_TYPE__, OverflowPolicies::saturate>;

// NOLINTNEXTLINE
using usize = Numeral<__SIZE_TYPE__, OverflowPolicies::undefined>;
// NOLINTNEXTLINE
using ssize = Numeral<MakeSigned<__SIZE_TYPE__>, OverflowPolicies::undefined>;

namespace detail {
    template <arithmetic From, arithmetic To>
    inline constexpr bool is_safe_comparison =
        // `ToRawNumeral` is needed here to prevent a recursive constraint
        // in evaluating the `<` operator.
        ((is_signed<ToRawNumeral<From>> == is_signed<ToRawNumeral<To>>)) &&
        (is_floating_point<From> == is_floating_point<To>);

    // Any numeral can safely convert to a type larger than itself, but not
    // smaller than itself.
    template <arithmetic From, arithmetic To>
    inline constexpr bool is_safe_conversion = (sizeof(From) <= sizeof(To)) &&
                                               (is_safe_comparison<From, To>);

    template <typename T, typename U>
    consteval auto promoted_numeral() {
        if constexpr (is_arithmetic_ptr<T>) {
            return T{};
        } else if constexpr (is_arithmetic_ptr<U>) {
            return U{};
        } else {
            if constexpr (sizeof(T) >= sizeof(U)) {
                return Numeral<ToRawNumeral<T>, OverflowPolicies::undefined>{};
            } else {
                return Numeral<ToRawNumeral<U>, OverflowPolicies::undefined>{};
            }
        }
    }

    template <typename T, typename U>
        requires((is_signed<T> == is_signed<U>)&&(is_floating_point<T> ==
                                                  is_floating_point<U>))
    using PromotedNumeral = decltype(promoted_numeral<T, U>());
}  // namespace detail

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_leading_zeros(T value) -> ssize;

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_trailing_zeros(T value) -> ssize;

// Overflow intrinsics optimize fairly well in GCC.
// `	[[nodiscard, gnu::optimize(2)]]` is required because the codegen is
// awful by default.
// TODO: Support saturating floats.

// Add two integers with saturating overflow.
template <rawNumeral T>
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_add(T lhs, T rhs) -> T {
    T sum;
    bool overflow = __builtin_add_overflow(lhs, rhs, &sum);
    if (overflow) {
        return Limits<T>::max();
    }
    return sum;
}

// Unwrap `Numeral` for `sat_add()`.
template <integral T, integral U>
    requires(detail::is_safe_comparison<T, U>)
[[nodiscard]] constexpr auto sat_add(T lhs, U rhs)
    -> detail::PromotedNumeral<T, U> {
    // Saturating arithmetic inputs must be cast to the same size.
    using Type = Larger<ToRawNumeral<T>, ToRawNumeral<U>>;
    return sat_add(static_cast<Type>(lhs), static_cast<Type>(rhs));
}

// Add two integers with wrapping overflow.
template <integral T, integral U>
    requires(detail::is_safe_comparison<T, U>)
[[nodiscard]] constexpr auto wrap_add(T lhs, U rhs)
    -> detail::PromotedNumeral<T, U> {
    using Type = Larger<T, U>;
    return detail::PromotedNumeral<T, U>{make_unsigned(static_cast<Type>(lhs)) +
                                         make_unsigned(static_cast<Type>(rhs))};
}

// Subtract two integers with saturating overflow.
template <rawNumeral T>
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_sub(T lhs, T rhs) -> T {
    T sum;
    bool overflow = __builtin_sub_overflow(lhs, rhs, &sum);
    if (overflow) {
        return Limits<T>::min();
    }
    return sum;
}

// Unwrap `Numeral` for `sat_sub()`.
template <integral T, integral U>
    requires(detail::is_safe_comparison<T, U>)
[[nodiscard]] constexpr auto sat_sub(T lhs, U rhs)
    -> detail::PromotedNumeral<T, U> {
    // Saturating arithmetic inputs must be cast to the same size.
    using Type = Larger<ToRawNumeral<T>, ToRawNumeral<U>>;
    return sat_sub(static_cast<Type>(lhs), static_cast<Type>(rhs));
}

// Subtract two integers with wrapping overflow.
template <integral T, integral U>
    requires(detail::is_safe_comparison<T, U>)
[[nodiscard]] constexpr auto wrap_sub(T lhs, U rhs)
    -> detail::PromotedNumeral<T, U> {
    using Type = Larger<ToRawNumeral<T>, ToRawNumeral<U>>;
    return detail::PromotedNumeral<T, U>{make_unsigned(static_cast<Type>(lhs)) -
                                         make_unsigned(static_cast<Type>(rhs))};
}

// Subtract two integers with saturating overflow.
template <rawNumeral T>
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_mul(T lhs, T rhs) -> T {
    T sum;
    bool overflow = __builtin_mul_overflow(lhs, rhs, &sum);
    if (overflow) {
        return Limits<T>::max();
    }
    return sum;
}

// Unwrap `Numeral` for `sat_mul()`.
template <integral T, integral U>
    requires(detail::is_safe_comparison<T, U>)
[[nodiscard]] constexpr auto sat_mul(T lhs, U rhs)
    -> detail::PromotedNumeral<T, U> {
    // Saturating arithmetic inputs must be cast to the same size.
    using Type = Larger<ToRawNumeral<T>, ToRawNumeral<U>>;
    return sat_mul(static_cast<Type>(lhs), static_cast<Type>(rhs));
}

// Multiply two integers with wrapping overflow.
template <integral T, integral U>
    requires(detail::is_safe_comparison<T, U>)
[[nodiscard]] constexpr auto wrap_mul(T lhs, U rhs)
    -> detail::PromotedNumeral<T, U> {
    using Type = Larger<ToRawNumeral<T>, ToRawNumeral<U>>;
    return detail::PromotedNumeral<T, U>{make_unsigned(static_cast<Type>(lhs)) *
                                         make_unsigned(static_cast<Type>(rhs))};
}

// Subtract two integers with saturating overflow.
template <rawNumeral T>
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_div(T lhs, T rhs) -> T {
    if constexpr (is_signed<T>) {
        lhs += !((rhs + 1) | (make_unsigned(lhs) + Limits<T>::max()));
    }
    // Unsigned integer division cannot overflow.
    return lhs / rhs;
}

// Unwrap `Numeral` for `sat_mul()`.
template <integral T, integral U>
    requires(detail::is_safe_comparison<T, U>)
[[nodiscard]] constexpr auto sat_div(T lhs, U rhs)
    -> detail::PromotedNumeral<T, U> {
    // Saturating arithmetic inputs must be cast to the same size.
    using Type = Larger<ToRawNumeral<T>, ToRawNumeral<U>>;
    return sat_div(static_cast<Type>(lhs), static_cast<Type>(rhs));
}

// Divide two integers with wrapping overflow.
template <integral T, integral U>
    requires(detail::is_safe_comparison<T, U>)
[[nodiscard]] constexpr auto wrap_div(T lhs, U rhs)
    -> detail::PromotedNumeral<T, U> {
    using Type = Larger<ToRawNumeral<T>, ToRawNumeral<U>>;
    return detail::PromotedNumeral<T, U>{make_unsigned(static_cast<Type>(lhs)) /
                                         make_unsigned(static_cast<Type>(rhs))};
}

// Left bit-shifting two unsigned integers with saturating overflow.
template <rawNumeral T, rawNumeral U>
    // TODO: Figure out signed saturating shift semantics.
    requires(is_unsigned<T>)
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_shl(T value, U bits) {
    // TODO: Try `cat::count_trailing_zeros()`.
    if (bits >= Limits<T>::bits - __builtin_ctz(value)) {
        return Limits<T>::max();
    }
    return value << bits;
}

// Unwrap `Numeral` for `sat_shl()`.
template <integral T, integral U>
    requires(detail::is_safe_comparison<T, U>)
[[nodiscard]] constexpr auto sat_shl(T value, U bits)
    -> detail::PromotedNumeral<T, U> {
    // Saturating arithmetic inputs must be cast to the same size.
    using Type = Larger<ToRawNumeral<T>, ToRawNumeral<U>>;
    return sat_shl(static_cast<Type>(value), static_cast<Type>(bits));
}

template <rawNumeral T, rawNumeral U>
    // TODO: Figure out signed saturating shift semantics.
    requires(is_unsigned<T>)
[[nodiscard, gnu::optimize(2)]] constexpr auto sat_shr(T value, U bits) {
    // TODO: Try `cat::count_leading_zeros()`.
    if (bits >= Limits<T>::bits - __builtin_clz(value)) {
        return Limits<T>::min();
    }
    return value >> bits;
}

// Unwrap `Numeral` for `sat_shr()`.
template <integral T, integral U>
    requires(detail::is_safe_comparison<T, U>)
[[nodiscard]] constexpr auto sat_shr(T value, U bits)
    -> detail::PromotedNumeral<T, U> {
    // Saturating arithmetic inputs must be cast to the same size.
    using Type = Larger<ToRawNumeral<T>, ToRawNumeral<U>>;
    return sat_shr(static_cast<Type>(value), static_cast<Type>(bits));
}

namespace detail {
    template <typename T, OverflowPolicies>
    struct NumeralStorage;

    // To prevent `Numeral` holding a member of its own type, only undefined
    // overflow can access other overflow semantics.

    template <typename T>
    struct NumeralStorage<T, OverflowPolicies::undefined> {
        auto operator<=>(NumeralStorage<T, OverflowPolicies::undefined>) =
            delete;
        auto operator==(NumeralStorage<T, OverflowPolicies::undefined>) =
            delete;

        union {
            T raw;
            Numeral<T, OverflowPolicies::wrap_member> wrap;
            Numeral<T, OverflowPolicies::saturate_member> sat;
            Numeral<T, OverflowPolicies::trap_member> trap;
        };
    };

    template <typename T>
    struct NumeralStorage<T, OverflowPolicies::wrap> {
        union {
            T raw;
            Numeral<T, OverflowPolicies::saturate_member> sat;
            Numeral<T, OverflowPolicies::trap_member> trap;
        };
    };

    template <typename T>
    struct NumeralStorage<T, OverflowPolicies::saturate> {
        union {
            T raw;
            Numeral<T, OverflowPolicies::wrap_member> wrap;
            Numeral<T, OverflowPolicies::trap_member> trap;
        };
    };

    template <typename T>
    struct NumeralStorage<T, OverflowPolicies::trap> {
        union {
            T raw;
            Numeral<T, OverflowPolicies::wrap_member> wrap;
            Numeral<T, OverflowPolicies::saturate_member> sat;
        };
    };

    template <typename T>
    struct NumeralStorage<T, OverflowPolicies::wrap_member> {
        T raw;
    };

    template <typename T>
    struct NumeralStorage<T, OverflowPolicies::saturate_member> {
        T raw;
    };

    template <typename T>
    struct NumeralStorage<T, OverflowPolicies::trap_member> {
        T raw;
    };
}  // namespace detail

// `Numeral` can represent an integer or floating point value. It prevents
// unsafe casts or operations. This is a trivial `struct` so it can be used as a
// non-type template parameter.
template <typename T, OverflowPolicies policy = OverflowPolicies::undefined>
struct Numeral : detail::NumeralStorage<T, policy> {
    using Raw = T;

    constexpr Numeral() = default;

    template <arithmetic U>
    constexpr explicit(!detail::is_safe_conversion<U, T>) Numeral(U other) {
        this->raw = to_raw_numeral(other);
    }

    template <typename U>
    constexpr explicit operator U() const {
        return static_cast<U>(this->raw);
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator<=>(Numeral<T, policy> lhs,
                                                    U rhs) {
        return lhs.raw <=> to_raw_numeral(rhs);
    }

    // A `!=` operator is not generated by `<=>`, but overloading `!=` prevents
    // generating `==`. Instead, `==` is explicitly provided to generate `!=`.
    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator==(Numeral<T, policy> lhs,
                                                   U rhs) -> bool {
        return lhs.raw == to_raw_numeral(rhs);
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    constexpr auto operator=(U operand) {
        this->raw = to_raw_numeral(operand);
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator+(Numeral<T, policy> self,
                                                  U operand)
        -> detail::PromotedNumeral<T, U> {
        using enum OverflowPolicies;
        if constexpr (policy == undefined) {
            return detail::PromotedNumeral<T, U>{self.raw +
                                                 to_raw_numeral(operand)};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_add(to_raw_numeral(self), to_raw_numeral(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_add(to_raw_numeral(self), to_raw_numeral(operand));
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator+(U* p_operand,
                                                  Numeral<T, policy> numeral)
        -> U* {
        return p_operand + numeral.raw;
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator+(Numeral<T, policy> numeral,
                                                  U* p_operand) -> U* {
        return numeral.raw + p_operand;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator+=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self = self + to_raw_numeral(operand);
        return self;
    }

    [[nodiscard]] friend constexpr auto operator+(Numeral<T, policy> self)
        -> Numeral {
        return +(self.raw);
    }

    friend constexpr auto operator++(Numeral<T, policy>& self) -> Numeral& {
        self += static_cast<T>(1);
        return self;
    }

    friend constexpr auto operator++(Numeral<T, policy>& self, int)
        -> Numeral& {
        self += static_cast<T>(1);
        return self;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator-(Numeral<T, policy> self,
                                                  U operand)
        -> detail::PromotedNumeral<T, U> {
        using enum OverflowPolicies;
        if constexpr (policy == undefined) {
            return detail::PromotedNumeral<T, U>{self.raw -
                                                 to_raw_numeral(operand)};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_sub(to_raw_numeral(self), to_raw_numeral(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_sub(to_raw_numeral(self), to_raw_numeral(operand));
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator-(U* p_operand,
                                                  Numeral<T, policy> self)
        -> U* {
        return p_operand - self.raw;
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator-(Numeral<T, policy> numeral,
                                                  U* p_operand) -> U* {
        return numeral.raw - p_operand;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    friend constexpr auto operator-=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self = self - to_raw_numeral(operand);
        return self;
    }

    [[nodiscard]] friend constexpr auto operator-(Numeral<T, policy> self)
        -> Numeral requires(is_signed<T>) {
        return -(self.raw);
    }

    friend constexpr auto operator--(Numeral<T, policy>& self) -> Numeral& {
        self -= static_cast<T>(1);
        return self;
    }

    friend constexpr auto operator--(Numeral<T, policy>& self, int)
        -> Numeral& {
        self -= static_cast<T>(1);
        return self;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator*(Numeral<T, policy> self,
                                                  U operand)
        -> detail::PromotedNumeral<T, U> {
        using enum OverflowPolicies;
        if constexpr (policy == OverflowPolicies::undefined) {
            return detail::PromotedNumeral<T, U>{self.raw *
                                                 to_raw_numeral(operand)};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_mul(to_raw_numeral(self), to_raw_numeral(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_mul(to_raw_numeral(self), to_raw_numeral(operand));
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator*(U* p_operand,
                                                  Numeral<T, policy> self)
        -> U* {
        return p_operand * self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator*(Numeral<T, policy> self,
                                                  U* p_operand) -> U* {
        return p_operand * self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator*=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self = self * to_raw_numeral(operand);
        return self;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator/(Numeral<T, policy> self,
                                                  U operand)
        -> detail::PromotedNumeral<T, U> {
        using enum OverflowPolicies;
        if constexpr (policy == undefined) {
            return detail::PromotedNumeral<T, U>{self.raw /
                                                 to_raw_numeral(operand)};
        } else if constexpr (policy == wrap || policy == wrap_member) {
            return wrap_mul(to_raw_numeral(self), to_raw_numeral(operand));
        } else if constexpr (policy == saturate || policy == saturate_member) {
            return sat_mul(to_raw_numeral(self), to_raw_numeral(operand));
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator/(U* p_operand,
                                                  Numeral<T, policy> self)
        -> U* {
        return p_operand / self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator/(Numeral<T, policy> self,
                                                  U* p_operand) -> U* {
        return p_operand / self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator/=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self = self / to_raw_numeral(operand);
        return self;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator%(Numeral<T, policy> self,
                                                  U operand)
        -> detail::PromotedNumeral<T, U> {
        return detail::PromotedNumeral<T, U>{self.raw %
                                             to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator%(U* p_operand,
                                                  Numeral<T, policy> self)
        -> U* {
        return p_operand % self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator%(Numeral<T, policy> self,
                                                  U* p_operand) -> U* {
        return p_operand % self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator%=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw %= to_raw_numeral(operand);
        return self;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator&(Numeral<T, policy> self,
                                                  U operand)
        -> detail::PromotedNumeral<T, U> {
        return detail::PromotedNumeral<T, U>{self.raw &
                                             to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator&(U* p_operand,
                                                  Numeral<T, policy> self)
        -> U* {
        return p_operand & self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator&(Numeral<T, policy> self,
                                                  U* p_operand) -> U* {
        return p_operand & self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator&=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw &= to_raw_numeral(operand);
        return self;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    [[nodiscard]] friend constexpr auto operator|(Numeral<T, policy> self,
                                                  U operand)
        -> detail::PromotedNumeral<T, U> {
        return detail::PromotedNumeral<T, U>{self.raw |
                                             to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator|(U* p_operand,
                                                  Numeral<T, policy> self)
        -> U* {
        return p_operand | self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator|(Numeral<T, policy> self,
                                                  U* p_operand) -> U* {
        return p_operand | self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator|=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw |= to_raw_numeral(operand);
        return self;
    }

    template <typename U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator<<(Numeral<T, policy> self,
                                                   U operand) -> Numeral<T> {
        if constexpr (policy == OverflowPolicies::saturate) {
            return sat_shl(to_raw_numeral(self), to_raw_numeral(operand));
        } else {
            return self.raw << to_raw_numeral(operand);
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator<<(U* p_operand,
                                                   Numeral<T, policy> self)
        -> U* {
        return p_operand << self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator<<(Numeral<T, policy> self,
                                                   U* p_operand) -> U* {
        return p_operand << self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator<<=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self = self << to_raw_numeral(operand);
        return self;
    }

    template <typename U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator>>(Numeral<T, policy> self,
                                                   U operand) -> Numeral<T> {
        if constexpr (policy == OverflowPolicies::saturate) {
            return sat_shr(to_raw_numeral(self), to_raw_numeral(operand));
        } else {
            return self.raw >> to_raw_numeral(operand);
        }
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator>>(U* p_operand,
                                                   Numeral<T, policy> self)
        -> U* {
        return p_operand >> self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator>>(Numeral<T, policy> self,
                                                   U* p_operand) -> U* {
        return p_operand >> self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator>>=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self = self >> to_raw_numeral(operand);
        return self;
    }

    [[nodiscard]] friend constexpr auto operator~(Numeral<T, policy> self)
        -> Numeral requires(is_integral<T>) {
        return ~(self.raw);
    }

    // Member functions for all numerals.

    [[nodiscard]] constexpr auto count_leading_zeros() const -> ssize
        requires(is_integral<T>) {
        return cat::count_leading_zeros(this->raw);
    }

    [[nodiscard]] constexpr auto count_trailing_zeros() const -> ssize
        requires(is_integral<T>) {
        return cat::count_trailing_zeros(this->raw);
    }

    // Making these `auto` solves a clang-tidy false diagnostic.
    // TODO: These should be type `Numeral<T>`.
    static constexpr auto min = Limits<Raw>::min();
    static constexpr auto max = Limits<Raw>::max();

    // `Numeral` derives public storage from `detail::NumeralStorage`.
};

// `ArithmeticPtr` can be constructed from any integer type or any pointer.
// It can only convert into `T*`, but it is otherwise interchangeable with
// integers. It satisfies the `is_integral` type trait and
// `integral` concept.
template <typename T, typename Storage,
          auto policy = OverflowPolicies::undefined>
class ArithmeticPtr : public Numeral<Storage, policy> {
  public:
    using Raw = Storage;
    using Ptr = T*;

    constexpr ArithmeticPtr() = default;
    constexpr ArithmeticPtr(ArithmeticPtr<T, Storage, policy> const&) = default;
    constexpr ArithmeticPtr(ArithmeticPtr<T, Storage, policy>&&) = default;

    template <integral U>
        requires(detail::is_safe_conversion<U, Storage>)
    constexpr ArithmeticPtr(U other)
        : Numeral<Storage, policy>(to_raw_numeral(other)){};

    constexpr ArithmeticPtr(T* p_input)
        : Numeral<Storage, policy>(reinterpret_cast<Storage>(p_input)) {
    }

    // Allow explicitly constructing from another `ArithmeticPtr` with the same
    // `T`.
    template <arithmetic U, OverflowPolicies other_policy>
    constexpr explicit ArithmeticPtr(ArithmeticPtr<T, U, other_policy> other)
        : Numeral<Storage, policy>(to_raw_numeral(other)){};

    // Only allow casting back into the original pointer type.
    explicit constexpr operator T*() {
        return reinterpret_cast<T*>(this->raw);
    }

    // Only allow casting back into the original pointer type.
    explicit constexpr operator T*() const {
        return reinterpret_cast<T const*>(this->raw);
    }

    // TODO: Add a dereference operator.

    // TODO: Streamline out all of these operators by implementing `Numeral`'s
    // with "deducing this".

    // TODO: Cat assignment be `default`?
    // TODO: This redundant assignment operator is required by GCC.
    constexpr auto operator=(ArithmeticPtr<T, Storage, policy> operand)
        -> ArithmeticPtr& {
        this->raw = operand.raw;
        return *this;
    }

    template <integral U>
        requires(detail::is_safe_conversion<U, Storage>)
    constexpr auto operator=(U operand) -> ArithmeticPtr& {
        this->raw = to_raw_numeral(operand);
        return *this;
    }

    template <typename U>
        requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator<=>(
        ArithmeticPtr<T, Storage, policy> lhs, U rhs) {
        return lhs.raw <=> to_raw_numeral(rhs);
    }

    // A `!=` operator is not generated by `<=>`, but overloading `!=`
    // prevents generating `==`. Instead, `==` is explicitly provided to
    // generate `!=`.
    template <typename U>
        requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator==(
        ArithmeticPtr<T, Storage, policy> lhs, U rhs) -> bool {
        return lhs.raw == to_raw_numeral(rhs);
    }

    // TODO: `requires` constraints on these operators makes GCC 13's argument
    // dependant lookup become ambiguous for some reason.

    template <integral U>
    [[nodiscard]] friend constexpr auto operator+(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw + to_raw_numeral(operand);
    }

    template <integral U>
    constexpr auto operator+=(U operand) {
        this->raw += to_raw_numeral(operand);
        return *this;
    }

    [[nodiscard]] friend constexpr auto operator+(
        ArithmeticPtr<T, Storage, policy> self) -> ArithmeticPtr {
        return +(self.raw);
    }

    friend constexpr auto operator++(ArithmeticPtr<T, Storage, policy>& self)
        -> ArithmeticPtr {
        return ++(self.raw);
    }

    friend constexpr auto operator++(ArithmeticPtr<T, Storage, policy>& self,
                                     int) -> ArithmeticPtr {
        return (self.raw)++;
    }

    template <integral U>
    [[nodiscard]] friend constexpr auto operator-(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw - to_raw_numeral(operand);
    }

    // TODO: Make this `friend`.
    template <typename U>
    constexpr auto operator-=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw - to_raw_numeral(operand);
        return *this;
    }

    [[nodiscard]] friend constexpr auto operator-(
        ArithmeticPtr<T, Storage, policy> self) -> ArithmeticPtr {
        return -(self.raw);
    }

    friend constexpr auto operator--(ArithmeticPtr<T, Storage, policy>& self)
        -> ArithmeticPtr& {
        return --(self.raw);
    }

    friend constexpr auto operator--(ArithmeticPtr<T, Storage, policy>& self,
                                     int) -> ArithmeticPtr& {
        return (self.raw)--;
    }

    template <integral U>
    [[nodiscard]] friend constexpr auto operator*(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw * to_raw_numeral(operand);
    }

    template <typename U>
    constexpr auto operator*=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw * to_raw_numeral(operand);
        return *this;
    }

    template <integral U>
    [[nodiscard]] friend constexpr auto operator/(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw / to_raw_numeral(operand);
    }

    template <typename U>
    constexpr auto operator/=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw / to_raw_numeral(operand);
        return *this;
    }

    template <integral U>
    [[nodiscard]] friend constexpr auto operator%(
        ArithmeticPtr<T, Storage, policy> self, U operand)
        -> ArithmeticPtr<T, Storage, policy> {
        return self.raw % to_raw_numeral(operand);
    }

    template <typename U>
    constexpr auto operator%=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw % to_raw_numeral(operand);
        return *this;
    }

    template <integral U>
    [[nodiscard]] friend constexpr auto operator&(
        ArithmeticPtr<T, Storage, policy> self, U operand)
        -> ArithmeticPtr<T, Storage, policy> {
        return self.raw & to_raw_numeral(operand);
    }

    template <typename U>
    constexpr auto operator&=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw & to_raw_numeral(operand);
        return *this;
    }

    template <integral U>
    [[nodiscard]] friend constexpr auto operator|(
        ArithmeticPtr<T, Storage, policy> self, U operand)
        -> ArithmeticPtr<T, Storage, policy> {
        return self.raw | to_raw_numeral(operand);
    }

    // TODO: Make more of these hidden `friend`s.

    template <typename U>
    constexpr auto operator|=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw | to_raw_numeral(operand);
        return *this;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator<<(U operand) const
        -> ArithmeticPtr<T, Storage, policy> {
        return static_cast<Storage>(this->raw << to_raw_numeral(operand));
    }

    template <typename U>
    constexpr auto operator<<=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw << to_raw_numeral(operand);
        return *this;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator>>(U operand) const
        -> ArithmeticPtr<T, Storage, policy> {
        return static_cast<Storage>(this->raw >> to_raw_numeral(operand));
    }

    template <typename U>
    constexpr auto operator>>=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw >> to_raw_numeral(operand);
        return *this;
    }

    [[nodiscard]] constexpr auto operator~() -> ArithmeticPtr {
        return ~(this->raw);
    }
};

// `__INTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using intptr = ArithmeticPtr<T, __INTPTR_TYPE__>;  // NOLINT

// `__UINTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using uintptr = cat::ArithmeticPtr<T, __UINTPTR_TYPE__>;  // NOLINT

// Add and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator+=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs += rhs.raw;
    return p_lhs;
}

// Subtract and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator-=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs -= rhs.raw;
    return p_lhs;
}

// Multiply and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator*=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs *= rhs.raw;
    return p_lhs;
}

// Divide and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator/=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs /= rhs.raw;
    return p_lhs;
}

// Bitwise shift left and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator<<=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs <<= rhs.raw;
    return p_lhs;
}

// Bitwise shift right and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator>>=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs >>= rhs.raw;
    return p_lhs;
}

// Bitwise modulo and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator%=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs %= rhs.raw;
    return p_lhs;
}

// Bitwise and and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator&=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs &= rhs.raw;
    return p_lhs;
}

// Bitwise or and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator|=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs |= rhs.raw;
    return p_lhs;
}

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_leading_zeros(T value) -> ssize {
    auto raw_value = to_raw_numeral(value);
    return ssize{__builtin_clz(raw_value)};
    // if constexpr (sizeof(T) == 2) {
    //     return ssize{__builtin_ia32_lzcnt_u16(raw_value)};
    // } else if constexpr (sizeof(T) == 4) {
    // return ssize{__builtin_clz(raw_value)};
    // } else if constexpr (sizeof(T) == 8) {
    //     return ssize{__builtin_clzll(raw_value)};
    // } else {
    //     __builtin_unreachable();
    // }
}

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_trailing_zeros(T value) -> ssize {
    auto raw_value = to_raw_numeral(value);
    return ssize{__builtin_ctz(raw_value)};
    // if constexpr (sizeof(T) == 4) {
    //     return ssize{__builtin_ctz(raw_value)};
    // } else if constexpr (sizeof(T) == 8) {
    //     return ssize{__builtin_ctzll(raw_value)};
    // } else {
    //     __builtin_unreachable();
    // }
}

struct bool2 {  // NOLINT
    using Raw = uint2;
    uint2 raw;
    constexpr bool2() = default;
    constexpr bool2(bool input) : raw(static_cast<unsigned char>(input)){};
    constexpr operator bool() const {
        return this->raw != 0u;
    }
};

struct bool4 {  // NOLINT
    using Raw = uint4;
    uint4 raw;
    constexpr bool4() = default;
    constexpr bool4(bool input) : raw(static_cast<unsigned char>(input)){};
    constexpr bool4(bool2 input) : raw(static_cast<unsigned char>(input)){};
    constexpr operator bool() const {
        return this->raw != 0u;
    }
};

inline constexpr int1 int1_min = Limits<int1>::min();
inline constexpr int1 int1_max = Limits<int1>::max();
inline constexpr uint1 uint1_min = Limits<uint1>::min();
inline constexpr uint1 uint1_max = Limits<uint1>::max();
inline constexpr int2 int2_min = Limits<int2>::min();
inline constexpr int2 int2_max = Limits<int2>::max();
inline constexpr uint2 uint2_min = Limits<uint2>::min();
inline constexpr uint2 uint2_max = Limits<uint2>::max();
inline constexpr int4 int4_min = Limits<int4>::min();
inline constexpr int4 int4_max = Limits<int4>::max();
inline constexpr uint4 uint4_min = Limits<uint4>::min();
inline constexpr uint4 uint4_max = Limits<uint4>::max();
inline constexpr int8 int8_min = Limits<int8>::min();
inline constexpr int8 int8_max = Limits<int8>::max();
inline constexpr uint8 uint8_min = Limits<uint8>::min();
inline constexpr uint8 uint8_max = Limits<uint8>::max();

}  // namespace cat

constexpr auto operator""_i1(unsigned long long input) -> cat::int1 {
    return cat::int1{input};
}

constexpr auto operator""_i2(unsigned long long input) -> cat::int2 {
    return cat::int2{input};
}

constexpr auto operator""_i4(unsigned long long input) -> cat::int4 {
    return cat::int4{input};
}

constexpr auto operator""_i8(unsigned long long input) -> cat::int8 {
    return cat::int8{input};
}

constexpr auto operator""_sz(unsigned long long input) -> cat::ssize {
    return cat::ssize{input};
}

constexpr auto operator""_u1(unsigned long long input) -> cat::uint1 {
    return cat::uint1{input};
}

constexpr auto operator""_u2(unsigned long long input) -> cat::uint2 {
    return cat::uint2{input};
}

constexpr auto operator""_u4(unsigned long long input) -> cat::uint4 {
    return cat::uint4{input};
}

constexpr auto operator""_u8(unsigned long long input) -> cat::uint8 {
    return cat::uint8{input};
}

constexpr auto operator""_uz(unsigned long long input) -> cat::usize {
    return cat::usize{input};
}

constexpr auto operator""_f4(unsigned long long input) -> cat::float4 {
    return cat::float4{input};
}

constexpr auto operator""_f8(unsigned long long input) -> cat::float8 {
    return cat::float8{input};
}

using cat::bool2;
using cat::bool4;
using cat::float4;
using cat::float8;
using cat::int1;
using cat::int2;
using cat::int4;
using cat::int8;
using cat::ssize;
using cat::uint1;
using cat::uint2;
using cat::uint4;
using cat::uint8;
using cat::usize;

template <typename T>
using intptr = cat::intptr<T>;  // NOLINT
template <typename T>
using uintptr = cat::uintptr<T>;  // NOLINT

// `intptr` and `uintptr` are not trivial, but they can be trivially
// relocatable.
template <typename T>
    requires(cat::is_trivial<T> || cat::is_void<T>)
constexpr bool cat::is_trivially_relocatable<cat::intptr<T>> = true;
template <typename T>
    requires(cat::is_trivial<T> || cat::is_void<T>)
constexpr bool cat::is_trivially_relocatable<cat::uintptr<T>> = true;
