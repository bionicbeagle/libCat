// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/compare>
#include <cat/meta>

// `Numeral` is a container for numeric data types which prevents unsafe
// implicit type casts.
//
// All of its conversion operators, arithmetic operators and constructors
// are generic with constraints. Because these methods are constrained, it
// is possible that the compiler will fail to resolve any satisfying
// overloads for an invocation of an arithmetic operator, constructor, or
// conversion operator, and thus prevent compilation.
//
// Constraints such as "the operand's size must be less than or equal to my
// own size" guarantee that an unwanted overload cannot be resolved.
// This solution is concise, because any constraint broadly applies to all
// possible type conversions.

namespace cat {

template <typename>
struct NumericLimits {};

template <typename T>
struct NumericLimits<Numeral<T>> {
    NumericLimits() = delete;

    // Forward the underlying storage type to `.max`.
    static constexpr auto max = NumericLimits<T>::max;

    // Forward the underlying storage type to `.min`.
    static constexpr auto min = NumericLimits<T>::min;
};

// TODO: Implement `min` and `max` limits in terms of GCC macros, like
// `__LONG_LONG_MAX__`.

template <>
struct NumericLimits<char> {
    NumericLimits() = delete;
    static constexpr auto min() -> __INT8_TYPE__ {
        return -128;
    }
    static constexpr auto max() -> __INT8_TYPE__ {
        return 127;
    }

    static constexpr __INT8_TYPE__ digits = 7;
    static constexpr __INT8_TYPE__ digits10 = 2;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__INT8_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __INT8_TYPE__ {
        return -128;
    }
    static constexpr auto max() -> __INT8_TYPE__ {
        return 127;
    }

    static constexpr __INT8_TYPE__ digits = 7;
    static constexpr __INT8_TYPE__ digits10 = 2;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__UINT8_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __UINT8_TYPE__ {
        return 0u;
    }
    static constexpr auto max() -> __UINT8_TYPE__ {
        return 255u;
    }

    static constexpr __INT8_TYPE__ digits = 8;
    static constexpr __INT8_TYPE__ digits10 = 2;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__INT16_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __INT16_TYPE__ {
        return -32'768;
    }
    static constexpr auto max() -> __INT16_TYPE__ {
        return 32'767;
    }

    static constexpr __INT8_TYPE__ digits = 15;
    static constexpr __INT8_TYPE__ digits10 = 4;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__UINT16_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __UINT16_TYPE__ {
        return 0u;
    }
    static constexpr auto max() -> __UINT16_TYPE__ {
        return 65535u;
    }

    static constexpr __INT8_TYPE__ digits = 16;
    static constexpr __INT8_TYPE__ digits10 = 4;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__INT32_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __INT32_TYPE__ {
        return -2'147'483'648;
    }
    static constexpr auto max() -> __INT32_TYPE__ {
        return 2'147'483'647;
    }

    static constexpr __INT8_TYPE__ digits = 31;
    static constexpr __INT8_TYPE__ digits10 = 9;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__UINT32_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __UINT32_TYPE__ {
        return 0u;
    }
    static constexpr auto max() -> __UINT32_TYPE__ {
        return 4'294'967'295;
    }

    static constexpr __INT8_TYPE__ digits = 32;
    static constexpr __INT8_TYPE__ digits10 = 9;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__INT64_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __INT64_TYPE__ {
        return -9'223'372'036'854'775'807;
    }
    static constexpr auto max() -> __INT64_TYPE__ {
        return 9'223'372'036'854'775'807;
    }

    static constexpr __INT8_TYPE__ digits = 63;
    static constexpr __INT8_TYPE__ digits10 = 18;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__UINT64_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __UINT64_TYPE__ {
        return 0u;
    }
    static constexpr auto max() -> __UINT64_TYPE__ {
        return 18'446'744'073'709'551'615u;
    }

    static constexpr __INT8_TYPE__ digits = 64;
    static constexpr __INT8_TYPE__ digits10 = 19;
    static constexpr bool is_iec559 = false;
};

enum class FloatDenorm {
    indeterminate = -1,
    absent = 0,
    present = 1
};

enum class FloatRound {
    indeterminate = -1,
    toward_zero = 0,
    to_nearest = 1,
    toward_infinity = 2,
    toward_neg_infinity = 3
};

template <>
struct NumericLimits<float> {
    NumericLimits() = delete;
    static constexpr auto min() -> float {
        return __FLT_MIN__;
    }
    static constexpr auto max() -> float {
        return __FLT_MAX__;
    }

    static constexpr bool is_iec559 = true;
    static constexpr __INT32_TYPE__ radix = __FLT_RADIX__;
    static constexpr __INT32_TYPE__ digits = __FLT_MANT_DIG__;
    static constexpr __INT32_TYPE__ digits10 = __FLT_DIG__;
    static constexpr __INT32_TYPE__ max_digits10 =
        2 + __FLT_MANT_DIG__ * 643L / 2136;

    static constexpr auto epsilon() -> float {
        return __FLT_EPSILON__;
    }

    static constexpr __INT32_TYPE__ min_exponent = __FLT_MIN_EXP__;
    static constexpr __INT32_TYPE__ min_exponent10 = __FLT_MIN_10_EXP__;
    static constexpr __INT32_TYPE__ max_exponent = __FLT_MAX_EXP__;
    static constexpr __INT32_TYPE__ max_exponent10 = __FLT_MAX_10_EXP__;

    static constexpr bool has_infinity = __FLT_HAS_INFINITY__;
    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;
    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr bool has_signaling_NaN = has_quiet_NaN;
    static constexpr FloatDenorm has_denorm =
        static_cast<FloatDenorm>(__FLT_HAS_DENORM__);

    static constexpr auto infinity() -> float {
        return __builtin_huge_valf();
    }

    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr auto quiet_NaN() -> float {
        return __builtin_nanf("");
    }

    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr auto signaling_NaN() -> float {
        return __builtin_nansf("");
    }

    static constexpr auto denorm_min() -> float {
        return __FLT_DENORM_MIN__;
    }

    static constexpr FloatRound round_style = FloatRound::to_nearest;
};

template <>
struct NumericLimits<double> {
    NumericLimits() = delete;
    static constexpr auto min() -> float {
        return __DBL_MIN__;
    }
    static constexpr auto max() -> float {
        return __DBL_MAX__;
    }

    static constexpr bool is_iec559 = true;
    static constexpr __INT32_TYPE__ radix = __FLT_RADIX__;
    static constexpr __INT32_TYPE__ digits = __DBL_MANT_DIG__;
    static constexpr __INT32_TYPE__ digits10 = __DBL_DIG__;
    static constexpr __INT32_TYPE__ max_digits10 =
        2 + __DBL_MANT_DIG__ * 643L / 2136;

    static constexpr auto epsilon() -> float {
        return __DBL_EPSILON__;
    }

    static constexpr __INT32_TYPE__ min_exponent = __DBL_MIN_EXP__;
    static constexpr __INT32_TYPE__ min_exponent10 = __DBL_MIN_10_EXP__;
    static constexpr __INT32_TYPE__ max_exponent = __DBL_MAX_EXP__;
    static constexpr __INT32_TYPE__ max_exponent10 = __DBL_MAX_10_EXP__;

    static constexpr bool has_infinity = __DBL_HAS_INFINITY__;
    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;
    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr bool has_signaling_NaN = has_quiet_NaN;
    static constexpr FloatDenorm has_denorm =
        static_cast<FloatDenorm>(__DBL_HAS_DENORM__);

    static constexpr auto infinity() -> double {
        return __builtin_huge_val();
    }

    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr auto quiet_NaN() -> double {
        return __builtin_nan("");
    }

    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr auto signaling_NaN() -> double {
        return __builtin_nans("");
    }

    static constexpr auto denorm_min() -> double {
        return __DBL_DENORM_MIN__;
    }

    static constexpr FloatRound round_style = FloatRound::to_nearest;
};

// TODO: `NumericLimits<long double>`.

template <arithmetic T>
constexpr auto to_raw_numeral(T value) {
    if constexpr (safeNumeral<T>) {
        return value.raw;
    } else {
        return value;
    }
}

template <arithmetic T>
using ToUnsafeNumeral = decltype(to_raw_numeral(declval<T>()));

template <arithmetic T>
using ToSafeNumeral = Numeral<ToUnsafeNumeral<T>>;

namespace detail {
    template <arithmetic T, arithmetic U>
    constexpr auto is_safe_conversion() -> bool {
        using TRaw = ToUnsafeNumeral<T>;
        using URaw = ToUnsafeNumeral<U>;
        // clang-format off
        return (sizeof(TRaw) >= sizeof(URaw))
            // && (is_signed<TRaw> == is_signed<URaw>)
            && (is_floating_point<TRaw> == is_floating_point<URaw>);
        // clang-format on
    }

    // Satisfies any type that is an integer and is not `intptr` or `uintptr`.
    template <typename T>
    concept NonPtrIntegral =
        is_integral<T> && !is_specialization<T, ArithmeticPtr>;

    // Satisfies any arithmetic type that is not `intptr` or `uintptr`.
    template <typename T>
    concept ArithmeticNonPtr =
        is_arithmetic<T> && !is_specialization<T, ArithmeticPtr>;

    // Take two types, and produce the type that should be produced by their
    // arithmetic operations.
    template <typename T, typename U>
        requires(
            // is_signed<T> == is_signed<U> &&
            is_floating_point<T> == is_floating_point<U>)
    using PromotedNumeral =
        // `ArithmeticPtr` takes precedence above everything else.
        Conditional<is_specialization<T, ArithmeticPtr>, T,
                    Conditional<is_specialization<U, ArithmeticPtr>, U,
                                // Pick the largest type.
                                Conditional<(sizeof(T) > sizeof(U)), T, U>>>;
}  // namespace detail

template <typename T>
[[nodiscard]] constexpr auto count_leading_zeros(T value) -> ssize
    requires(is_integral<T>);

template <typename T>
[[nodiscard]] constexpr auto count_trailing_zeros(T value) -> ssize
    requires(is_integral<T>);

template <typename T>
struct Numeral {
    using Raw = T;

    constexpr Numeral() = default;

    template <arithmetic U>
    constexpr explicit(!detail::is_safe_conversion<T, U>()) Numeral(U from)
        : raw(to_raw_numeral(from)){};

    template <typename U>
    constexpr explicit operator U() const {
        return static_cast<U>(this->raw);
    }

    template <typename U>
        requires(detail::is_safe_conversion<T, U>())
    constexpr auto operator=(U operand) -> Numeral& {
        this->raw = static_cast<T>(operand);
        return *this;
    }

    template <arithmetic U>
    [[nodiscard]] friend constexpr auto operator<=>(Numeral<T> lhs, U rhs) {
        return lhs.raw <=> to_raw_numeral(rhs);
    }

    template <arithmetic U>
    [[nodiscard]] friend constexpr auto operator==(Numeral<T> lhs, U rhs)
        -> bool {
        return lhs.raw == to_raw_numeral(rhs);
    }

    // Declare arithmetic operators as hidden friends to prevent them from
    // pessimizing argument-dependant-lookup times.

    template <arithmetic U>
    [[nodiscard]] friend constexpr auto operator+(Numeral<T> self, U operand)
        -> Numeral<detail::PromotedNumeral<T, U>> {
        return self.raw + to_raw_numeral(operand);
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator+(U* p_operand,
                                                  Numeral<T> numeral) -> U* {
        return p_operand + numeral.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator+(Numeral<T> numeral,
                                                  U* p_operand) -> U* {
        return p_operand + numeral.raw;
    }

    template <arithmetic U>
    constexpr auto operator+=(U operand) {
        this->raw += to_raw_numeral(operand);
        return *this;
    }

    constexpr auto operator++() -> Numeral& {
        ++(this->raw);
        return *this;
    }

    constexpr auto operator++(int) -> Numeral& {
        (this->raw)++;
        return *this;
    }

    template <detail::ArithmeticNonPtr U>
    [[nodiscard]] friend constexpr auto operator-(Numeral<T> self, U operand)
        -> Numeral<detail::PromotedNumeral<T, U>> {
        return self.raw - to_raw_numeral(operand);
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator-(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand - self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator-(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand - self.raw;
    }

    template <typename U>
    constexpr auto operator-=(U operand)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->raw = this->raw - static_cast<T>(operand);
        return *this;
    }

    // TODO: Unary `-` operator.

    constexpr auto operator--() -> Numeral<T> {
        return --(this->raw);
    }

    constexpr auto operator--(int) -> Numeral<T> {
        return (this->raw)--;
    }

    template <detail::ArithmeticNonPtr U>
    [[nodiscard]] friend constexpr auto operator*(Numeral<T> self, U operand)
        -> Numeral<detail::PromotedNumeral<T, U>> {
        return self.raw * to_raw_numeral(operand);
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator*(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand * self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator*(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand * self.raw;
    }

    template <typename U>
    constexpr auto operator*=(U operand)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->raw = this->raw * static_cast<T>(operand);
        return *this;
    }

    template <detail::ArithmeticNonPtr U>
    [[nodiscard]] friend constexpr auto operator/(Numeral<T> self, U operand)
        -> Numeral<detail::PromotedNumeral<T, U>> {
        return self.raw / to_raw_numeral(operand);
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator/(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand / self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator/(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand / self.raw;
    }

    template <typename U>
    constexpr auto operator/=(U operand)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->raw = this->raw / static_cast<T>(operand);
        return *this;
    }

    template <detail::ArithmeticNonPtr U>
    [[nodiscard]] friend constexpr auto operator%(Numeral<T> self, U operand)
        -> Numeral<detail::PromotedNumeral<T, U>> {
        return self.raw % to_raw_numeral(operand);
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator%(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand % self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator%(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand % self.raw;
    }

    template <typename U>
    constexpr auto operator%=(U operand)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->raw = this->raw % static_cast<T>(operand);
        return *this;
    }

    template <detail::ArithmeticNonPtr U>
    [[nodiscard]] friend constexpr auto operator&(Numeral<T> self, U operand)
        -> Numeral<detail::PromotedNumeral<T, U>> {
        return self.raw & to_raw_numeral(operand);
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator&(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand & self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator&(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand & self.raw;
    }

    template <typename U>
    constexpr auto operator&=(U operand)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->raw = this->raw & static_cast<T>(operand);
        return *this;
    }

    template <detail::ArithmeticNonPtr U>
    [[nodiscard]] friend constexpr auto operator|(Numeral<T> self, U operand)
        -> Numeral<detail::PromotedNumeral<T, U>> {
        return self.raw | to_raw_numeral(operand);
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator|(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand | self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator|(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand | self.raw;
    }

    // TODO: Make more of these hidden `friend`s.

    template <typename U>
        requires(detail::is_safe_conversion<T, U>())
    constexpr auto operator|=(U operand) -> Numeral& {
        this->raw = this->raw | static_cast<T>(operand);
        return *this;
    }

    template <typename U>
        requires(detail::is_safe_conversion<T, U>())
    [[nodiscard]] constexpr auto operator<<(U operand) const -> Numeral<T> {
        return static_cast<T>(this->raw << static_cast<T>(operand));
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator<<(U* p_operand,
                                                   Numeral<T> self) -> U* {
        return p_operand << self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator<<(Numeral<T> self,
                                                   U* p_operand) -> U* {
        return p_operand << self.raw;
    }

    template <typename U>
    constexpr auto operator<<=(U operand)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->raw = this->raw << static_cast<T>(operand);
        return *this;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator>>(U operand) const -> Numeral<T>
        requires(detail::is_safe_conversion<T, U>())
    { return static_cast<T>(this->raw >> static_cast<T>(operand)); }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator>>(U* p_operand,
                                                   Numeral<T> self) -> U* {
        return p_operand >> self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator>>(Numeral<T> self,
                                                   U* p_operand) -> U* {
        return p_operand >> self.raw;
    }

    template <typename U>
        requires(detail::is_safe_conversion<T, U>())
    constexpr auto operator>>=(U operand) -> Numeral& {
        this->raw = this->raw >> static_cast<T>(operand);
        return *this;
    }

    [[nodiscard]] constexpr auto operator~() -> Numeral& {
        this->raw = ~(this->raw);
        return *this;
    }

    [[nodiscard]] constexpr auto count_leading_zeros() const -> ssize
        requires(is_integral<T>) {
        return cat::count_leading_zeros(this->raw);
    }

    [[nodiscard]] constexpr auto count_trailing_zeros() const -> ssize
        requires(is_integral<T>) {
        return cat::count_trailing_zeros(this->raw);
    }

    // `raw` is `public` for convenient access and to allow `cat::Numeral` to be
    // used as a non-type template parameter.
    T raw;

    // Making these `auto` solves a clang-tidy false diagnostic.
    // TODO: These should be type `Numeral<T>`.
    static constexpr auto min = NumericLimits<Raw>::min;
    static constexpr auto max = NumericLimits<Raw>::max;
};

template <typename T>
Numeral(T) -> Numeral<T>;

// Add and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator+=(T*& p_lhs, Numeral<U> rhs) -> T* {
    p_lhs += rhs.raw;
    return p_lhs;
}

// Subtract and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator-=(T*& p_lhs, Numeral<U> rhs) -> T* {
    p_lhs -= rhs.raw;
    return p_lhs;
}

// Multiply and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator*=(T*& p_lhs, Numeral<U> rhs) -> T* {
    p_lhs *= rhs.raw;
    return p_lhs;
}

// Divide and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator/=(T*& p_lhs, Numeral<U> rhs) -> T* {
    p_lhs /= rhs.raw;
    return p_lhs;
}

// Bitwise shift left and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator<<=(T*& p_lhs, Numeral<U> rhs) -> T* {
    p_lhs <<= rhs.raw;
    return p_lhs;
}

// Bitwise shift right and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator>>=(T*& p_lhs, Numeral<U> rhs) -> T* {
    p_lhs >>= rhs.raw;
    return p_lhs;
}

// Bitwise modulo and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator%=(T*& p_lhs, Numeral<U> rhs) -> T* {
    p_lhs %= rhs.raw;
    return p_lhs;
}

// Bitwise and and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator&=(T*& p_lhs, Numeral<U> rhs) -> T* {
    p_lhs &= rhs.raw;
    return p_lhs;
}

// Bitwise or and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator|=(T*& p_lhs, Numeral<U> rhs) -> T* {
    p_lhs |= rhs.raw;
    return p_lhs;
}

template <typename T>
[[nodiscard]] constexpr auto count_leading_zeros(T value) -> ssize
    requires(is_integral<T>) {
    auto raw_value = to_raw_numeral(value);
    if constexpr (sizeof(T) == 2) {
        return ssize{__builtin_ia32_lzcnt_u16(raw_value)};
    } else if constexpr (sizeof(T) == 4) {
        return ssize{__builtin_clz(raw_value)};
    } else if constexpr (sizeof(T) == 8) {
        return ssize{__builtin_clzll(raw_value)};
    } else {
        __builtin_unreachable();
    }
}

// TODO: Make this `constexpr`.
template <typename T>
[[nodiscard]] constexpr auto count_trailing_zeros(T value) -> ssize
    requires(is_integral<T>) {
    auto raw_value = to_raw_numeral(value);
    if constexpr (sizeof(T) == 4) {
        return ssize{__builtin_ctz(raw_value)};
    } else if constexpr (sizeof(T) == 8) {
        return ssize{__builtin_ctzll(raw_value)};
    }
    __builtin_unreachable();
}

// These macros are defined by the GCC compiler.
using int1 = cat::Numeral<__INT8_TYPE__>;
using uint1 = cat::Numeral<__UINT8_TYPE__>;
using int2 = cat::Numeral<__INT16_TYPE__>;
using uint2 = cat::Numeral<__UINT16_TYPE__>;
using int4 = cat::Numeral<__INT32_TYPE__>;
using uint4 = cat::Numeral<__UINT32_TYPE__>;
using int8 = cat::Numeral<__INT64_TYPE__>;
using uint8 = cat::Numeral<__UINT64_TYPE__>;
// using i128 = cat::Numeral<int128_t>;
// using u128 = cat::Numeral<uint128_t>;

using float4 = cat::Numeral<float>;
using float8 = cat::Numeral<double>;

using usize = cat::Numeral<__SIZE_TYPE__>;
// TODO: Support word size of `4`:
using ssize = cat::Numeral<long int>;

struct bool2 {  // NOLINT
    using Raw = uint2;
    uint2 raw;
    constexpr bool2() = default;
    constexpr bool2(bool input) : raw(static_cast<unsigned char>(input)){};
    constexpr operator bool() const {
        return this->raw != 0u;
    }
};

struct bool4 {  // NOLINT
    using Raw = uint4;
    uint4 raw;
    constexpr bool4() = default;
    constexpr bool4(bool input) : raw(static_cast<unsigned char>(input)){};
    constexpr bool4(bool2 input) : raw(static_cast<unsigned char>(input)){};
    constexpr operator bool() const {
        return this->raw != 0u;
    }
};

// `ArithmeticPtr` can be constructed from any integer type or any pointer. It
// can only convert into `T*`, but it is otherwise interchangeable with
// integers. It satisfies the `is_integral` type trait and
// `Integral` concept.
template <typename T, typename Storage>
struct ArithmeticPtr {
    using Raw = Storage;

    constexpr ArithmeticPtr() = default;
    constexpr ArithmeticPtr(ArithmeticPtr<T, Storage> const&) = default;
    constexpr ArithmeticPtr(ArithmeticPtr<T, Storage>&& input) = default;

    constexpr ArithmeticPtr(detail::NonPtrIntegral auto input)
        : raw(static_cast<Storage>(input)){};

    constexpr ArithmeticPtr(T* p_input) {
        this->raw = reinterpret_cast<Storage>(p_input);
    }

    constexpr operator T*() {
        return reinterpret_cast<T*>(this->raw);
    }

    constexpr operator T*() const {
        return reinterpret_cast<T const*>(this->raw);
    }

    constexpr explicit operator Storage() const {
        return this->raw;
    }

    constexpr auto operator=(ArithmeticPtr<T, Storage> const& from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = from.raw;
        return *this;
    }

    constexpr auto operator=(ArithmeticPtr<T, Storage>&& from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = cat::move(from).raw;
        return *this;
    }

    constexpr auto operator=(detail::NonPtrIntegral auto from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = static_cast<Storage>(from);
        return *this;
    }

    // TODO: Make more of these `friend`.

    template <typename U>
    [[nodiscard]] constexpr auto operator<=>(
        ArithmeticPtr<U, Storage> from) const {
        return this->raw <=> from.raw;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator!=(
        ArithmeticPtr<U, Storage> from) const {
        return this->raw != from.raw;
    }

    [[nodiscard]] constexpr auto operator+(ArithmeticPtr<T, Storage> rhs)
        -> ArithmeticPtr {
        return this->raw + rhs.raw;
    }

    template <typename U>
    constexpr auto operator+=(ArithmeticPtr<U, Storage> from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw += from.raw;
        return *this;
    }
    constexpr auto operator+=(detail::NonPtrIntegral auto from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw += static_cast<Storage>(from);
        return *this;
    }

    constexpr auto operator++() -> ArithmeticPtr<T, Storage> {
        return ++(this->raw);
    }

    constexpr auto operator++(int) -> ArithmeticPtr<T, Storage> {
        return (this->raw)++;
    }

    template <typename U>
    constexpr auto operator-=(ArithmeticPtr<U, Storage> from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw - static_cast<Storage>(from);
        return *this;
    }
    constexpr auto operator-=(detail::NonPtrIntegral auto from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw - static_cast<Storage>(from);
        return *this;
    }

    constexpr auto operator--() -> ArithmeticPtr<T, Storage> {
        return --(this->raw);
    }

    constexpr auto operator--(int) -> ArithmeticPtr<T, Storage> {
        return (this->raw)--;
    }

    template <typename U>
    constexpr auto operator*=(ArithmeticPtr<U, Storage> from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw * static_cast<Storage>(from);
        return *this;
    }
    constexpr auto operator*=(detail::NonPtrIntegral auto from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw * static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator/(ArithmeticPtr<U, Storage> from) const
        -> ArithmeticPtr<T, Storage> {
        return this->raw / from.raw;
    }
    [[nodiscard]] constexpr auto operator/(
        detail::NonPtrIntegral auto from) const -> ArithmeticPtr<T, Storage> {
        return this->raw / static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator/=(ArithmeticPtr<U, Storage> from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw / from.raw;
        return *this;
    }
    constexpr auto operator/=(detail::NonPtrIntegral auto from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw / static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator%(ArithmeticPtr<U, Storage> from) const
        -> ArithmeticPtr<T, Storage> {
        return this->raw % from.raw;
    }
    [[nodiscard]] constexpr auto operator%(
        detail::NonPtrIntegral auto from) const -> ArithmeticPtr<T, Storage> {
        return this->raw % static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator%=(ArithmeticPtr<U, Storage> from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw % from.raw;
        return *this;
    }
    constexpr auto operator%=(detail::NonPtrIntegral auto from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw % static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator&=(ArithmeticPtr<U, Storage> from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw & from.raw;
        return *this;
    }
    constexpr auto operator&=(detail::NonPtrIntegral auto from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw & static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator|(ArithmeticPtr<U, Storage> from) const
        -> ArithmeticPtr<T, Storage> {
        return this->raw | from.raw;
    }
    [[nodiscard]] constexpr auto operator|(
        detail::NonPtrIntegral auto from) const -> ArithmeticPtr<T, Storage> {
        return this->raw | static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator|=(ArithmeticPtr<U, Storage> from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw | from.raw;
        return *this;
    }
    constexpr auto operator|=(detail::NonPtrIntegral auto from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw | static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator<<(
        ArithmeticPtr<U, Storage> from) const -> ArithmeticPtr<T, Storage> {
        return this->raw << from.raw;
    }
    [[nodiscard]] constexpr auto operator<<(
        detail::NonPtrIntegral auto from) const -> ArithmeticPtr<T, Storage> {
        return this->raw << static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator<<=(ArithmeticPtr<U, Storage> from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw << from.raw;
        return *this;
    }
    constexpr auto operator<<=(detail::NonPtrIntegral auto from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw << static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    [[nodiscard]] constexpr auto operator>>(
        ArithmeticPtr<U, Storage> from) const -> ArithmeticPtr<T, Storage> {
        return this->raw >> from.raw;
    }
    [[nodiscard]] constexpr auto operator>>(
        detail::NonPtrIntegral auto from) const -> ArithmeticPtr<T, Storage> {
        return this->raw >> static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator>>=(ArithmeticPtr<U, Storage> from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw >> from.raw;
        return *this;
    }
    constexpr auto operator>>=(detail::NonPtrIntegral auto from)
        -> ArithmeticPtr<T, Storage>& {
        this->raw = this->raw >> static_cast<Storage>(from);
        return *this;
    }

    constexpr auto operator~() -> ArithmeticPtr<T, Storage>& {
        this->raw = ~(this->raw);
        return *this;
    }

    // TODO: `min` and `max` members.

    // `raw` is `public` for convenient access and to allow `cat::Numeral` to be
    // used as a non-type template parameter.
    Raw raw;
};

// Order-independant operators between an `ArithmeticPtr` and a pointer.
template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator<=>(ArithmeticPtr<T, Storage> lhs,
                                         T* p_rhs) {
    return lhs.raw <=> ArithmeticPtr<T, Storage>{p_rhs}.raw;
}

template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator!=(ArithmeticPtr<T, Storage> lhs, T* p_rhs)
    -> bool {
    return lhs.raw != ArithmeticPtr<T, Storage>{p_rhs}.raw;
}

template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator-(ArithmeticPtr<T, Storage> lhs, T* p_rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.raw - ArithmeticPtr<T, Storage>{p_rhs}.raw;
}

template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator*(ArithmeticPtr<T, Storage> lhs, T* p_rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.raw * ArithmeticPtr<T, Storage>{p_rhs}.raw;
}

template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator&(ArithmeticPtr<T, Storage> lhs, T* p_rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.raw & ArithmeticPtr<T, Storage>{p_rhs}.raw;
}

template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator|(ArithmeticPtr<T, Storage> lhs, T* p_rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.raw | ArithmeticPtr<T, Storage>{p_rhs}.raw;
}

// Order-independant operators between an `ArithmeticPtr<T>` and an integer.
template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator<=>(ArithmeticPtr<T, Storage> lhs,
                                         detail::NonPtrIntegral auto rhs) {
    return lhs.raw <=> rhs;
}

template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator!=(ArithmeticPtr<T, Storage> lhs,
                                        detail::NonPtrIntegral auto rhs)
    -> bool {
    return lhs.raw != rhs;
}

template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator-(ArithmeticPtr<T, Storage> lhs,
                                       detail::NonPtrIntegral auto rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.raw - static_cast<Storage>(rhs);
}

template <typename T, typename U, typename Storage>
[[nodiscard]] constexpr auto operator-(ArithmeticPtr<T, Storage> lhs,
                                       ArithmeticPtr<U, Storage> rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.raw - rhs.raw;
}

template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator*(ArithmeticPtr<T, Storage> lhs,
                                       detail::NonPtrIntegral auto rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.raw * ArithmeticPtr<T, Storage>{rhs}.raw;
}

template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator&(ArithmeticPtr<T, Storage> lhs,
                                       detail::NonPtrIntegral auto rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.raw & ArithmeticPtr<T, Storage>{rhs}.raw;
}

template <typename T, typename Storage>
[[nodiscard]] constexpr auto operator|(ArithmeticPtr<T, Storage> lhs,
                                       detail::NonPtrIntegral auto rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.raw | ArithmeticPtr<T, Storage>{rhs}.raw;
}

// `__INTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using intptr = cat::ArithmeticPtr<T, __INTPTR_TYPE__>;  // NOLINT
// `__UINTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using uintptr = cat::ArithmeticPtr<T, __UINTPTR_TYPE__>;  // NOLINT

}  // namespace cat

constexpr auto operator""_i1(unsigned long long input) -> cat::int1 {
    return cat::int1{input};
}

constexpr auto operator""_i2(unsigned long long input) -> cat::int2 {
    return cat::int2{input};
}

constexpr auto operator""_i4(unsigned long long input) -> cat::int4 {
    return cat::int4{input};
}

constexpr auto operator""_i8(unsigned long long input) -> cat::int8 {
    return cat::int8{input};
}

constexpr auto operator""_sz(unsigned long long input) -> cat::ssize {
    return cat::ssize{input};
}

constexpr auto operator""_u1(unsigned long long input) -> cat::uint1 {
    return cat::uint1{input};
}

constexpr auto operator""_u2(unsigned long long input) -> cat::uint2 {
    return cat::uint2{input};
}

constexpr auto operator""_u4(unsigned long long input) -> cat::uint4 {
    return cat::uint4{input};
}

constexpr auto operator""_u8(unsigned long long input) -> cat::uint8 {
    return cat::uint8{input};
}

constexpr auto operator""_uz(unsigned long long input) -> cat::usize {
    return cat::usize{input};
}

using cat::bool2;
using cat::bool4;
using cat::float4;
using cat::float8;
using cat::int1;
using cat::int2;
using cat::int4;
using cat::int8;
using cat::ssize;
using cat::uint1;
using cat::uint2;
using cat::uint4;
using cat::uint8;
using cat::usize;

template <typename T>
using intptr = cat::intptr<T>;  // NOLINT
template <typename T>
using uintptr = cat::uintptr<T>;  // NOLINT
