// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/compare>

// `Numeral` and `ArithmeticPtr` are containers for numeric data types which
// prevents unsafe implicit type casts.
//
// All of their conversion operators, arithmetic operators and constructors
// are generic with constraints. Because these methods are constrained, it
// is possible that the compiler will fail to resolve any satisfying
// overloads for an invocation of an operator or constructor, and thus prevent
// compilation.
//
// Constraints such as "the operand's size must be less than or equal to my
// own size" guarantee that an unwanted overload cannot be resolved.
// This solution is concise, because any constraint broadly applies to all
// possible type conversions.

namespace cat {

// TODO: Implement support for GCC 13's `__bf16` type.
// TODO: Implement support for complex floats.

template <typename>
struct NumericLimits {};

// Unwrap all `Numeral`s inside of `NumericLimits`.
template <typename T, OverflowPolicies policy>
struct NumericLimits<Numeral<T, policy>> : NumericLimits<T> {};

// TODO: Implement `min` and `max` limits in terms of GCC macros, like
// `__LONG_LONG_MAX__`.

template <>
struct NumericLimits<char> {
    NumericLimits() = delete;
    static constexpr auto min() -> __INT8_TYPE__ {
        return -128;
    }
    static constexpr auto max() -> __INT8_TYPE__ {
        return 127;
    }

    static constexpr __INT8_TYPE__ digits = 7;
    static constexpr __INT8_TYPE__ digits10 = 2;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__INT8_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __INT8_TYPE__ {
        return -128;
    }
    static constexpr auto max() -> __INT8_TYPE__ {
        return 127;
    }

    static constexpr __INT8_TYPE__ digits = 7;
    static constexpr __INT8_TYPE__ digits10 = 2;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__UINT8_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __UINT8_TYPE__ {
        return 0u;
    }
    static constexpr auto max() -> __UINT8_TYPE__ {
        return 255u;
    }

    static constexpr __INT8_TYPE__ digits = 8;
    static constexpr __INT8_TYPE__ digits10 = 2;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__INT16_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __INT16_TYPE__ {
        return -32'768;
    }
    static constexpr auto max() -> __INT16_TYPE__ {
        return 32'767;
    }

    static constexpr __INT8_TYPE__ digits = 15;
    static constexpr __INT8_TYPE__ digits10 = 4;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__UINT16_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __UINT16_TYPE__ {
        return 0u;
    }
    static constexpr auto max() -> __UINT16_TYPE__ {
        return 65535u;
    }

    static constexpr __INT8_TYPE__ digits = 16;
    static constexpr __INT8_TYPE__ digits10 = 4;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__INT32_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __INT32_TYPE__ {
        return -2'147'483'648;
    }
    static constexpr auto max() -> __INT32_TYPE__ {
        return 2'147'483'647;
    }

    static constexpr __INT8_TYPE__ digits = 31;
    static constexpr __INT8_TYPE__ digits10 = 9;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__UINT32_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __UINT32_TYPE__ {
        return 0u;
    }
    static constexpr auto max() -> __UINT32_TYPE__ {
        return 4'294'967'295;
    }

    static constexpr __INT8_TYPE__ digits = 32;
    static constexpr __INT8_TYPE__ digits10 = 9;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__INT64_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __INT64_TYPE__ {
        return -9'223'372'036'854'775'807;
    }
    static constexpr auto max() -> __INT64_TYPE__ {
        return 9'223'372'036'854'775'807;
    }

    static constexpr __INT8_TYPE__ digits = 63;
    static constexpr __INT8_TYPE__ digits10 = 18;
    static constexpr bool is_iec559 = false;
};

template <>
struct NumericLimits<__UINT64_TYPE__> {
    NumericLimits() = delete;
    static constexpr auto min() -> __UINT64_TYPE__ {
        return 0u;
    }
    static constexpr auto max() -> __UINT64_TYPE__ {
        return 18'446'744'073'709'551'615u;
    }

    static constexpr __INT8_TYPE__ digits = 64;
    static constexpr __INT8_TYPE__ digits10 = 19;
    static constexpr bool is_iec559 = false;
};

enum class FloatDenorm {
    indeterminate = -1,
    absent = 0,
    present = 1
};

enum class FloatRound {
    indeterminate = -1,
    toward_zero = 0,
    to_nearest = 1,
    toward_infinity = 2,
    toward_neg_infinity = 3
};

template <>
struct NumericLimits<float> {
    NumericLimits() = delete;
    static constexpr auto min() -> float {
        return __FLT_MIN__;
    }
    static constexpr auto max() -> float {
        return __FLT_MAX__;
    }

    static constexpr bool is_iec559 = true;
    static constexpr __INT32_TYPE__ radix = __FLT_RADIX__;
    static constexpr __INT32_TYPE__ digits = __FLT_MANT_DIG__;
    static constexpr __INT32_TYPE__ digits10 = __FLT_DIG__;
    static constexpr __INT32_TYPE__ max_digits10 =
        2 + __FLT_MANT_DIG__ * 643L / 2136;

    static constexpr auto epsilon() -> float {
        return __FLT_EPSILON__;
    }

    static constexpr __INT32_TYPE__ min_exponent = __FLT_MIN_EXP__;
    static constexpr __INT32_TYPE__ min_exponent10 = __FLT_MIN_10_EXP__;
    static constexpr __INT32_TYPE__ max_exponent = __FLT_MAX_EXP__;
    static constexpr __INT32_TYPE__ max_exponent10 = __FLT_MAX_10_EXP__;

    static constexpr bool has_infinity = __FLT_HAS_INFINITY__;
    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;
    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr bool has_signaling_NaN = has_quiet_NaN;
    static constexpr FloatDenorm has_denorm =
        static_cast<FloatDenorm>(__FLT_HAS_DENORM__);

    static constexpr auto infinity() -> float {
        return __builtin_huge_valf();
    }

    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr auto quiet_NaN() -> float {
        return __builtin_nanf("");
    }

    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr auto signaling_NaN() -> float {
        return __builtin_nansf("");
    }

    // TODO: Use GCC 13's `__builtin_issignalling()`.

    static constexpr auto denorm_min() -> float {
        return __FLT_DENORM_MIN__;
    }

    static constexpr FloatRound round_style = FloatRound::to_nearest;
};

template <>
struct NumericLimits<double> {
    NumericLimits() = delete;
    static constexpr auto min() -> float {
        return __DBL_MIN__;
    }
    static constexpr auto max() -> float {
        return __DBL_MAX__;
    }

    static constexpr bool is_iec559 = true;
    static constexpr __INT32_TYPE__ radix = __FLT_RADIX__;
    static constexpr __INT32_TYPE__ digits = __DBL_MANT_DIG__;
    static constexpr __INT32_TYPE__ digits10 = __DBL_DIG__;
    static constexpr __INT32_TYPE__ max_digits10 =
        2 + __DBL_MANT_DIG__ * 643L / 2136;

    static constexpr auto epsilon() -> float {
        return __DBL_EPSILON__;
    }

    static constexpr __INT32_TYPE__ min_exponent = __DBL_MIN_EXP__;
    static constexpr __INT32_TYPE__ min_exponent10 = __DBL_MIN_10_EXP__;
    static constexpr __INT32_TYPE__ max_exponent = __DBL_MAX_EXP__;
    static constexpr __INT32_TYPE__ max_exponent10 = __DBL_MAX_10_EXP__;

    static constexpr bool has_infinity = __DBL_HAS_INFINITY__;
    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;
    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr bool has_signaling_NaN = has_quiet_NaN;
    static constexpr FloatDenorm has_denorm =
        static_cast<FloatDenorm>(__DBL_HAS_DENORM__);

    static constexpr auto infinity() -> double {
        return __builtin_huge_val();
    }

    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr auto quiet_NaN() -> double {
        return __builtin_nan("");
    }

    // NOLINTNEXTLINE Let this weird lettercase be used.
    static constexpr auto signaling_NaN() -> double {
        return __builtin_nans("");
    }

    static constexpr auto denorm_min() -> double {
        return __DBL_DENORM_MIN__;
    }

    static constexpr FloatRound round_style = FloatRound::to_nearest;
};

// TODO: `NumericLimits<long double>`.

enum class OverflowPolicies {
    undefined,
    wrapping,
    overflow
};

template <typename T>
inline constexpr bool is_arithmetic_ptr = requires {
    T::Ptr;
};

template <typename T>
constexpr auto to_raw_numeral(T value) {
    if constexpr (requires { value.raw; }) {
        return value.raw;
    } else {
        return value;
    }
}

template <typename T>
using ToRawNumeral = decltype(to_raw_numeral(T{0}));

// // TODO: Forward policy from a `Numeral`.
// template <typename T>
// using ToSafeNumeral = Numeral<ToRawNumeral<T>, OverflowPolicies::undefined>;

template <integral T>
constexpr auto make_signed(T value) -> MakeSigned<T> {
    return static_cast<MakeSigned<T>>(value);
}

template <integral T>
constexpr auto make_unsigned(T value) -> MakeUnsigned<T> {
    return static_cast<MakeUnsigned<T>>(value);
}

template <integral From, integral To>
constexpr auto make_sign_from(To value) -> CopySignFrom<From, To> {
    return static_cast<CopySignFrom<From, To>>(value);
}

// These macros are defined by the GCC compiler.
using int1 = Numeral<__INT8_TYPE__, OverflowPolicies::undefined>;
using uint1 = Numeral<__UINT8_TYPE__, OverflowPolicies::undefined>;
using int2 = Numeral<__INT16_TYPE__, OverflowPolicies::undefined>;
using uint2 = Numeral<__UINT16_TYPE__, OverflowPolicies::undefined>;
using int4 = Numeral<__INT32_TYPE__, OverflowPolicies::undefined>;
using uint4 = Numeral<__UINT32_TYPE__, OverflowPolicies::undefined>;
using int8 = Numeral<__INT64_TYPE__, OverflowPolicies::undefined>;
using uint8 = Numeral<__UINT64_TYPE__, OverflowPolicies::undefined>;
// using i128 = Numeral<int128_t, OverflowPolicies::undefined>;
// using u128 = Numeral<uint128_t, OverflowPolicies::undefined>;

using float4 = Numeral<float, OverflowPolicies::undefined>;
using float8 = Numeral<double, OverflowPolicies::undefined>;

using usize = Numeral<__SIZE_TYPE__, OverflowPolicies::undefined>;
using ssize = Numeral<MakeSigned<__SIZE_TYPE__>, OverflowPolicies::undefined>;

namespace detail {
    template <arithmetic From, arithmetic To>
    inline constexpr bool is_safe_comparison =
        // `ToRawNumeral` is needed here to prevent a recursive constraint
        // in evaluating the `<` operator.
        ((is_signed<ToRawNumeral<From>> == is_signed<ToRawNumeral<To>>)) &&
        (is_floating_point<From> == is_floating_point<To>);

    // Any numeral can safely convert to a type larger than itself, but not
    // smaller than itself.
    template <arithmetic From, arithmetic To>
    inline constexpr bool is_safe_conversion = (sizeof(From) <= sizeof(To)) &&
                                               (is_safe_comparison<From, To>);

    /*
    template <typename T, typename U>
    requires((is_signed<T> == is_signed<U>)&&(is_floating_point<T> ==
                                              is_floating_point<U>))
    using PromotedNumeral = Conditional<
    // `ArithmeticPtr` takes precedence above everything else.
    is_arithmetic_ptr<T>, T,
    Conditional<is_arithmetic_ptr<U>, U,
                // Otherwise, pick the largest raw type, and make it a
                // `Numeral`.
                Numeral<Conditional<(sizeof(T) >= sizeof(U)),
                                    ToRawNumeral<T>, ToRawNumeral<U>>,
                        // TODO: Get a correct policy.
                        OverflowPolicies::undefined>>>;
    */

    template <typename T, typename U>
    consteval auto promoted_numeral() {
        if constexpr (is_arithmetic_ptr<T>) {
            return T{};
        } else if constexpr (is_arithmetic_ptr<U>) {
            return U{};
        } else {
            if constexpr (sizeof(T) >= sizeof(U)) {
                return Numeral<ToRawNumeral<T>, OverflowPolicies::undefined>{};
            } else {
                return Numeral<ToRawNumeral<U>, OverflowPolicies::undefined>{};
            }
        }
    }

    template <typename T, typename U>
        requires((is_signed<T> == is_signed<U>)&&(is_floating_point<T> ==
                                                  is_floating_point<U>))
    using PromotedNumeral = decltype(promoted_numeral<T, U>());
}  // namespace detail

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_leading_zeros(T value) -> ssize;

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_trailing_zeros(T value) -> ssize;

// `Numeral` can represent an integer or floating point value. It prevents
// unsafe casts or operations. This is a trivial `struct` so it can be used as a
// non-type template parameter.
template <typename T, OverflowPolicies policy = OverflowPolicies::undefined>
struct Numeral {
    using Raw = T;

    constexpr Numeral() = default;

    template <arithmetic U>
    constexpr explicit(!detail::is_safe_conversion<U, T>) Numeral(U from)
        : raw(to_raw_numeral(from)){};

    // TODO: Cast to `uintptr<T>`.
    template <typename U>
    // requires(!is_pointer<U>)
    constexpr explicit operator U() const {
        return static_cast<U>(this->raw);
    }

    template <typename U>
        requires(detail::is_safe_conversion<U, T>)
    constexpr auto operator=(U operand) -> Numeral& {
        this->raw = to_raw_numeral(operand);
        return *this;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator<=>(Numeral<T> lhs, U rhs) {
        return lhs.raw <=> to_raw_numeral(rhs);
    }

    // A `!=` operator is not generated by `<=>`, but overloading `!=` prevents
    // generating `==`. Instead, `==` is explicitly provided to generate `!=`.
    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator==(Numeral<T> lhs, U rhs)
        -> bool {
        return lhs.raw == to_raw_numeral(rhs);
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator+(Numeral<T> self, U operand)
        -> detail::PromotedNumeral<T, U> {
        return detail::PromotedNumeral<T, U>{self.raw +
                                             to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator+(U* p_operand,
                                                  Numeral<T> numeral) -> U* {
        return p_operand + numeral.raw;
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator+(Numeral<T> numeral,
                                                  U* p_operand) -> U* {
        return numeral.raw + p_operand;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator+=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw += to_raw_numeral(operand);
        return self;
    }

    [[nodiscard]] friend constexpr auto operator+(Numeral<T, policy> self)
        -> Numeral {
        return +(self.raw);
    }

    friend constexpr auto operator++(Numeral<T, policy> self) -> Numeral {
        return ++(self.raw);
    }

    friend constexpr auto operator++(Numeral<T, policy> self, int) -> Numeral {
        return (self.raw)++;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator-(Numeral<T> self, U operand)
        -> detail::PromotedNumeral<T, U> {
        return detail::PromotedNumeral<T, U>{self.raw -
                                             to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator-(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand - self.raw;
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator-(Numeral<T> numeral,
                                                  U* p_operand) -> U* {
        return numeral.raw - p_operand;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    friend constexpr auto operator-=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw -= to_raw_numeral(operand);
        return self;
    }

    [[nodiscard]] friend constexpr auto operator-(Numeral<T, policy> self)
        -> Numeral {
        return -(self.raw);
    }

    friend constexpr auto operator--(Numeral<T, policy> self) -> Numeral {
        return --(self.raw);
    }

    friend constexpr auto operator--(Numeral<T, policy> self, int) -> Numeral {
        return (self.raw)--;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator*(Numeral<T> self, U operand)
        -> detail::PromotedNumeral<T, U> {
        return detail::PromotedNumeral<T, U>{self.raw *
                                             to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator*(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand * self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator*(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand * self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator*=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw *= to_raw_numeral(operand);
        return self;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator/(Numeral<T> self, U operand)
        -> detail::PromotedNumeral<T, U> {
        return detail::PromotedNumeral<T, U>{self.raw /
                                             to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator/(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand / self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator/(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand / self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator/=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw /= to_raw_numeral(operand);
        return self;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator%(Numeral<T> self, U operand)
        -> detail::PromotedNumeral<T, U> {
        return detail::PromotedNumeral<T, U>{self.raw %
                                             to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator%(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand % self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator%(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand % self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator%=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw %= to_raw_numeral(operand);
        return self;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator&(Numeral<T> self, U operand)
        -> detail::PromotedNumeral<T, U> {
        return detail::PromotedNumeral<T, U>{self.raw &
                                             to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator&(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand & self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator&(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand & self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator&=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw &= to_raw_numeral(operand);
        return self;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    [[nodiscard]] friend constexpr auto operator|(Numeral<T> self, U operand)
        -> detail::PromotedNumeral<T, U> {
        return detail::PromotedNumeral<T, U>{self.raw |
                                             to_raw_numeral(operand)};
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator|(U* p_operand, Numeral<T> self)
        -> U* {
        return p_operand | self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator|(Numeral<T> self, U* p_operand)
        -> U* {
        return p_operand | self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator|=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw |= to_raw_numeral(operand);
        return self;
    }

    template <typename U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator<<(Numeral<T, policy> self,
                                                   U operand) -> Numeral<T> {
        return self.raw << to_raw_numeral(operand);
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator<<(U* p_operand,
                                                   Numeral<T> self) -> U* {
        return p_operand << self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator<<(Numeral<T> self,
                                                   U* p_operand) -> U* {
        return p_operand << self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator<<=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw <<= to_raw_numeral(operand);
        return self;
    }

    template <typename U>
        requires(detail::is_safe_comparison<T, U>)
    [[nodiscard]] friend constexpr auto operator>>(Numeral<T, policy> self,
                                                   U operand) -> Numeral<T> {
        return self.raw >> to_raw_numeral(operand);
    }

    template <typename U>
    [[nodiscard]] friend constexpr auto operator>>(U* p_operand,
                                                   Numeral<T> self) -> U* {
        return p_operand >> self.raw;
    }
    template <typename U>
    [[nodiscard]] friend constexpr auto operator>>(Numeral<T> self,
                                                   U* p_operand) -> U* {
        return p_operand >> self.raw;
    }

    template <arithmetic U>
        requires(detail::is_safe_comparison<U, T>)
    friend constexpr auto operator>>=(Numeral<T, policy>& self, U operand)
        -> Numeral& {
        self.raw >>= to_raw_numeral(operand);
        return self;
    }

    [[nodiscard]] friend constexpr auto operator~(Numeral<T, policy> self)
        -> Numeral requires(is_integral<T>) {
        return ~(self.raw);
    }

    // Member functions for all numerals.

    [[nodiscard]] constexpr auto count_leading_zeros() const -> ssize
        requires(is_integral<T>) {
        return cat::count_leading_zeros(this->raw);
    }

    [[nodiscard]] constexpr auto count_trailing_zeros() const -> ssize
        requires(is_integral<T>) {
        return cat::count_trailing_zeros(this->raw);
    }

    // `raw` is `public` for convenient access and to allow `cat::Numeral`
    // to be used as a non-type template parameter.
    T raw;

    // Making these `auto` solves a clang-tidy false diagnostic.
    // TODO: These should be type `Numeral<T>`.
    static constexpr auto min = NumericLimits<Raw>::min;
    static constexpr auto max = NumericLimits<Raw>::max;
};

// TODO: Is this needed?
template <typename T>
Numeral(T) -> Numeral<T>;

// `ArithmeticPtr` can be constructed from any integer type or any pointer.
// It can only convert into `T*`, but it is otherwise interchangeable with
// integers. It satisfies the `is_integral` type trait and
// `integral` concept.
template <typename T, typename Storage,
          OverflowPolicies policy = OverflowPolicies::undefined>
class ArithmeticPtr : public Numeral<Storage, policy> {
  public:
    using Raw = Storage;
    using Ptr = T*;

    // TODO: Can these be `default`?

    constexpr ArithmeticPtr() : Numeral<Storage, policy>(){};

    constexpr ArithmeticPtr(ArithmeticPtr<T, Storage, policy> const& other)
        : Numeral<Storage, policy>(other.raw){};

    constexpr ArithmeticPtr(ArithmeticPtr<T, Storage, policy>&& other)
        : Numeral<Storage, policy>(move(other).raw){};

    // Forward other integrals to the `Numeral` class.
    constexpr ArithmeticPtr(integral auto input)
        : Numeral<Storage, policy>(to_raw_numeral(input)){};

    constexpr ArithmeticPtr(T* p_input)
        : Numeral<Storage, policy>(reinterpret_cast<Storage>(p_input)) {
    }

    // Only allow casting back into the original pointer type.
    explicit constexpr operator T*() {
        return reinterpret_cast<T*>(this->raw);
    }

    // Only allow casting back into the original pointer type.
    explicit constexpr operator T*() const {
        return reinterpret_cast<T const*>(this->raw);
    }

    constexpr explicit operator Storage() const {
        return this->raw;
    }

    // TODO: Streamline out these operators by implementing `Numeral`'s with
    // "deducing this".

    constexpr auto operator=(ArithmeticPtr<T, Storage, policy> from)
        -> ArithmeticPtr& {
        this->raw = from.raw;
        return *this;
    }

    template <integral U>
        requires(detail::is_safe_conversion<U, Storage>)
    constexpr auto operator=(U from) -> ArithmeticPtr& {
        this->raw = static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
        requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator<=>(
        ArithmeticPtr<T, Storage, policy> lhs, U rhs) {
        return lhs.raw <=> to_raw_numeral(rhs);
    }

    // A `!=` operator is not generated by `<=>`, but overloading `!=`
    // prevents generating `==`. Instead, `==` is explicitly provided to
    // generate `!=`.
    template <typename U>
        requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator==(
        ArithmeticPtr<T, Storage, policy> lhs, U rhs) -> bool {
        return lhs.raw == to_raw_numeral(rhs);
    }

    template <integral U>
    // TODO: This constraint causes GCC's ADL to be ambiguous.
    // requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator+(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw + to_raw_numeral(operand);
    }

    template <integral U>
        requires(detail::is_safe_comparison<U, Storage>)
    constexpr auto operator+=(U operand) {
        this->raw += to_raw_numeral(operand);
        return *this;
    }

    constexpr auto operator++() -> ArithmeticPtr& {
        ++(this->raw);
        return *this;
    }

    constexpr auto operator++(int) -> ArithmeticPtr& {
        (this->raw)++;
        return *this;
    }

    constexpr auto operator+() -> ArithmeticPtr<T, Storage, policy> {
        return +(this->raw);
    }

    // TODO: Should subtracting two pointers produce another pointer, or a
    // `ssize` similar to `ptrdiff_t`?

    template <integral U>
    // TODO: This constraint causes GCC's ADL to be ambiguous.
    // requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator-(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw - to_raw_numeral(operand);
    }

    template <typename U>
    // requires(detail::is_safe_comparison<Storage, U>)
    constexpr auto operator-=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw - to_raw_numeral(operand);
        return *this;
    }

    // TODO: Make this `friend`?
    constexpr auto operator-() -> ArithmeticPtr<T, Storage, policy> {
        return -(this->raw);
    }

    constexpr auto operator--() -> ArithmeticPtr<T, Storage, policy> {
        return --(this->raw);
    }

    constexpr auto operator--(int) -> ArithmeticPtr<T, Storage, policy> {
        return (this->raw)--;
    }

    template <integral U>
    // requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator*(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw * to_raw_numeral(operand);
    }

    template <typename U>
    // requires(detail::is_safe_comparison<Storage, U>)
    constexpr auto operator*=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw * to_raw_numeral(operand);
        return *this;
    }

    template <integral U>
    // requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator/(
        ArithmeticPtr<T, Storage, policy> self, U operand) -> ArithmeticPtr {
        return self.raw / to_raw_numeral(operand);
    }

    template <typename U>
    // requires(detail::is_safe_comparison<Storage, U>)
    constexpr auto operator/=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw / to_raw_numeral(operand);
        return *this;
    }

    template <integral U>
    // requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator%(
        ArithmeticPtr<T, Storage, policy> self, U operand)
        -> ArithmeticPtr<T, Storage, policy> {
        return self.raw % to_raw_numeral(operand);
    }

    template <typename U>
    // requires(detail::is_safe_comparison<Storage, U>)
    constexpr auto operator%=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw % to_raw_numeral(operand);
        return *this;
    }

    template <integral U>
    // requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] friend constexpr auto operator&(
        ArithmeticPtr<T, Storage, policy> self, U operand)
        -> ArithmeticPtr<T, Storage, policy> {
        return self.raw & to_raw_numeral(operand);
    }

    template <typename U>
    // requires(detail::is_safe_comparison<Storage, U>)
    constexpr auto operator&=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw & to_raw_numeral(operand);
        return *this;
    }

    template <integral U>
    // requires(detail::is_safe_comparison<U, Storage>)
    [[nodiscard]] friend constexpr auto operator|(
        ArithmeticPtr<T, Storage, policy> self, U operand)
        -> ArithmeticPtr<T, Storage, policy> {
        return self.raw | to_raw_numeral(operand);
    }

    // TODO: Make more of these hidden `friend`s.

    template <typename U>
    // requires(detail::is_safe_comparison<Storage, U>)
    constexpr auto operator|=(U operand) -> ArithmeticPtr& {
        return *this;
    }

    template <typename U>
    // requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] constexpr auto operator<<(U operand) const
        -> ArithmeticPtr<T, Storage, policy> {
        return static_cast<Storage>(this->raw << to_raw_numeral(operand));
    }

    template <typename U>
    // requires(detail::is_safe_comparison<U, Storage>)
    constexpr auto operator<<=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw << to_raw_numeral(operand);
        return *this;
    }

    template <typename U>
    // requires(detail::is_safe_comparison<Storage, U>)
    [[nodiscard]] constexpr auto operator>>(U operand) const
        -> ArithmeticPtr<T, Storage, policy> {
        return static_cast<Storage>(this->raw >> to_raw_numeral(operand));
    }

    template <typename U>
    // requires(detail::is_safe_comparison<Storage, U>)
    constexpr auto operator>>=(U operand) -> ArithmeticPtr& {
        this->raw = this->raw >> to_raw_numeral(operand);
        return *this;
    }

    [[nodiscard]] constexpr auto operator~() -> ArithmeticPtr
        requires(is_integral<Storage>) {
        return ~(this->raw);
    }
};

// `__INTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using intptr = ArithmeticPtr<T, __INTPTR_TYPE__>;

// `__UINTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using uintptr = cat::ArithmeticPtr<T, __UINTPTR_TYPE__>;

// Add and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator+=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs += rhs.raw;
    return p_lhs;
}

// Subtract and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator-=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs -= rhs.raw;
    return p_lhs;
}

// Multiply and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator*=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs *= rhs.raw;
    return p_lhs;
}

// Divide and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator/=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs /= rhs.raw;
    return p_lhs;
}

// Bitwise shift left and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator<<=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs <<= rhs.raw;
    return p_lhs;
}

// Bitwise shift right and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator>>=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs >>= rhs.raw;
    return p_lhs;
}

// Bitwise modulo and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator%=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs %= rhs.raw;
    return p_lhs;
}

// Bitwise and and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator&=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs &= rhs.raw;
    return p_lhs;
}

// Bitwise or and assign a `Numeral` to a pointer.
template <typename T, typename U>
constexpr auto operator|=(T* p_lhs, Numeral<U> rhs) -> T* {
    p_lhs |= rhs.raw;
    return p_lhs;
}

template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_leading_zeros(T value) -> ssize {
    auto raw_value = to_raw_numeral(value);
    if constexpr (sizeof(T) == 2) {
        return ssize{__builtin_ia32_lzcnt_u16(raw_value)};
    } else if constexpr (sizeof(T) == 4) {
        return ssize{__builtin_clz(raw_value)};
    } else if constexpr (sizeof(T) == 8) {
        return ssize{__builtin_clzll(raw_value)};
    } else {
        __builtin_unreachable();
    }
}

// TODO: Make this `constexpr`.
template <typename T>
    requires(is_integral<T>)
[[nodiscard]] constexpr auto count_trailing_zeros(T value) -> ssize {
    auto raw_value = to_raw_numeral(value);
    if constexpr (sizeof(T) == 4) {
        return ssize{__builtin_ctz(raw_value)};
    } else if constexpr (sizeof(T) == 8) {
        return ssize{__builtin_ctzll(raw_value)};
    } else {
        __builtin_unreachable();
    }
}

struct bool2 {  // NOLINT
    using Raw = uint2;
    uint2 raw;
    constexpr bool2() = default;
    constexpr bool2(bool input) : raw(static_cast<unsigned char>(input)){};
    constexpr operator bool() const {
        return this->raw != 0u;
    }
};

struct bool4 {  // NOLINT
    using Raw = uint4;
    uint4 raw;
    constexpr bool4() = default;
    constexpr bool4(bool input) : raw(static_cast<unsigned char>(input)){};
    constexpr bool4(bool2 input) : raw(static_cast<unsigned char>(input)){};
    constexpr operator bool() const {
        return this->raw != 0u;
    }
};

}  // namespace cat

constexpr auto operator""_i1(unsigned long long input) -> cat::int1 {
    return cat::int1{input};
}

constexpr auto operator""_i2(unsigned long long input) -> cat::int2 {
    return cat::int2{input};
}

constexpr auto operator""_i4(unsigned long long input) -> cat::int4 {
    return cat::int4{input};
}

constexpr auto operator""_i8(unsigned long long input) -> cat::int8 {
    return cat::int8{input};
}

constexpr auto operator""_sz(unsigned long long input) -> cat::ssize {
    return cat::ssize{input};
}

constexpr auto operator""_u1(unsigned long long input) -> cat::uint1 {
    return cat::uint1{input};
}

constexpr auto operator""_u2(unsigned long long input) -> cat::uint2 {
    return cat::uint2{input};
}

constexpr auto operator""_u4(unsigned long long input) -> cat::uint4 {
    return cat::uint4{input};
}

constexpr auto operator""_u8(unsigned long long input) -> cat::uint8 {
    return cat::uint8{input};
}

constexpr auto operator""_uz(unsigned long long input) -> cat::usize {
    return cat::usize{input};
}

constexpr auto operator""_f4(unsigned long long input) -> cat::float4 {
    return cat::float4{input};
}

constexpr auto operator""_f8(unsigned long long input) -> cat::float8 {
    return cat::float8{input};
}

using cat::bool2;
using cat::bool4;
using cat::float4;
using cat::float8;
using cat::int1;
using cat::int2;
using cat::int4;
using cat::int8;
using cat::ssize;
using cat::uint1;
using cat::uint2;
using cat::uint4;
using cat::uint8;
using cat::usize;

template <typename T>
using intptr = cat::intptr<T>;  // NOLINT
template <typename T>
using uintptr = cat::uintptr<T>;  // NOLINT

// `intptr` and `uintptr` are not trivial, but they can be trivially
// relocatable.
template <typename T>
    requires(cat::is_trivial<T> || cat::is_void<T>)
constexpr bool cat::is_trivially_relocatable<cat::intptr<T>> = true;
template <typename T>
    requires(cat::is_trivial<T> || cat::is_void<T>)
constexpr bool cat::is_trivially_relocatable<cat::uintptr<T>> = true;
