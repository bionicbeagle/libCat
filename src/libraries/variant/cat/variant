// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/array>
#include <cat/memory>
#include <cat/meta>
#include <cat/type_list>
#include <utility>

namespace cat {

template <typename... Ts>
    requires(TypeList<Ts...>::is_unique_list)
class Variant {
  public:
    using Types = TypeList<Ts...>;

  private:
    static constexpr ssize raw_size = Types::largest_size;
    static constexpr usize::Raw alignment = Types::largest_alignment.raw;
    using Storage = Array<char, raw_size>;
    alignas(alignment) Storage storage;
    // TODO: Use the smallest `Numeral` that can hold at least `sizeof...(Ts)`
    // values.
    uint1 discriminant;

    template <typename T, ssize index>
        requires(index >= 0)
    static consteval auto get_index_of_type() -> uint1 {
        using IndexType = typename Types::template Get<index>;
        if constexpr (is_same<T, IndexType>) {
            return static_cast<uint1>(index);
        } else {
            return get_index_of_type<T, index - 1>();
        }
    }

    template <typename U, typename... Us>
        requires(sizeof...(Us) >= 0)
    constexpr void hard_reset() {
        if (this->holds_alternative<U>()) {
            this->get<U>().~U();
        } else {
            if constexpr (sizeof...(Us) > 0) {
                this->hard_reset<Us...>();
            }
        }
    }

    // constexpr void hard_reset() {
    //     this->hard_reset<Ts...>();
    // }

    template <typename U, typename... Us>
        requires(sizeof...(Us) >= 0)
    constexpr void construct_from_other_variant(auto const& variant) {
        if constexpr (RemoveReference<
                          decltype(variant)>::Types::template has_type<U>) {
            if (variant.template holds_alternative<U>()) {
                this->discriminant = this->index<U>;
                this->get<U>() = variant.template get<U>();
                return;
            }
        }
        if constexpr (sizeof...(Us) > 0) {
            return this->construct_from_other_variant<Us...>(variant);
        }
    }

    template <typename U, typename... Us>
        requires(sizeof...(Us) >= 0)
    constexpr void assign_other_variant(auto const& variant) {
        if constexpr (RemoveReference<
                          decltype(variant)>::Types::template has_type<U>) {
            if (variant.template holds_alternative<U>()) {
                if (!this->holds_alternative<U>()) {
                    this->hard_reset<Ts...>();
                    this->discriminant = this->index<U>;
                    return;
                }
                this->get<U>() = variant.template get<U>();
            }
        }
        if constexpr (sizeof...(Us) > 0) {
            return this->assign_other_variant<Us...>(variant);
        }
    }

  public:
    static constexpr ssize variant_size = static_cast<ssize>(sizeof...(Ts));

    constexpr Variant() = default;

    constexpr Variant(Variant<Ts...> const& variant) {
        this->construct_from_other_variant<Ts...>(variant);
    };

    constexpr Variant(Variant<Ts...>&& variant) {
        this->construct_from_other_variant<Ts...>(move(variant));
    };

    // Consume any type within the alternatives list.
    template <typename T>
        requires(Types::template has_type<T>)
    constexpr Variant(T const& input) {
        // Construct a new `T` at the address where it will be gotten from.
        construct_at(addressof(this->get<T>()), input);
        this->discriminant = this->index<T>;
    };

    template <rvalue T>
        requires(Types::template has_type<T>)
    // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
    constexpr Variant(T&& input) {
        // Construct a new `T` at the address where it will be gotten from.
        construct_at(addressof(this->get<T>()), forward<T>(input));
        this->discriminant = this->index<T>;
    };

    // Subsume a `Variant` that holds a subset of this one's alternatives.
    template <typename... Us>
    constexpr Variant(Variant<Us...> variant) {
        this->construct_from_other_variant<Us...>(variant);
    };

    template <typename T>
        requires(Types::template has_type<T>)
    constexpr auto operator=(T const& operand) -> Variant<Ts...>& {
        if (!this->holds_alternative<T>()) {
            if constexpr (!is_trivially_destructible<T>) {
                this->get<T>().~T();
            }
            this->get<T>() = operand;
            this->discriminant = this->index<T>;
        }
        return *this;
    }

    template <rvalue T>
        requires(Types::template has_type<T>)
    constexpr auto operator=(T&& operand) -> Variant<Ts...>& {
        if (!this->holds_alternative<T>()) {
            if constexpr (!is_trivially_destructible<T>) {
                this->get<T>().~T();
            }
            this->get<T>() = forward<T>(operand);
            this->discriminant = this->index<T>;
        }
        return *this;
    }

    constexpr auto operator=(Variant<Ts...> const& operand) -> Variant<Ts...>& {
        this->assign_other_variant<Ts...>(operand);
        return *this;
    }

    // constexpr auto operator=(Variant<Ts...>&& operand) -> Variant<Ts...>&
    // {
    //     this->assign_other_variant<Ts...>(
    //         forward<Variant<Ts...>>(operand));
    //     return *this;
    // }

    template <typename... Us>
    constexpr auto operator=(Variant<Us...> const& operand) -> Variant<Ts...>& {
        this->assign_other_variant<Us...>(operand);
        return *this;
    }

    template <typename... Us>
    constexpr auto operator=(Variant<Us...>&& operand) -> Variant<Ts...>& {
        this->assign_other_variant<Us...>(forward<Variant<Us...>>(operand));
        return *this;
    }

    template <typename T>
        requires(Types::template has_type<T>)
    constexpr auto get() & -> T& {
        // This cast is safe when this variant holds `T`.
        return *reinterpret_cast<T*>(addressof(this->storage));
    }

    template <typename T>
        requires(Types::template has_type<T>)
    constexpr auto get() const& -> T const& {
        // This cast is safe when this variant holds `T`.
        return *reinterpret_cast<T const* const>(&this->storage);
    }

    template <ssize index>
        requires(index >= 0 && index < ssizeof_pack<Ts...>())
    constexpr auto get() & {
        using T = typename Types::template Get<index>;
        return *reinterpret_cast<T*>(addressof(this->storage));
    }

    template <ssize index>
        requires(index >= 0 && index < ssizeof_pack<Ts...>())
    constexpr auto get() const& -> decltype(auto) {
        using T = typename Types::template Get<index>;
        return *reinterpret_cast<T const* const>(&this->storage);
    }

    template <typename T>
        requires(Types::template has_type<T>)
    constexpr auto get_if() & -> Optional<T&> {
        if (this->holds_alternative<T>()) {
            return this->get<T>();
        }
        return nullopt;
    }

    template <typename T>
        requires(Types::template has_type<T>)
    constexpr auto get_if() const& -> Optional<T&> {
        if (this->holds_alternative<T>()) {
            return this->get<T>();
        }
        return nullopt;
    }

    template <ssize index>
        requires(index >= 0 && index < ssizeof_pack<Ts...>())
    constexpr auto get_if() & {
        using T = typename Types::template Get<index>;
        if (this->holds_alternative<T>()) {
            return Optional<T>{this->get<T>()};
        }
        return Optional<T>{nullopt};
    }

    template <ssize index>
        requires(index >= 0 && index < ssizeof_pack<Ts...>())
    constexpr auto get_if() const& {
        using T = typename Types::template Get<index>;
        if (this->holds_alternative<T>()) {
            return Optional<T>{this->get<T>()};
        }
        return Optional<T>{nullopt};
    }

    template <typename T>
        requires(Types::template has_type<T>)
    static constexpr uint1 index = get_index_of_type<T, variant_size - 1>();

    template <typename T>
        requires(Types::template has_type<T>)
    constexpr auto holds_alternative() -> bool {
        return this->discriminant == this->index<T>;
    }

    template <typename T>
        requires(Types::template has_type<T>)
    constexpr auto holds_alternative() const -> bool {
        return this->discriminant == this->index<T>;
    }

    constexpr auto holds_alternative(ssize alternative_index) const -> bool {
        return this->discriminant == alternative_index;
    }

    constexpr auto get_index() const -> uint1 {
        return this->discriminant;
    }
};

}  // namespace cat
