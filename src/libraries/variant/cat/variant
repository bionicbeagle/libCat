// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/memory>
#include <cat/meta>
#include <cat/type_list>

namespace cat {
namespace detail {
    template <typename...>
    struct VariantNode {};

    template <typename T>
    struct VariantNode<T> {
        T storage;

        template <ssize>
        constexpr auto get() & -> T& {
            return this->storage;
        }

        template <ssize>
        constexpr auto get() const& -> T const& {
            return this->storage;
        }
    };

    template <typename T, typename... Remaining>
    struct VariantNode<T, Remaining...> {
        union {
            T storage;
            VariantNode<Remaining...> remaining;
            // A dummy member is required to constant-evaluate this union
            // without initializing it if `T` is a non-trivial class.
            Monostate dummy;
        };

        // `.get()` is provided an alternative type's index. It then recurses
        // through the alternative types that many times. Then it returns a
        // reference to the storage of this node it has reached.

        template <ssize remaining_recursions>
        constexpr auto get() & -> auto& {
            if constexpr (remaining_recursions == 0) {
                return this->storage;
            } else {
                return this->remaining.template get<remaining_recursions - 1>();
            }
        }

        template <ssize remaining_recursions>
        constexpr auto get() const& -> auto& {
            if constexpr (remaining_recursions == 0) {
                return this->storage;
            } else {
                return this->remaining.template get<remaining_recursions - 1>();
            }
        }
    };
}  // namespace detail

// TODO: Support reference types in a `Variant`.

template <typename... Ts>
    requires(TypeList<Ts...>::is_unique_list)
class Variant {
    detail::VariantNode<Ts...> storage;

  public:
    using Types = TypeList<Ts...>;
    // TODO: Use the smallest `Numeral` that can hold at least `sizeof...(Ts)`
    // values.
    using AlternativeIndex = ssize;
    AlternativeIndex discriminant;

    // The number of alternatives in this `Variant`.
    static constexpr AlternativeIndex variant_size = ssizeof_pack<Ts...>();


  private:
    template <typename T, AlternativeIndex index>
        requires(index < variant_size)
    static consteval auto recurse_for_index_of_type() -> AlternativeIndex {
        using ThisAlternative = typename Types::template Get<index>;
        if constexpr (is_same<T, ThisAlternative>) {
            return index;
        } else {
            return recurse_for_index_of_type<T, index + 1>();
        }
    }

  public:
    template <typename U, typename... Us>
        requires(sizeof...(Us) >= 0)
    constexpr void hard_reset() {
        if (this->is<U>()) {
            this->get<U>().~U();
        } else {
            if constexpr (sizeof...(Us) > 0) {
                this->hard_reset<Us...>();
            }
        }
    }

    // constexpr void hard_reset() {
    //     this->hard_reset<Ts...>();
    // }

    template <typename U, typename... Us>
        requires(sizeof...(Us) >= 0)
    constexpr void construct_from_other_variant(auto const& variant) {
        if constexpr (RemoveReference<
                          decltype(variant)>::Types::template has_type<U>) {
            if (variant.template is<U>()) {
                this->discriminant = this->alternative_index<U>;
                this->get<U>() = variant.template get<U>();
                return;
            }
        }
        if constexpr (sizeof...(Us) > 0) {
            return this->construct_from_other_variant<Us...>(variant);
        }
    }

    template <typename U, typename... Us>
        requires(sizeof...(Us) >= 0)
    constexpr void assign_other_variant(auto const& variant) {
        if constexpr (RemoveReference<
                          decltype(variant)>::Types::template has_type<U>) {
            if (variant.template is<U>()) {
                if (!this->is<U>()) {
                    this->hard_reset<Ts...>();
                    this->discriminant = this->alternative_index<U>;
                    return;
                }
                this->get<U>() = variant.template get<U>();
            }
        }
        if constexpr (sizeof...(Us) > 0) {
            return this->assign_other_variant<Us...>(variant);
        }
    }

  public:
    // Get the index of an alternative from its type.
    template <typename T>
        requires(Types::template has_type<T>)
    static constexpr auto alternative_index = recurse_for_index_of_type<T, 0>();

    // Get the type of an alternative from its index.
    template <AlternativeIndex index>
    using Alternative = typename Types::template Get<index>;

    constexpr Variant() = default;

    constexpr Variant(Variant<Ts...> const& variant) {
        this->construct_from_other_variant<Ts...>(variant);
    };

    constexpr Variant(Variant<Ts...>&& variant) {
        this->construct_from_other_variant<Ts...>(move(variant));
    };

    // Consume any type within the alternatives list.
    template <typename T>
        requires(Types::template has_type<T>)
    constexpr Variant(T const& input) {
        // Construct a new `T` at the address where it will be gotten from.
        construct_at(addressof(this->get<T>()), input);
        this->discriminant = this->alternative_index<T>;
    };

    template <rvalue T>
        requires(Types::template has_type<T>)
    // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
    constexpr Variant(T&& input) {
        // Construct a new `T` at the address where it will be gotten from.
        construct_at(addressof(this->get<T>()), forward<T>(input));
        this->discriminant = this->alternative_index<T>;
    };

    // Subsume a `Variant` that holds a subset of this one's alternatives.
    template <typename... Us>
    constexpr Variant(Variant<Us...> variant) {
        this->construct_from_other_variant<Us...>(variant);
    };

    template <typename T>
        requires(Types::template has_type<T>)
    constexpr auto operator=(T const& operand) -> Variant<Ts...>& {
        if (!this->is<T>()) {
            if constexpr (!is_trivially_destructible<T>) {
                this->get<T>().~T();
            }
            this->get<T>() = operand;
            this->discriminant = this->alternative_index<T>;
        } else {
            this->get<T>() = operand;
        }
        return *this;
    }

    template <rvalue T>
        requires(Types::template has_type<T>)
    constexpr auto operator=(T&& operand) -> Variant<Ts...>& {
        if (!this->is<T>()) {
            if constexpr (!is_trivially_destructible<T>) {
                this->get<T>().~T();
            }
            this->get<T>() = forward<T>(operand);
            this->discriminant = this->alternative_index<T>;
        } else {
            this->get<T>() = forward<T>(operand);
        }
        return *this;
    }

    constexpr auto operator=(Variant<Ts...> const& operand) -> Variant<Ts...>& {
        this->assign_other_variant<Ts...>(operand);
        return *this;
    }

    // constexpr auto operator=(Variant<Ts...>&& operand) -> Variant<Ts...>&
    // {
    //     this->assign_other_variant<Ts...>(
    //         forward<Variant<Ts...>>(operand));
    //     return *this;
    // }

    template <typename... Us>
    constexpr auto operator=(Variant<Us...> const& operand) -> Variant<Ts...>& {
        this->assign_other_variant<Us...>(operand);
        return *this;
    }

    template <typename... Us>
    constexpr auto operator=(Variant<Us...>&& operand) -> Variant<Ts...>& {
        this->assign_other_variant<Us...>(forward<Variant<Us...>>(operand));
        return *this;
    }

    template <typename T>
        requires(Types::template has_type<T>)
    [[nodiscard]] constexpr auto get() & -> T& {
        return this->storage.template get<alternative_index<T>>();
    }

    template <typename T>
        requires(Types::template has_type<T>)
    [[nodiscard]] constexpr auto get() const& -> T const& {
        return this->storage.template get<alternative_index<T>>();
    }

    template <AlternativeIndex index>
        requires(index >= 0 && index < ssizeof_pack<Ts...>())
    [[nodiscard]] constexpr auto get() & {
        return this->storage.template get<index>();
    }

    template <AlternativeIndex index>
        requires(index >= 0 && index < ssizeof_pack<Ts...>())
    [[nodiscard]] constexpr auto get() const& -> decltype(auto) {
        return this->storage.template get<index>();
    }

    template <typename T>
        requires(Types::template has_type<T>)
    [[nodiscard]] constexpr auto get_if() & -> Optional<T&> {
        if (this->is<T>()) {
            return this->get<T>();
        }
        return nullopt;
    }

    template <typename T>
        requires(Types::template has_type<T>)
    [[nodiscard]] constexpr auto get_if() const& -> Optional<T&> {
        if (this->is<T>()) {
            return this->get<T>();
        }
        return nullopt;
    }

    template <AlternativeIndex index>
        requires(index >= 0 && index < ssizeof_pack<Ts...>())
    [[nodiscard]] constexpr auto get_if() & {
        using T = typename Types::template Get<index>;
        if (this->is<T>()) {
            return Optional<T>{this->get<T>()};
        }
        return Optional<T>{nullopt};
    }

    template <AlternativeIndex index>
        requires(index >= 0 && index < ssizeof_pack<Ts...>())
    [[nodiscard]] constexpr auto get_if() const& {
        using T = typename Types::template Get<index>;
        if (this->is<T>()) {
            return Optional<T>{this->get<T>()};
        }
        return Optional<T>{nullopt};
    }

    [[nodiscard]] constexpr auto alternative() const -> AlternativeIndex {
        return this->discriminant;
    }

    // Holds true if this `Variant` currently has some value of the type
    // `T`. This method allows `Variant` to be used in `match` statements.
    template <typename T>
    [[nodiscard]] constexpr auto is() const -> bool {
        if constexpr (Types::template has_type<T>) {
            return this->discriminant == this->alternative_index<T>;
        } else {
            return false;
        }
    }

  private:
    // Base case.
    template <AlternativeIndex index, typename T>
    constexpr auto recurse_converting_equality(auto const& in_value) const
        -> bool {
        if (this->holds_alternative(index)) {
            return static_cast<T>(in_value) == this->get<T>();
        }
        return false;
    }

    // Recurse through every alternative type, and if it is currently the
    // active alternative, convert `in_value` to that type, then check if it
    // is equal to this `Variant`'s value.
    template <AlternativeIndex index, typename T, typename... Remaining>
        requires(sizeof...(Remaining) > 0)
    constexpr auto recurse_converting_equality(auto const& in_value) const
        -> bool {
        if (this->holds_alternative(index)) {
            return static_cast<T>(in_value) == this->get<T>();
        }
        return recurse_converting_equality<index + 1, Remaining...>(in_value);
    }

  public:
    // Holds true if this `Variant` currently has some value convertible to
    // `in_value`. This method allows `Variant` to be used in `match`
    // statements.
    template <typename T>
        requires(is_convertible<T, Ts>&&...)
    [[nodiscard]] constexpr auto is(T const& in_value) const -> bool {
        return this->recurse_converting_equality<0, Ts...>(in_value);
    }

    // Holds true if this `Variant` currently has some value of the type
    // `T`. Unlike `.is()`, this only accepts types that are potentially
    // valid alternatives.
    template <typename T>
        requires(Types::template has_type<T>)
    [[nodiscard]] constexpr auto holds_alternative() const -> bool {
        return this->discriminant == this->alternative_index<T>;
    }

    // Holds true if this `Variant` currently holds the type of index
    // `alternative_index`, which can be retrieved from `.alternative()` or
    // `.alternative_index<T>`.
    [[nodiscard]] constexpr auto holds_alternative(
        AlternativeIndex alternative_index) const -> bool {
        return this->discriminant.raw == alternative_index;
    }
};

}  // namespace cat
