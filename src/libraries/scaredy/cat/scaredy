// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/array>
#include <cat/string>
#include <cat/variant>

namespace cat {
namespace detail {
    template <typename T, typename... error_types>
    struct scaredy_variant_storage {
        using value_type = conditional<is_void<T>, monostate_type, T>;

        constexpr scaredy_variant_storage() = default;

        // value_type and error types must have separate constructors and
        // operators, because `cat::variant` cannot have implicit conversions in
        // its own constructors or operators. So an explicit conversion is
        // required to implicitly convert a value type without accidentally
        // converting error types.

        template <typename U>
        static constexpr bool is_value =
            // `U` must be converted to the value type.
            is_implicitly_convertible<U, value_type> &&
            // `U` must not be one of the errors.
            !type_list<error_types...>::template has_type<U>;

        template <typename U>
        static constexpr bool is_error =
            // `U` must not be the value type.
            !is_same<U, value_type> &&
            // `U` must be one of the errors.
            type_list<error_types...>::template has_type<U>;

        // Convert and copy-construct a value.
        template <typename U>
            requires(is_value<U>)
        constexpr scaredy_variant_storage(U const& input)
            : storage(static_cast<value_type>(input)) {
        }

        // Convert and move-construct a value.
        template <rvalue U>
            requires(is_value<U>)
        // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
        constexpr scaredy_variant_storage(U&& input)
            : storage(forward<value_type>(input)) {
        }

        // Convert and copy-construct an error.
        template <typename error_type>
            requires(is_error<error_type>)
        constexpr scaredy_variant_storage(error_type const& error)
            : storage(error) {
        }

        // Convert and move-construct an error.
        template <rvalue error_type>
            requires(is_error<error_type>)
        // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
        constexpr scaredy_variant_storage(error_type&& error)
            : storage(forward<error_type>(error)) {
        }

        // Forward `monostate` into `storage`.
        constexpr scaredy_variant_storage(monostate_type) : storage(monostate) {
        }

        // Copy-assign and convert a value to `storage`.
        template <typename U>
            requires(is_value<U>)
        constexpr auto operator=(U const& operand)
            -> scaredy_variant_storage<T, error_types...>& {
            this->storage = static_cast<T>(operand);
            return *this;
        }

        // Move-assign and convert a value to `storage`.
        template <rvalue U>
            requires(is_value<U>)
        constexpr auto operator=(U&& operand)
            -> scaredy_variant_storage<T, error_types...>& {
            this->storage = forward<value_type>(operand);
            return *this;
        }

        // Copy-assign and convert an error to `storage`.
        template <typename error_type>
            requires(is_error<error_type>)
        constexpr auto operator=(error_type const& operand)
            -> scaredy_variant_storage<T, error_types...>& {
            this->storage = operand;
            return *this;
        }

        // Move-assign and convert a value to `storage`.
        template <rvalue error_type>
            requires(is_error<error_type>)
        constexpr auto operator=(error_type&& operand)
            -> scaredy_variant_storage<T, error_types...>& {
            this->storage = forward<error_type>(operand);
            return *this;
        }

        constexpr auto has_value() const -> bool {
            return this->storage.template is<value_type>();
        }

        constexpr auto value() & -> value_type& requires(!is_void<T>) {
            return this->storage.template get<value_type>();
        }

        constexpr auto value() const& -> value_type const& requires(
            !is_void<T>) {
            return as_const(this->storage.template get<value_type>());
        }

        constexpr auto value() && -> value_type&& requires(!is_void<T>) {
            return move(this)->storage.template get<value_type>();
        }

        constexpr auto value() const&& -> value_type const&& requires(
            !is_void<T>) {
            return move(this)->storage.template get<value_type>();
        }

        template <typename error_type>
        constexpr auto error() {
            return this->storage.template get<error_type>();
        }

        template <typename error_type>
        constexpr auto error() const {
            return this->storage.template get<error_type>();
        }

        template <typename U>
        constexpr auto is() const -> bool {
            return this->storage.template is<U>();
        }

        template <typename U>
        constexpr auto is(U&& in_value) const -> bool {
            return this->storage.template is<U>(forward<U>(in_value));
        }

        variant<value_type, error_types...> storage;
    };

    // `T` is a `compact_scaredy<type, predicate>`.
    template <typename T, typename... error_types>
    struct scaredy_compact_storage {
        using value_type = typename T::type;
        // `error_types` can only hold one error in this storage struct. It is
        // variadic merely to simplify overload resolution in `scaredy`.
        // `decltype` adds a reference to it, so that is removed by
        // `remove_reference`.
        // TODO: Consider `typeof()` instead?
        using error_type =
            remove_reference<decltype(array(error_types()...)[0])>;

        constexpr scaredy_compact_storage() = default;

        template <typename U>
        static constexpr bool is_value =
            // `U` must be converted to the value type.
            is_implicitly_convertible<U, value_type> &&
            // `U` must not be one of the errors.
            !type_list<error_types...>::template has_type<U>;

        template <typename U>
        static constexpr bool is_error =
            // `U` must not be the value type.
            !is_same<U, value_type> &&
            // `U` must be one of the errors.
            type_list<error_types...>::template has_type<U>;

        template <typename U>
            requires(is_value<U>)
        constexpr scaredy_compact_storage(U const& input)
            : storage(static_cast<value_type>(input)) {
        }

        template <rvalue U>
            requires(is_value<U>)
        constexpr scaredy_compact_storage(U&& input)  // NOLINT
            : storage(forward<value_type>(input)) {
        }

        constexpr scaredy_compact_storage(error_type const& error)
            : error_code(error) {
        }

        constexpr scaredy_compact_storage(error_type&& error)
            : error_code(move(error)) {
        }

        // It does not make sense for this class to have a `monostate_type`
        // constructor, since `T` cannot be `void`.

        template <typename U>
            requires(is_value<U>)
        constexpr auto operator=(U const& operand)
            -> scaredy_compact_storage<T, error_type>& {
            this->storage = static_cast<T>(operand);
            return *this;
        }

        template <typename U>
            requires(is_value<U>)
        constexpr auto operator=(U&& operand)
            -> scaredy_compact_storage<T, error_type>& {
            this->storage = forward<value_type>(operand);
            return *this;
        }

        constexpr auto operator=(error_type const& operand)
            -> scaredy_compact_storage<T, error_type>& {
            this->error_code = operand;
            return *this;
        }

        constexpr auto operator=(error_type&& operand)
            -> scaredy_compact_storage<T, error_type>& {
            this->error_code = move(operand);
            return *this;
        }

        constexpr auto value() & -> value_type& {
            return this->storage;
        }

        constexpr auto value() const& -> value_type const& {
            return this->storage;
        }

        constexpr auto value() && -> value_type&& {
            return move(this->storage);
        }

        constexpr auto value() const&& -> value_type&& {
            return move(this->storage);
        }

        // this_type is variadic to give it a homogenous interface with other
        // `scaredy`'s.
        template <typename...>
        constexpr auto error() -> error_type {
            return this->error_code;
        }

        // this_type is variadic to give it a homogenous interface with other
        // `scaredy`'s.
        template <typename...>
        constexpr auto error() const -> error_type {
            return this->error_code;
        }

        constexpr auto has_value() const -> bool {
            return T::predicate_function(this->storage);
        }

        // Compare the type `U` against `value_type` or `error_type`.
        template <typename U>
        constexpr auto is() const -> bool {
            if constexpr (is_same<U, value_type>) {
                return this->has_value();
            } else if constexpr (is_same<U, error_type>) {
                return !this->has_value();
            } else {
                // Any type besides `value_type` and `error_type` can never hold
                // true.
                return false;
            }
        }

        // value_type comparison against either `this->storage` or
        // `this->error_code`.
        template <typename U>
        constexpr auto is(U&& in_value) const -> bool {
            if (this->has_value()) {
                return static_cast<value_type>(forward<U>(in_value)) ==
                       this->storage;
            }
            return static_cast<error_type>(forward<U>(in_value)) ==
                   this->error_code;
        }

        constexpr auto get_index() const {
            if (this->has_value()) {
                return 0;
            }
            return 1;
        }

        union {
            value_type storage;
            error_type error_code;
        };
    };
}  // namespace detail

// TODO: Support reference types in a `scaredy`.

template <typename T, typename... error_types>
    requires(
        // `scaredy` cannot hold C arrays.
        (!is_array<error_types> && ...) &&
        // `scaredy` should have at least one error type.
        sizeof...(error_types) > 0)
class scaredy {
  private:
    // clang-format off
    using storage_type = conditional <requires {
        T::predicate_function;
    }, detail::scaredy_compact_storage<T, error_types...>,
        detail::scaredy_variant_storage <T, error_types...>>;
    // clang-format on

  public:
    using value_type = typename storage_type::value_type;
    using errors_list = type_list<error_types...>;

  private:
    // These two templates must be declared here to be used in the below atomic
    // constraints.

    template <typename U>
    static constexpr bool is_value =
        // `U` must be converted to the value type.
        is_implicitly_convertible<U, value_type> &&
        // `U` must not be one of the errors.
        !type_list<error_types...>::template has_type<U>;

    template <typename U>
    static constexpr bool is_error =
        // `U` must not be the value type.
        !is_same<U, value_type> &&
        // `U` must be one of the errors.
        type_list<error_types...>::template has_type<U>;

    // `storage_type` constructors are used by the monadic member functions to
    // propagate errors.
    constexpr scaredy(storage_type const& in_storage) : storage(in_storage) {
    }
    constexpr scaredy(storage_type&& in_storage) : storage(move(in_storage)) {
    }

  public:
    constexpr scaredy() = default;

    // TODO: Construct from a subset of `error_types`.

    // Copy and convert the storage of a convertible `scaredy`.
    template <typename U>
        requires(is_implicitly_convertible<U, value_type>)
    constexpr scaredy(scaredy<U, error_types...> const& scaredy)
        : storage(scaredy.storage) {
    }

    // Move and convert the storage of a convertible `scaredy`.
    template <typename U>
        requires(is_implicitly_convertible<U, value_type>)
    constexpr scaredy(scaredy<U, error_types...>&& scaredy)
        : storage(move(scaredy).storage) {
    }

    // Forward a value into the storage.
    template <typename U>
        requires(is_value<U>)
    constexpr scaredy(U const& input) : storage(input) {
    }

    template <rvalue U>
        requires(is_value<U>)
    // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
    constexpr scaredy(U&& input) : storage(input) {
    }

    // Forward an error into the storage.
    template <typename U>
        requires(is_error<U>)
    constexpr scaredy(U const& error) : storage(error) {
    }

    // Forward an error into the storage.
    template <rvalue U>
        requires(is_error<U>)
    // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
    constexpr scaredy(U&& error) : storage(forward<U>(error)) {
    }

    // Forward a `monostate` into the storage if there is no value type.
    constexpr scaredy(monostate_type) requires(
        is_void<value_type> || is_same<value_type, monostate_type>)
        : storage(monostate) {
    }

    // Copy-assign and convert a `scaredy`.
    template <typename U, typename... Othererror_types>
        requires(is_value<U> && (is_error<Othererror_types> && ...))
    constexpr auto operator=(scaredy<U, error_types...> const& operand)
        -> scaredy& {
        this->storage = operand.storage;
        return *this;
    }

    // Move-assign and convert a `scaredy`.
    template <typename U, typename... Othererror_types>
        requires(is_value<U> && (is_error<Othererror_types> && ...))
    constexpr auto operator=(scaredy<U, error_types...>&& operand) -> scaredy& {
        this->storage = operand.storage;
        return *this;
    }

    // Copy-assign and convert a value to `storage`.
    template <typename U>
        requires(is_value<U>)
    constexpr auto operator=(U const& operand) -> scaredy& {
        this->storage = static_cast<value_type>(operand);
        return *this;
    }

    // Move-assign and convert a value to `storage`.
    template <rvalue U>
        requires(is_value<U>)
    constexpr auto operator=(U&& operand) -> scaredy& {
        this->storage = static_cast<value_type&&>(operand);
        return *this;
    }

    // Copy-assign and convert an error to `storage`.
    template <typename error_type>
        requires(is_error<error_type>)
    constexpr auto operator=(error_type const& operand) -> scaredy& {
        this->storage = operand;
        return *this;
    }

    // Move-assign and convert an error to `storage`.
    template <rvalue error_type>
        requires(is_error<error_type>)
    constexpr auto operator=(error_type&& operand) -> scaredy& {
        this->storage = forward<error_type>(operand);
        return *this;
    }

    [[nodiscard]] constexpr auto has_value() const -> bool {
        return this->storage.has_value();
    }

    [[nodiscard]] constexpr auto value() & requires(!is_void<T>) {
        return this->storage.value();
    }

    [[nodiscard]] constexpr auto value() const& requires(!is_void<T>) {
        return this->storage.value();
    }

    [[nodiscard]] constexpr auto value() && requires(!is_void<T>) {
        return move(this->storage.value());
    }

    [[nodiscard]] constexpr auto value() const&& requires(!is_void<T>) {
        return move(this->storage.value());
    }

    // Get the value of some error when its type is known to the caller.
    template <typename error_type>
    [[nodiscard]] constexpr auto error() {
        return this->storage.template error<error_type>();
    }

    // Get the value of some error when its type is known to the caller.
    template <typename error_type>
    [[nodiscard]] constexpr auto error() const {
        return this->storage.template error<error_type>();
    }

    // If there is only one error type, a template argument is not required.
    [[nodiscard]] constexpr auto error() requires(sizeof...(error_types) == 1) {
        return this->storage.template error<error_types...>();
    }

    // If there is only one error type, a template argument is not required.
    [[nodiscard]] constexpr auto error() const
        requires(sizeof...(error_types) == 1) {
        return this->storage.template error<error_types...>();
    }

    [[nodiscard]] constexpr auto value_or(value_type fallback) & {
        if (this->storage.has_value()) {
            return this->storage.value();
        }
        return fallback;
    }

    [[nodiscard]] constexpr auto value_or(value_type fallback) && {
        if (this->storage.has_value()) {
            return move(this->storage).value();
        }
        return fallback;
    }

    [[nodiscard]] constexpr auto value_or(value_type fallback) const& {
        if (this->storage.has_value()) {
            return this->storage.value();
        }
        return fallback;
    }

    [[nodiscard]] constexpr auto value_or(value_type fallback) const&& {
        if (this->storage.has_value()) {
            return move(this->storage).value();
        }
        return fallback;
    }

    // TODO: Add `.p_value()` getters, like `cat::maybe`.

    // TODO: Add `&&` overloads to the `.assert()` and `.verify()` getters.
    // TODO: Make the `.assert()` and `.verify()` getters `constexpr`.
    // TODO: Add overloads which take a `string const` for an error message.

    [[nodiscard]] auto assert(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) & -> value_type& {
        cat::assert(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto assert(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) const& -> value_type& {
        cat::assert(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto assert(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) && -> value_type&& {
        cat::assert(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto assert(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) const&& -> value_type&& {
        cat::assert(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto verify(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) & -> value_type& {
        cat::verify(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto verify(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) const& -> value_type& {
        cat::verify(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto verify(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) && -> value_type {
        cat::verify(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    [[nodiscard]] auto verify(
        void (*p_assert_handler)(source_location const&) = assert_handler,
        source_location const& callsite =
            source_location::current()) const&& -> value_type {
        cat::verify(this->has_value(), p_assert_handler, callsite);
        return this->value();
    }

    // Holds true if this `scaredy` currently has some value of the type `U`.
    // this_type method allows `scaredy` to be used in `match` statements.
    template <typename U>
    [[nodiscard]] constexpr auto is() const -> bool {
        return this->storage.template is<U>();
    }

    // Holds true if this `scaredy` currently has some value convertible and
    // equivalent to `in_value`. this_type method allows `scaredy` to be used in
    // `match` statements.
    template <typename U>
    [[nodiscard]] constexpr auto is(U&& in_value) const -> bool {
        return this->storage.template is(forward<U>(in_value));
    }

    // Member access syntax pattern matching for `cat::match()`.
    template <typename... patterns>
        requires(is_specialization<patterns, detail::pattern_invocable>&&...)
    constexpr void match(patterns&&... pattern_args) {
        detail::match_patterns (*this)(forward<patterns>(pattern_args)...);
    }

    // TODO: Use `is_invocable` constraints.

    // If this non-`const`-qualified `scaredy` holds a value, transform it
    // by a function. Otherwise, propagate the error value.
    template <typename F>
    [[nodiscard]] constexpr auto transform(F&& invocable) & {
        using this_type = scaredy<T, error_types...>;
        if (this->has_value()) {
            return this_type(forward<F>(invocable)(this->value()));
        }
        return this_type(this->storage);
    }

    template <typename F>
    [[nodiscard]] constexpr auto transform(F&& invocable) const& {
        using this_type = scaredy<T, error_types...>;
        if (this->has_value()) {
            return this_type(forward<F>(invocable)(this->value()));
        }
        return this_type(this->storage);
    }

    template <typename F>
    [[nodiscard]] constexpr auto transform(F&& invocable) && {
        using this_type = scaredy<T, error_types...>;
        if (this->has_value()) {
            return this_type(forward<F>(invocable)(move(this)->value()));
        }
        return this_type(move(this->storage));
    }

    template <typename F>
    [[nodiscard]] constexpr auto transform(F&& invocable) const&& {
        using this_type = scaredy<T, error_types...>;
        if (this->has_value()) {
            return this_type(forward<F>(invocable)(move(this)->value()));
        }
        return this_type(move(this->storage));
    }

    template <typename F>
    [[nodiscard]] constexpr auto and_then(F&& invocable) & {
        using this_type = scaredy<T, error_types...>;
        return this->has_value() ? forward<F>(invocable)(this->value())
                                 : this_type(this->storage);
    }

    template <typename F>
    [[nodiscard]] constexpr auto and_then(F&& invocable) const& {
        using this_type = scaredy<T, error_types...>;
        return this->has_value() ? forward<F>(invocable)(this->value())
                                 : this_type(this->storage);
    }

    template <typename F>
    [[nodiscard]] constexpr auto and_then(F&& invocable) && {
        using this_type = scaredy<T, error_types...>;
        return this->has_value() ? forward<F>(invocable)(move(this)->value())
                                 : this_type(move(this->storage));
    }

    template <typename F>
    [[nodiscard]] constexpr auto and_then(F&& invocable) const&& {
        using this_type = scaredy<T, error_types...>;
        return this->has_value() ? forward<F>(invocable)(move(this)->value())
                                 : this_type(move(this->storage));
    }

    template <typename F>
    [[nodiscard]] constexpr auto or_else(F&& invocable) & {
        using U = decltype(invocable());
        static_assert(is_void<U> || is_specialization<U, scaredy>);

        if (!this->has_value()) {
            if constexpr (is_void<U>) {
                forward<F>(invocable)();
            } else {
                return forward<F>(invocable)();
            }
        }

        if constexpr (is_void<U>) {
            return;
        } else {
            return *this;
        }
    }

    template <typename F>
    [[nodiscard]] constexpr auto or_else(F&& invocable) const& {
        using U = decltype(invocable());
        static_assert(is_void<U> || is_specialization<U, scaredy>);

        if (!this->storage.has_value()) {
            if constexpr (is_void<U>) {
                forward<F>(invocable)();
            } else {
                return forward<F>(invocable)();
            }
        }

        if constexpr (is_void<U>) {
            return;
        } else {
            return *this;
        }
    }

    [[nodiscard]] auto or_exit(ssize exit_code = 1) & {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return this->value();
            } else {
                return;
            }
        }
        exit(exit_code);
        __builtin_unreachable();
    }

    [[nodiscard]] auto or_exit(ssize exit_code = 1) const& {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return this->value();
            } else {
                return;
            }
        }
        exit(exit_code);
        __builtin_unreachable();
    }

    [[nodiscard]] auto or_exit(ssize exit_code = 1) && {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return move(this)->value();
            } else {
                return;
            }
        }
        exit(exit_code);
        __builtin_unreachable();
    }

    [[nodiscard]] auto or_exit(ssize exit_code = 1) const&& {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return move(this)->value();
            } else {
                return;
            }
        }
        exit(exit_code);
        __builtin_unreachable();
    }

    [[nodiscard]] auto or_exit(string const error_message,
                               ssize exit_code = 1) & {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return this->value();
            } else {
                return;
            }
        } else {
            _ = eprintln(error_message);
            exit(exit_code);
        }
    }

    [[nodiscard]] auto or_exit(string const error_message,
                               ssize exit_code = 1) const& {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return this->value();
            } else {
                return;
            }
        } else {
            _ = eprintln(error_message);
            exit(exit_code);
        }
    }

    [[nodiscard]] auto or_exit(string const error_message,
                               ssize exit_code = 1) && {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return move(this)->value();
            } else {
                return;
            }
        } else {
            _ = eprintln(error_message);
            exit(exit_code);
        }
    }

    [[nodiscard]] auto or_exit(string const error_message,
                               ssize exit_code = 1) const&& {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return move(this)->value();
            } else {
                return;
            }
        } else {
            _ = eprintln(error_message);
            exit(exit_code);
        }
    }

  private:
    storage_type storage;
};

template <typename T>
concept is_scaredy = requires(T t) {
    // T::value_type;
    // T::error_types;
    cat::maybe<decltype(t.value())>();
}
&&!requires(T t) {
    t = cat::nullopt;
};

}  // namespace cat
