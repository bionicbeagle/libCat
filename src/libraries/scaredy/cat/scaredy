// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/meta>
#include <cat/string>
#include <cat/variant>

namespace cat {
namespace detail {
    template <typename T, typename... Errors>
    struct ScaredyVariantStorage {
        using Value = Conditional<is_void<T>, Monostate, T>;
        Variant<Value, Errors...> storage;

        constexpr ScaredyVariantStorage() = default;

        // Value and error types must have separate constructors and operators,
        // because `cat::Variant` cannot have implicit conversions in its own
        // constructors or operators. So an explicit conversion is required to
        // implicitly convert a value type without accidentally converting error
        // types.

        template <typename U>
        static constexpr bool is_value =
            // `U` must be converted to the value type.
            is_implicitly_convertible<U, Value> &&
            // `U` must not be one of the errors.
            !TypeList<Errors...>::template has_type<U>;

        template <typename U>
        static constexpr bool is_error =
            // `U` must not be the value type.
            !is_same<U, Value> &&
            // `U` must be one of the errors.
            TypeList<Errors...>::template has_type<U>;

        // Convert and copy-construct a value.
        template <typename U>
            requires(is_value<U>)
        constexpr ScaredyVariantStorage(U const& input)
            : storage(static_cast<Value>(input)){};

        // Convert and move-construct a value.
        template <rvalue U>
            requires(is_value<U>)
        // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
        constexpr ScaredyVariantStorage(U&& input)
            : storage(forward<Value>(input)){};

        // Convert and copy-construct an error.
        template <typename Error>
            requires(is_error<Error>)
        constexpr ScaredyVariantStorage(Error const& error) : storage(error){};

        // Convert and move-construct an error.
        template <rvalue Error>
            requires(is_error<Error>)
        // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
        constexpr ScaredyVariantStorage(Error&& error)
            : storage(forward<Error>(error)){};

        // Forward `monostate` into `storage`.
        constexpr ScaredyVariantStorage(Monostate) : storage(monostate){};

        // Copy-assign and convert a value to `storage`.
        template <typename U>
            requires(is_value<U>)
        constexpr auto operator=(U const& operand)
            -> ScaredyVariantStorage<T, Errors...>& {
            this->storage = static_cast<T>(operand);
            return *this;
        }

        // Move-assign and convert a value to `storage`.
        template <rvalue U>
            requires(is_value<U>)
        constexpr auto operator=(U&& operand)
            -> ScaredyVariantStorage<T, Errors...>& {
            this->storage = forward<Value>(operand);
            return *this;
        }

        // Copy-assign and convert an error to `storage`.
        template <typename Error>
            requires(is_error<Error>)
        constexpr auto operator=(Error const& operand)
            -> ScaredyVariantStorage<T, Errors...>& {
            this->storage = operand;
            return *this;
        }

        // Move-assign and convert a value to `storage`.
        template <rvalue Error>
            requires(is_error<Error>)
        constexpr auto operator=(Error&& operand)
            -> ScaredyVariantStorage<T, Errors...>& {
            this->storage = forward<Error>(operand);
            return *this;
        }

        constexpr auto has_value() const -> bool {
            return this->storage.template holds_alternative<Value>();
        }

        constexpr auto value() & -> Value& requires(!is_void<T>) {
            return this->storage.template get<Value>();
        }

        constexpr auto value() const& -> Value const& requires(!is_void<T>) {
            return as_const(this->storage.template get<Value>());
        }

        constexpr auto value() && -> Value&& requires(!is_void<T>) {
            return move(this)->storage.template get<Value>();
        }

        constexpr auto value() const&& -> Value const&& requires(!is_void<T>) {
            return move(this)->storage.template get<Value>();
        }

        template <typename Error>
        constexpr auto error() {
            return this->storage.template get<Error>();
        }

        template <typename Error>
        constexpr auto error() const {
            return this->storage.template get<Error>();
        }

        template <typename U>
        constexpr auto holds_alternative() const -> bool {
            return this->storage.template holds_alternative<U>();
        }
    };

    // `T` is a `Compact<Type, predicate, sentinel>`.
    template <typename T, typename... Errors>
    struct ScaredyCompactStorage {
        using Value = typename T::Type;
        // `Errors` can only hold one error in this storage struct. It is
        // variadic merely to simplify overload resolution in `Scaredy`.
        // `decltype` adds a reference to it, so that is removed by
        // `RemoveReference`.
        // TODO: Consider `typeof()` instead?
        using Error = RemoveReference<decltype(Array{Errors{}...}[0])>;

        union {
            Value storage;
            Error error_code;
        };

        constexpr ScaredyCompactStorage() = default;

        template <typename U>
        static constexpr bool is_value =
            // `U` must be converted to the value type.
            is_implicitly_convertible<U, Value> &&
            // `U` must not be one of the errors.
            !TypeList<Errors...>::template has_type<U>;

        template <typename U>
        static constexpr bool is_error =
            // `U` must not be the value type.
            !is_same<U, Value> &&
            // `U` must be one of the errors.
            TypeList<Errors...>::template has_type<U>;

        template <typename U>
            requires(is_value<U>)
        constexpr ScaredyCompactStorage(U const& input)
            : storage(static_cast<Value>(input)){};

        template <rvalue U>
            requires(is_value<U>)
        constexpr ScaredyCompactStorage(U&& input)  // NOLINT
            : storage(forward<Value>(input)){};

        constexpr ScaredyCompactStorage(Error const& error)
            : error_code(error){};

        constexpr ScaredyCompactStorage(Error&& error)
            : error_code(move(error)){};

        // It does not make sense for this class to have a `Monostate`
        // constructor, since `T` cannot be `void`.

        template <typename U>
            requires(is_value<U>)
        constexpr auto operator=(U const& operand)
            -> ScaredyCompactStorage<T, Error>& {
            this->storage = static_cast<T>(operand);
            return *this;
        }

        template <typename U>
            requires(is_value<U>)
        constexpr auto operator=(U&& operand)
            -> ScaredyCompactStorage<T, Error>& {
            this->storage = forward<Value>(operand);
            return *this;
        }

        constexpr auto operator=(Error const& operand)
            -> ScaredyCompactStorage<T, Error>& {
            this->storage = operand;
            return *this;
        }

        constexpr auto operator=(Error&& operand)
            -> ScaredyCompactStorage<T, Error>& {
            this->storage = move(operand);
            return *this;
        }

        constexpr auto value() & -> Value& {
            return this->storage;
        }

        constexpr auto value() const& -> Value const& {
            return this->storage;
        }

        constexpr auto value() && -> Value&& {
            return move(this->storage);
        }

        constexpr auto value() const&& -> Value&& {
            return move(this->storage);
        }

        // This is variadic to give it a homogenous interface with other
        // `Scaredy`'s.
        template <typename...>
        constexpr auto error() -> Error {
            return this->error_code;
        }

        // This is variadic to give it a homogenous interface with other
        // `Scaredy`'s.
        template <typename...>
        constexpr auto error() const -> Error {
            return this->error_code;
        }

        constexpr auto has_value() const -> bool {
            return T::predicate_function(this->storage);
        }

        template <typename U>
        constexpr auto holds_alternative() const -> bool {
            // Since this storage can only hold either `Value` or `Error`, this
            // can be expressed in terms of `.has_value()`.
            if constexpr (is_same<U, Value>) {
                return this->has_value();
            } else {
                return !this->has_value();
            }
        }

        [[nodiscard]] constexpr auto holds_alternative(
            ssize alternative_index) const -> bool {
            if (alternative_index == 0) {
                return this->holds_alternative<Value>();
            }
            return this->holds_alternative<Error>();
        }

        constexpr auto get_index() const {
            if (this->has_value()) {
                return 0;
            }
            return 1;
        }
    };
}  // namespace detail

// TODO: Support reference types in a `Scaredy`.

template <typename T, typename... Errors>
    requires(
        // `Scaredy` cannot hold C arrays.
        (!is_array<Errors> && ...) &&
        // `Scaredy` should have at least one error type.
        sizeof...(Errors) > 0)
class Scaredy {
    // clang-format off
    using Storage = Conditional <requires {
        T::sentinel_value;
    }, detail::ScaredyCompactStorage<T, Errors...>,
        detail::ScaredyVariantStorage <T, Errors...>>;
    // clang-format on

    Storage storage;
    using Value = typename Storage::Value;
    using ErrorsList = TypeList<Errors...>;

    // `Storage` constructors are used by the monadic member functions to
    // propagate errors.
    constexpr Scaredy(Storage const& in_storage) : storage(in_storage){};
    constexpr Scaredy(Storage&& in_storage) : storage(move(in_storage)){};

    template <typename U>
    static constexpr bool is_value =
        // `U` must be converted to the value type.
        is_implicitly_convertible<U, Value> &&
        // `U` must not be one of the errors.
        !TypeList<Errors...>::template has_type<U>;

    template <typename U>
    static constexpr bool is_error =
        // `U` must not be the value type.
        !is_same<U, Value> &&
        // `U` must be one of the errors.
        TypeList<Errors...>::template has_type<U>;

  public:
    constexpr Scaredy() = default;

    // TODO: Construct from a subset of `Errors`.

    // Copy and convert the storage of a convertible `Scaredy`.
    template <typename U>
        requires(is_implicitly_convertible<U, Value>)
    constexpr Scaredy(Scaredy<U, Errors...> const& scaredy)
        : storage(scaredy.storage){};

    // Move and convert the storage of a convertible `Scaredy`.
    template <typename U>
        requires(is_implicitly_convertible<U, Value>)
    constexpr Scaredy(Scaredy<U, Errors...>&& scaredy)
        : storage(move(scaredy).storage){};

    // Forward a value into the storage.
    template <typename U>
        requires(is_value<U>)
    constexpr Scaredy(U const& input) : storage(input){};

    template <rvalue U>
        requires(is_value<U>)
    // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
    constexpr Scaredy(U&& input) : storage(input){};

    // Forward an error into the storage.
    template <typename U>
        requires(is_error<U>)
    constexpr Scaredy(U const& error) : storage(error){};

    // Forward an error into the storage.
    template <rvalue U>
        requires(is_error<U>)
    // NOLINTNEXTLINE `rvalue` sufficiently constrains this constructor.
    constexpr Scaredy(U&& error) : storage(forward<U>(error)){};

    // Forward a `monostate` into the storage if there is no value type.
    constexpr Scaredy(Monostate) requires(is_void<Value> ||
                                          is_same<Value, Monostate>)
        : storage(monostate){};

    // Copy-assign and convert a value to `storage`.
    template <typename U>
        requires(is_value<U>)
    constexpr auto operator=(U const& operand) -> Scaredy& {
        this->storage = static_cast<Value>(operand);
        return *this;
    }

    // Move-assign and convert a value to `storage`.
    template <rvalue U>
        requires(is_value<U>)
    constexpr auto operator=(U&& operand) -> Scaredy& {
        this->storage = static_cast<Value&&>(operand);
        return *this;
    }

    // Copy-assign and convert an error to `storage`.
    template <typename Error>
        requires(is_error<Error>)
    constexpr auto operator=(Error const& operand) -> Scaredy& {
        this->storage = operand;
        return *this;
    }

    // Move-assign and convert an error to `storage`.
    template <rvalue Error>
        requires(is_error<Error>)
    constexpr auto operator=(Error&& operand) -> Scaredy& {
        this->storage = forward<Error>(operand);
        return *this;
    }

    [[nodiscard]] constexpr auto has_value() const -> bool {
        return this->storage.has_value();
    }

    [[nodiscard]] constexpr auto value() & requires(!is_void<T>) {
        return this->storage.value();
    }

    [[nodiscard]] constexpr auto value() const& requires(!is_void<T>) {
        return this->storage.value();
    }

    [[nodiscard]] constexpr auto value() && requires(!is_void<T>) {
        return move(this->storage.value());
    }

    [[nodiscard]] constexpr auto value() const&& requires(!is_void<T>) {
        return move(this->storage.value());
    }

    template <typename Error>
    [[nodiscard]] constexpr auto error() {
        return this->storage.template error<Error>();
    }

    template <typename Error>
    [[nodiscard]] constexpr auto error() const {
        return this->storage.template error<Error>();
    }

    [[nodiscard]] constexpr auto value_or(Value fallback) & {
        if (this->storage.has_value()) {
            return this->storage.value();
        }
        return fallback;
    }

    [[nodiscard]] constexpr auto value_or(Value fallback) && {
        if (this->storage.has_value()) {
            return move(*this)->storage.value();
        }
        return fallback;
    }

    [[nodiscard]] constexpr auto value_or(Value fallback) const& {
        if (this->storage.has_value()) {
            return this->storage.value();
        }
        return fallback;
    }

    [[nodiscard]] constexpr auto value_or(Value fallback) const&& {
        if (this->storage.has_value()) {
            return move(this)->storage.value();
        }
        return fallback;
    }

    template <typename U>
    [[nodiscard]] constexpr auto holds_alternative() const -> bool {
        return this->storage.template holds_alternative<U>();
    }

    [[nodiscard]] constexpr auto holds_alternative(
        ssize alternative_index) const -> bool {
        return this->storage.template holds_alternative(alternative_index);
    }

    // If this non-`const`-qualified `Scaredy` holds a value, transform it
    // by a function. Otherwise, propagate the error value.
    template <typename Function>
    [[nodiscard]] constexpr auto transform(Function&& callback) & {
        using This = Scaredy<T, Errors...>;
        if (this->has_value()) {
            return This{forward<Function>(callback)(this->value())};
        }
        return This{this->storage};
    }

    template <typename Function>
    [[nodiscard]] constexpr auto transform(Function&& callback) const& {
        using This = Scaredy<T, Errors...>;
        if (this->has_value()) {
            return This{forward<Function>(callback)(this->value())};
        }
        return This{this->storage};
    }

    template <typename Function>
    [[nodiscard]] constexpr auto transform(Function&& callback) && {
        using This = Scaredy<T, Errors...>;
        if (this->has_value()) {
            return This{forward<Function>(callback)(move(this)->value())};
        }
        return This{move(this)->storage};
    }

    template <typename Function>
    [[nodiscard]] constexpr auto transform(Function&& callback) const&& {
        using This = Scaredy<T, Errors...>;
        if (this->has_value()) {
            return This{forward<Function>(callback)(move(this)->value())};
        }
        return This{move(this)->storage};
    }

    template <typename Function>
    [[nodiscard]] constexpr auto and_then(Function&& callback) & {
        using This = Scaredy<T, Errors...>;
        return this->has_value() ? forward<Function>(callback)(this->value())
                                 : This{this->storage};
    }

    template <typename Function>
    [[nodiscard]] constexpr auto and_then(Function&& callback) const& {
        using This = Scaredy<T, Errors...>;
        return this->has_value() ? forward<Function>(callback)(this->value())
                                 : This{this->storage};
    }

    template <typename Function>
    [[nodiscard]] constexpr auto and_then(Function&& callback) && {
        using This = Scaredy<T, Errors...>;
        return this->has_value()
                   ? forward<Function>(callback)(move(this)->value())
                   : This{move(this)->storage};
    }

    template <typename Function>
    [[nodiscard]] constexpr auto and_then(Function&& callback) const&& {
        using This = Scaredy<T, Errors...>;
        return this->has_value()
                   ? forward<Function>(callback)(move(this)->value())
                   : This{move(this)->storage};
    }

    template <typename Function>
    [[nodiscard]] constexpr auto or_else(Function&& callback) & {
        using U = decltype(callback());
        static_assert(is_void<U> || is_specialization<U, Scaredy>);

        if (!this->has_value()) {
            if constexpr (is_void<U>) {
                forward<Function>(callback)();
            } else {
                return forward<Function>(callback)();
            }
        }

        if constexpr (is_void<U>) {
            return;
        } else {
            return *this;
        }
    }

    template <typename Function>
    [[nodiscard]] constexpr auto or_else(Function&& callback) const& {
        using U = decltype(callback());
        static_assert(is_void<U> || is_specialization<U, Scaredy>);

        if (!this->storage.has_value()) {
            if constexpr (is_void<U>) {
                forward<Function>(callback)();
            } else {
                return forward<Function>(callback)();
            }
        }

        if constexpr (is_void<U>) {
            return;
        } else {
            return *this;
        }
    }

    [[nodiscard]] auto or_exit(ssize exit_code = 1) & {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return this->value();
            } else {
                return;
            }
        }
        exit(exit_code);
        __builtin_unreachable();
    }

    [[nodiscard]] auto or_exit(ssize exit_code = 1) const& {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return this->value();
            } else {
                return;
            }
        }
        exit(exit_code);
        __builtin_unreachable();
    }

    [[nodiscard]] auto or_exit(ssize exit_code = 1) && {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return move(this->value());
            } else {
                return;
            }
        }
        exit(exit_code);
        __builtin_unreachable();
    }

    [[nodiscard]] auto or_exit(ssize exit_code = 1) const&& {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return move(this->value());
            } else {
                return;
            }
        }
        exit(exit_code);
        __builtin_unreachable();
    }

    [[nodiscard]] auto or_exit(String const error_message,
                               ssize exit_code = 1) & {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return this->value();
            } else {
                return;
            }
        } else {
            _ = eprintln(error_message);
            exit(exit_code);
        }
    }

    [[nodiscard]] auto or_exit(String const error_message,
                               ssize exit_code = 1) const& {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return this->value();
            } else {
                return;
            }
        } else {
            _ = eprintln(error_message);
            exit(exit_code);
        }
    }

    [[nodiscard]] auto or_exit(String const error_message,
                               ssize exit_code = 1) && {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return move(this->value());
            } else {
                return;
            }
        } else {
            _ = eprintln(error_message);
            exit(exit_code);
        }
    }

    [[nodiscard]] auto or_exit(String const error_message,
                               ssize exit_code = 1) const&& {
        if (this->has_value()) [[likely]] {
            if constexpr (!is_void<T>) {
                return move(this->value());
            } else {
                return;
            }
        } else {
            _ = eprintln(error_message);
            exit(exit_code);
        }
    }
};

}  // namespace cat
