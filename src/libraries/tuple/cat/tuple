// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/type_list>

namespace cat {
namespace detail {
    // Because one type can only be derived from once, types must be binded to
    // their position in a paremeter pack to guarantee their uniqueness. This is
    // required to support `Tuple`s with non-uniquely-typed elements.
    template <ssize index, typename T>
    struct TupleElement {
        using Element = T;

        constexpr TupleElement() = default;

        // Conditionally trivial special member functions in C++20 allows these
        // to remain trivial in some cases:

        template <typename U>
            requires(is_implicitly_convertible<U, T>)
        constexpr TupleElement(U const& input)
            : storage(static_cast<T>(input)){};

        template <typename U>
            requires(is_implicitly_convertible<U, T>)
        constexpr TupleElement(U&& input) : storage(forward<U>(input)){};

        // For some reason, this produces ambiguous overload errors if it is
        // implemented as a normal function instead of an operator.
        constexpr auto operator[](Constant<index>) & -> T& {
            return this->storage;
        }

        constexpr auto operator[](Constant<index>) const& -> T const& {
            return this->storage;
        }

        constexpr auto operator[](Constant<index>) && -> T&& {
            return cat::move(this->storage);
        }

        constexpr auto operator[](Constant<index>) const&& -> T const&& {
            return cat::move(this->storage);
        }

        [[no_unique_address]] T storage;
    };

    // Deriving from a variadic list of types allows `Tuple` to be an aggregate
    // type.
    template <typename... Ts>
    struct TypeMap : Ts... {
        using Ts::operator[]...;
    };

    // This partial specialization is required in order to support two parameter
    // packs in the following `TupleStorage` declaration.
    template <typename...>
    struct TupleStorage {};

    // Map a list of indices to a list of types.
    template <ssize... indices, typename... Ts>
    struct TupleStorage<IndexList<indices...>, Ts...> {
        using Type = TypeMap<TupleElement<indices, Ts>...>;
    };

}  // namespace detail

template <typename... Ts>
struct Tuple : detail::TupleStorage<IndexSequenceFor<Ts...>, Ts...>::Type {
    using Types = TypeList<Ts...>;
    using Map =
        typename detail::TupleStorage<IndexSequenceFor<Ts...>, Ts...>::Type;

    // clangd 15 produces a false diagnostic if this is declared at the bottom
    // of this struct.
    static constexpr ssize size = Types::size;

    /*
// Convert each element of this `Tuple` into those of another `Tuple`.
template <typename T>
constexpr operator T() const {
    using OtherTypes = typename Decay<T>::Types;
    // Pass in a `TypeList` for its types to be deduced out of.
    return this->template convert_elements(OtherTypes{});
}

private:
template <ssize index, typename U>
constexpr auto convert_next_element(auto const& new_tuple) const {
    U converted_value = static_cast<U>(this->get<index>());
    return new_tuple.template concat(cat::Tuple<U>{converted_value});
}

template <ssize index, typename U, typename... Us>
    requires(sizeof...(Us) > 0)
constexpr auto convert_next_element(auto const& new_tuple) const {
    U converted_value = static_cast<U>(this->get<index>());
    return this->convert_next_element<index + 1, Us...>(
        new_tuple.template concat(cat::Tuple<U>{converted_value}));
}

template <typename... Us>
constexpr auto convert_elements(TypeList<Us...>) const {
    return this->convert_next_element<0, Us...>(Tuple<>{});
}

template <ssize index>
constexpr auto concat_lhs(auto& other_tuple) const {
    return other_tuple;
}

template <ssize index>
    requires(index < this->size)
constexpr auto concat_lhs(auto& other_tuple) const {
    other_tuple.template get<index>() = this->get<index>();
    return concat_lhs<index + 1>(other_tuple);
}

template <ssize index>
constexpr auto concat_rhs(auto const& other_tuple, auto&) const {
    return other_tuple;
}

template <ssize index>
constexpr auto concat_rhs(auto const& other_tuple, auto& rhs_tuple) const
    requires(index < rhs_tuple.this->size) {
    other_tuple.template get<index + static_cast<ssize>(sizeof...(Ts))>() =
        rhs_tuple.template get<index>();
    return concat_rhs<index + 1>(other_tuple, rhs_tuple);
}

template <ssize index>
constexpr auto concat_recurse(Tuple<Ts...> const& this_tuple,
                              auto const& other_tuple,
                              auto const& new_tuple) const {
    if constexpr (index < this->size) {
        return concat_recurse<index + 1>(this_tuple, other_tuple,
                                         new_tuple);
    }
}

public:
// Concatenate this tuple with another tuple.
template <typename... Us>
constexpr auto concat(Tuple<Us...> const& other_tuple) const
    -> Tuple<Ts..., Us...> {
    // TODO: If these tuples are trivially relocatable, optimize this.
    Tuple<Ts..., Us...> new_tuple =
        this->concat_recurse<0>(*this, other_tuple, Tuple<>{});
    // this->concat_lhs<0>(new_tuple);
    return new_tuple;
}
    */

    // Get a non-`const` reference to the N'th stored variable.
    template <ssize index>
    constexpr auto get() & -> auto& requires(index <= this->size) {
        return (*this)[Constant<index>{}];
    }

    // Get a `const` reference to the N'th stored variable.
    template <ssize index>
    constexpr auto get() const& -> auto const& requires(index <= this->size) {
        return (*this)[Constant<index>{}];
    }

    // Move the N'th stored variable.
    template <ssize index>
    constexpr auto get() && -> auto&& requires(index <= this->size) {
        return move((*this)[Constant<index>{}]);
    }

    // Move the N'th stored variable.
    template <ssize index>
    constexpr auto get() const&& -> auto const&& requires(index <= this->size) {
        return move((*this)[Constant<index>{}]);
    }

    // Get a non-`const` reference to the first stored variable.
    constexpr auto first() & -> auto& requires(this->size >= 1) {
        return this->get<0>();
    }

    // Get a `const` reference to the first stored variable.
    constexpr auto first() const& -> auto const& requires(this->size >= 1) {
        return this->get<0>();
    }

    // Move the first stored variable.
    constexpr auto first() && -> auto&& requires(this->size >= 1) {
        return move(this->get<0>());
    }

    // Move the first stored variable.
    constexpr auto first() const&& -> auto const&& requires(this->size >= 1) {
        return move(this->get<0>());
    }

    // Get a non-`const` reference to the second stored variable.
    constexpr auto second() & -> auto& requires(this->size >= 2) {
        return this->get<1>();
    }

    // Get a `const` reference to the second stored variable.
    constexpr auto second() const& -> auto const& requires(this->size >= 2) {
        return this->get<1>();
    }

    // Move the second stored variable.
    constexpr auto second() && -> auto&& requires(this->size >= 2) {
        return move(this->get<1>());
    }

    // Move the second stored variable.
    constexpr auto second() const&& -> auto const&& requires(this->size >= 2) {
        return move(this->get<1>());
    }

    // Get a non-`const` reference to the third stored variable.
    constexpr auto third() & -> auto& requires(this->size >= 3) {
        return this->get<2>();
    }

    // Get a `const` reference to the third stored variable.
    constexpr auto third() const& -> auto const& requires(this->size >= 3) {
        return this->get<2>();
    }

    // Move the third stored variable.
    constexpr auto third() && -> auto&& requires(this->size >= 3) {
        return move(this->get<2>());
    }

    // Move the third stored variable.
    constexpr auto third() const&& -> auto const&& requires(this->size >= 3) {
        return move(this->get<2>());
    }

    // Get a non-`const` reference to the fourth stored variable.
    constexpr auto fourth() & -> auto& requires(this->size >= 4) {
        return this->get<3>();
    }

    // Get a `const` reference to the fourth stored variable.
    constexpr auto fourth() const& -> auto const& requires(this->size >= 4) {
        return this->get<3>();
    }

    // Move the fourth stored variable.
    constexpr auto fourth() && -> auto&& requires(this->size >= 4) {
        return move(this->get<3>());
    }

    // Move the fourth stored variable.
    constexpr auto fourth() const&& -> auto const&& requires(this->size >= 4) {
        return move(this->get<3>());
    }

    // Get a non-`const` reference to the fifth stored variable.
    constexpr auto fifth() & -> auto& requires(this->size >= 5) {
        return this->get<4>();
    }

    // Get a `const` reference to the fifth stored variable.
    constexpr auto fifth() const& -> auto const& requires(this->size >= 5) {
        return this->get<4>();
    }

    // Move the fifth stored variable.
    constexpr auto fifth() && -> auto&& requires(this->size >= 5) {
        return move(this->get<4>());
    }

    // Move the fifth stored variable.
    constexpr auto fifth() const&& -> auto const&& requires(this->size >= 5) {
        return move(this->get<4>());
    }
};

// This deduction guide is required for variadic type deduction.
template <typename... Ts>
Tuple(Ts...) -> Tuple<Ts...>;

}  // namespace cat

template <typename... Tuples>
constexpr auto tuple_cat(Tuples&&... tuples);

namespace std {

// template <typename...>
// struct tuple_size {};  // NOLINT

template <typename>
struct tuple_size;  // NOLINT

template <typename... Ts>
struct tuple_size<cat::Tuple<Ts...>> : cat::Constant<sizeof...(Ts)> {};

template <typename T>
inline constexpr usize::Raw tuple_size_v = tuple_size<T>::value;

template <usize::Raw, typename>
struct tuple_element;

template <usize::Raw index, typename... Ts>
struct tuple_element<index, cat::Tuple<Ts...>> {
    // NOLINTNEXTLINE
    using type = decltype(cat::Tuple<Ts...>{}.template get<ssize{index}>());
};

template <usize::Raw I, typename T>
using tuple_element_t = typename tuple_element<I, T>::type;  // NOLINT

}  // namespace std

#include "implementations/tuple_cat.tpp"
