// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

namespace std {

// NOLINTNEXTLINE This must be snake_case.
class source_location {
  public:
    static constexpr auto current(
        decltype(__builtin_source_location()) p_call_site_location =
            __builtin_source_location()) -> source_location {
        source_location current_location;
        current_location.p_location =
            static_cast<__impl const*>(p_call_site_location);
        return current_location;
    }

    constexpr auto line() const -> unsigned long {
        return (this->p_location != nullptr) ? this->p_location->_M_line : 0u;
    }

    constexpr auto column() const -> unsigned long {
        return (this->p_location != nullptr) ? this->p_location->_M_column : 0u;
    }

    constexpr auto file_name() const -> char const* {
        return this->p_location->_M_file_name;
        // return (this->p_location != nullptr) ? this->p_location->_M_file_name
        //                                      : "";
    }

    constexpr auto function_name() const -> char const* {
        return (this->p_location != nullptr)
                   ? this->p_location->_M_function_name
                   : "";
    }

  private:
    // GCC requires these names be exactly what they are.
    struct __impl {                    // NOLINT
        char const* _M_file_name;      // NOLINT
        char const* _M_function_name;  // NOLINT
        unsigned long _M_line;         // NOLINT
        unsigned long _M_column;       // NOLINT
    };

    __impl const* p_location = nullptr;
};

}  // namespace std

namespace cat {
using SourceLocation = std::source_location;
}
