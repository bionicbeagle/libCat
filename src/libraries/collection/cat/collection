// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/algorithm>
#include <cat/iterator>
#include <cat/math>

namespace cat {

// Forward declarations for containers and algorithms needed by
// `CollectionFacade`.
template <typename T>
class Span;

template <typename T>
concept collection = requires(T container) {
    container.begin();
    container.end();
    container.cbegin();
    container.cend();
    container.size();
};

namespace detail {
    template <typename T>
    concept contiguousCollection = requires(T collection) {
        collection.p_data();
    };

    // clang-format off
    template <typename T>
    // Parentheses are required here to make cppcheck work.
    concept boundedCollection = (requires(T collection) {
        collection.size();
    }) || (requires(T collection) {
        collection.capacity();
    });
    // clang-format on

    // If `.size()` is provided.
    template <typename T>
    concept hasSize = requires(T t) {
        t.size();
    };

    // If `.capacity()` is provided.
    template <typename T>
    concept hasCapacity = requires(T t) {
        t.capacity();
    };
}  // namespace detail

template <typename Derived, typename T>
class CollectionFacade {
  private:
    // `is_array_like` at the top of this class instead of the bottom prevents
    // clangd false diagnostics.
    static constexpr bool is_array_like =
        detail::contiguousCollection<Derived> &&
        detail::boundedCollection<Derived>;

  public:
    // If `.size()` is not, provided and `.capacity()` is, generate
    // `.size()`.
    [[nodiscard]] constexpr auto size() const -> ssize
        requires(detail::hasCapacity<Derived> && !detail::hasSize<Derived>) {
        return this->self().capacity();
    }

    // If `.size()` is provided and `.capacity()` is not, generate
    // `.capacity()`.
    [[nodiscard]] constexpr auto capacity() const -> ssize
        requires(detail::hasSize<Derived>) {
        return this->self().size();
    }

    // This evaluates true if there are one or more elements currently in this
    // collection.
    [[nodiscard]] constexpr auto is_empty() const
        -> bool requires(detail::hasSize<Derived>) {
        return this->self().size() > 0;
    }

    // Index into this collection with bounds-checking.
    [[nodiscard]] constexpr auto at(ssize index) -> Optional<T&>
        requires(is_array_like)
    {
        if (!is_constant_evaluated()) {
            cat::assert(index >= 0);
        }
        if (index < this->self().capacity()) {
            return this->self_mut().p_data()[index.raw];
        }
        return nullopt;
    }

    // Index into this collection with bounds-checking.
    [[nodiscard]] constexpr auto at(ssize index) const -> Optional<T&> {
        // `unconst()` allows `.at()` to be safely called in a `const` context.
        return unconst(this)->at(index);
    }

    [[nodiscard]] constexpr auto front() -> T& requires(this->is_array_like) {
        return this->self_mut().p_data()[0];
    }

    [[nodiscard]] constexpr auto front() const -> T const& {
        return unconst(this)->front();
    }

    [[nodiscard]] constexpr auto back() -> T& requires(this->is_array_like) {
        return this->self_mut().p_data()[this->self().size().raw - 1];
    }

    [[nodiscard]] constexpr auto back() const -> T const& {
        return unconst(this)->back();
    }

    [[nodiscard]] constexpr auto subspan(ssize start_index, ssize end_index)
        -> Span<T>
        requires(this->is_array_like)
    {
        if (!is_constant_evaluated()) {
            cat::assert(start_index >= 0);
            cat::assert(end_index <= this->self().capacity());
        }

        return Span<T>(this->self().p_data() + start_index,
                       end_index - start_index);
    }

    [[nodiscard]] constexpr auto subspan(ssize start_index,
                                         ssize end_index) const -> Span<T const>
        requires(this->is_array_like)
    {
        if (!is_constant_evaluated()) {
            cat::assert(start_index >= 0);
            cat::assert(end_index <= this->self().capacity());
        }

        return Span<T const>(this->self().p_data() + start_index,
                             end_index - start_index);
    }

    [[nodiscard]] constexpr auto first(ssize count) -> Span<T>
        requires(this->is_array_like)
    { return this->subspan(0, count); }

    [[nodiscard]] constexpr auto first(ssize count) const -> Span<T const>
        requires(this->is_array_like)
    { return this->subspan(0, count); }

    [[nodiscard]] constexpr auto last(ssize count) -> Span<T>
        requires(this->is_array_like)
    { return this->subspan(this->self().size() - count, this->self().size()); }

    [[nodiscard]] constexpr auto last(ssize count) const -> Span<T const>
        requires(this->is_array_like)
    { return this->subspan(this->self().size() - count, this->self().size()); }

    template <integral U>
        requires(is_array_like)
    [[nodiscard]] constexpr auto operator[](U index) -> T& {
        if (!is_constant_evaluated()) {
            assert(index >= 0);
            assert(index < this->self().size());
        }

        return this->self_mut().p_data()[to_raw_numeral(index)];
    }

    template <integral U>
        requires(is_array_like)
    [[nodiscard]] constexpr auto operator[](U index) const -> T const& {
        if (!is_constant_evaluated()) {
            assert(index >= 0);
            assert(index < this->self().size());
        }

        return this->self().p_data()[to_raw_numeral(index)];
    }

    // `.begin()` and `.end()` can be automatically generated for contiguous
    // collections.
    [[nodiscard]] constexpr auto begin() requires(this->is_array_like) {
        return RemoveConst<decltype(unconst(this)->make_iterator())>{
            0, this->self_mut().p_data()};
    }

    [[nodiscard]] constexpr auto end() requires(this->is_array_like) {
        return RemoveConst<decltype(unconst(this)->make_iterator())>{
            this->self_mut().size(), this->self().p_data()};
    }

    // If this collection is not contiguous, get a non-`const` `.begin()` method
    // from `Derived`.
    [[nodiscard]] constexpr auto begin() {
        return this->self_mut().begin();
    }

    // If this collection is not contiguous, get a non-`const` `.end()` method
    // from `Derived`.
    [[nodiscard]] constexpr auto end() {
        return this->self_mut().end();
    }

    [[nodiscard]] constexpr auto begin() const {
        return unconst(this)->begin();
    }

    [[nodiscard]] constexpr auto end() const {
        return unconst(this)->end();
    }

    [[nodiscard]] constexpr auto cbegin() const {
        return this->begin();
    }

    [[nodiscard]] constexpr auto cend() const {
        return this->end();
    }

    [[nodiscard]] constexpr auto rbegin() requires(this->is_array_like) {
        return ReversedIterator<decltype(this->begin())>{
            this->self().size() - 1, this->self().p_data()};
    }

    [[nodiscard]] constexpr auto rend() requires(this->is_array_like) {
        return ReversedIterator<decltype(this->end())>(-1,
                                                       this->self().p_data());
    }

    // If this collection is not contiguous, get a non-`const` `.rbegin()`
    // method from `Derived`.
    [[nodiscard]] constexpr auto rbegin() requires(!this->is_array_like) {
        return this->self_mut().rbegin();
    }

    // If this collection is not contiguous, get a non-`const` `.rend()` method
    // from `Derived`.
    [[nodiscard]] constexpr auto rend() requires(!this->is_array_like) {
        return this->self_mut().rbegin();
    }

    [[nodiscard]] constexpr auto rbegin() const {
        return unconst(this)->rbegin();
    }

    [[nodiscard]] constexpr auto rend() const {
        return unconst(this)->rend();
    }

    [[nodiscard]] constexpr auto crbegin() const {
        return this->rbegin();
    }

    [[nodiscard]] constexpr auto crend() const {
        return this->rend();
    }

    // Member-access syntax algorithms.

    template <collection Other>
    auto copy_to(Other const& destination) const {
        assert(destination.capacity() >= this->capacity());
        return cat::copy(this->begin(), this->end(), destination.begin());
    }

    template <collection Other>
    auto move_to(Other const& destination) const {
        assert(destination.capacity() >= this->capacity());
        return cat::move(this->begin(), this->end(), destination.begin());
    }

    template <collection Other>
    auto relocate_to(Other const& destination) const {
        assert(destination.capacity() >= this->capacity());
        return cat::relocate(this->begin(), this->end(), destination.begin());
    }

    // Implementation details for type reflection.
  private:
    constexpr auto self_mut() -> Derived& {
        return static_cast<Derived&>(*this);
    }

    constexpr auto self() -> Derived& {
        return static_cast<Derived&>(*this);
    }

    constexpr auto self() const -> Derived const& {
        return static_cast<Derived const&>(*this);
    }

    // If the collection does not define an iterator, then one should be
    // generated. This function only exists for the purpose of deducing the type
    // of an iterator as `decltype(make_iterator())`.

    // Contiguous collections can produce non-`const` bidirectional iterators.
    constexpr auto make_iterator() requires(this->is_array_like) {
        class Iterator : public IteratorFacade<Iterator> {
          public:
            friend IteratorFacade<Iterator>;
            using Collection [[maybe_unused]] = Derived;

            constexpr Iterator(Iterator const&) = default;
            constexpr Iterator(ssize index, T* p_in_array)
                : current_index(index), p_array(p_in_array){};

            constexpr auto dereference() -> T& {
                return unconst(this->p_array[current_index.raw]);
            }
            constexpr auto dereference() const -> T const& {
                return this->p_array[current_index.raw];
            }
            constexpr void advance(ssize offset) {
                this->current_index += offset;
            }
            constexpr auto distance_to(Iterator const& other) const -> ssize {
                return other.current_index - current_index;
            }

            // TODO: Implement these in terms of `<=>`.
            constexpr auto operator<(Iterator const& other_iterator) const
                -> bool {
                return this->current_index < other_iterator.current_index;
            }
            constexpr auto operator<=(Iterator const& other_iterator) const
                -> bool {
                return this->current_index <= other_iterator.current_index;
            }
            constexpr auto operator>(Iterator const& other_iterator) const
                -> bool {
                return this->current_index > other_iterator.current_index;
            }
            constexpr auto operator>=(Iterator const& other_iterator) const
                -> bool {
                return this->current_index >= other_iterator.current_index;
            }

          private:
            ssize current_index;
            T* const p_array;
        };

        // Produce an iterator to have its type deduced later.
        return Iterator{0, nullptr};
    }

    // Contiguous collections can produce `const` bidirectional iterators.
    constexpr auto make_iterator() const requires(this->is_array_like) {
        class Iterator : public IteratorFacade<Iterator> {
          public:
            friend IteratorFacade<Iterator>;
            using Collection [[maybe_unused]] = Derived;

            constexpr Iterator(Iterator const&) = default;
            constexpr Iterator(ssize index, T const* p_in_array)
                : current_index(index), p_array(p_in_array){};

            constexpr auto dereference() const -> T const& {
                return this->p_array[current_index.raw];
            }
            constexpr void advance(ssize offset) {
                this->current_index += offset;
            }
            constexpr auto distance(Iterator const& other) const -> ssize {
                return other.current_index - current_index;
            }

          private:
            ssize current_index;
            T const* const p_array;
        };

        // Produce an iterator to have its type deduced later.
        return Iterator{0, nullptr};
    }

    // If `Derived` is not contiguous, use a provided iterator.
    static constexpr auto make_iterator() {
        // Produce an iterator to have its type deduced later.
        return typename Derived::Iterator{};
    }
};

template <typename T>
struct CollectionTraits {
    using Iterator = decltype(T{}.begin());
    using ConstIterator = AddConst<Iterator>;
    using ReversedIterator = cat::ReversedIterator<Iterator>;
    using ConstReversedIterator = cat::ReversedIterator<ConstIterator>;

    static constexpr bool is_array_like =
        detail::contiguousCollection<T> && detail::boundedCollection<T>;
};

}  // namespace cat
