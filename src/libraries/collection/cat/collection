// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/algorithm>
#include <cat/iterator>
#include <cat/math>

namespace cat {

// Forward declarations for containers and algorithms needed by
// `collection_interface`.
template <typename T>
class span;

template <typename T>
concept is_collection = requires(T container) {
    container.begin();
    container.end();
    container.cbegin();
    container.cend();
    container.size();
};

namespace detail {
    template <typename T>
    concept is_contiguous_collection = requires(T collection) {
        collection.data();
    };

    // clang-format off
    template <typename T>
    // Parentheses are required here to satisfy cppcheck.
    concept is_bounded_collection = (requires(T collection) {
        collection.size();
    }) || (requires(T collection) {
        collection.capacity();
    });
    // clang-format on

    // If `.size()` is provided.
    template <typename T>
    concept has_size = requires(T t) {
        t.size();
    };

    // If `.capacity()` is provided.
    template <typename T>
    concept has_capacity = requires(T t) {
        t.capacity();
    };
}  // namespace detail

template <typename derived_type, typename T>
class collection_interface {
  private:
    // `is_array_like` at the top of this class instead of the bottom prevents
    // clangd false diagnostics.
    static constexpr bool is_array_like =
        detail::is_contiguous_collection<derived_type> &&
        detail::is_bounded_collection<derived_type>;

  public:
    // If `.size()` is not, provided and `.capacity()` is, generate
    // `.size()`.
    [[nodiscard]] constexpr auto size() const -> ssize
        requires(detail::has_capacity<derived_type> &&
                 !detail::has_size<derived_type>) {
        return this->self().capacity();
    }

    // If `.size()` is provided and `.capacity()` is not, generate
    // `.capacity()`.
    [[nodiscard]] constexpr auto capacity() const -> ssize
        requires(detail::has_size<derived_type>) {
        return this->self().size();
    }

    // This evaluates true if there are one or more elements currently in this
    // collection.
    [[nodiscard]] constexpr auto is_empty() const
        -> bool requires(detail::has_size<derived_type>) {
        return this->self().size() == 0;
    }

    // This evaluates true if there are one or more elements currently in this
    // collection.
    [[nodiscard]] constexpr auto is_full() const
        -> bool requires(detail::has_size<derived_type>) {
        return this->self().size() == this->self().capacity();
    }

    // Index into this collection with bounds-checking.
    [[nodiscard]] constexpr auto at(ssize index) -> maybe<T&>
        requires(is_array_like)
    {
        // TODO: `if !consteval {` when using clangd 16.
        if (!__builtin_is_constant_evaluated()) {
            cat::assert(index >= 0);
        }
        if (index < this->self().capacity()) {
            return this->self_mut().data()[index.raw];
        }
        return nullopt;
    }

    // Index into this collection with bounds-checking.
    [[nodiscard]] constexpr auto at(ssize index) const -> maybe<T&> {
        // `unconst()` allows `.at()` to be safely called in a `const` context.
        return unconst(this)->at(index);
    }

    [[nodiscard]] constexpr auto front() -> T& requires(this->is_array_like) {
        cat::assert(this->self().size() > 0);
        return this->self_mut().data()[0];
    }

    [[nodiscard]] constexpr auto front() const -> T const& {
        cat::assert(this->self().size() > 0);
        return unconst(this)->front();
    }

    [[nodiscard]] constexpr auto back() -> T& requires(this->is_array_like) {
        cat::assert(this->self().size() > 0);
        return this->self_mut().data()[this->self().size().raw - 1];
    }

    [[nodiscard]] constexpr auto back() const -> T const& {
        cat::assert(this->self().size() > 0);
        return unconst(this)->back();
    }

    [[nodiscard]] constexpr auto subspan(ssize start_index, ssize end_index)
        -> span<T>
        requires(this->is_array_like)
    {
        // TODO: `if !consteval {` when using clangd 16.
        if (!__builtin_is_constant_evaluated()) {
            cat::assert(start_index >= 0);
            cat::assert(end_index <= this->self().capacity());
        }

        return span<T>(this->self().data() + start_index,
                       end_index - start_index);
    }

    [[nodiscard]] constexpr auto subspan(ssize start_index,
                                         ssize end_index) const -> span<T const>
        requires(this->is_array_like)
    {
        // TODO: `if !consteval {` when using clangd 16.
        if (!__builtin_is_constant_evaluated()) {
            cat::assert(start_index >= 0);
            cat::assert(end_index <= this->self().capacity());
        }

        return span<T const>(this->self().data() + start_index,
                             end_index - start_index);
    }

    [[nodiscard]] constexpr auto first(ssize count) -> span<T>
        requires(this->is_array_like)
    { return this->subspan(0, count); }

    [[nodiscard]] constexpr auto first(ssize count) const -> span<T const>
        requires(this->is_array_like)
    { return this->subspan(0, count); }

    [[nodiscard]] constexpr auto last(ssize count) -> span<T>
        requires(this->is_array_like)
    { return this->subspan(this->self().size() - count, this->self().size()); }

    [[nodiscard]] constexpr auto last(ssize count) const -> span<T const>
        requires(this->is_array_like)
    { return this->subspan(this->self().size() - count, this->self().size()); }

    template <is_integral U>
        requires(is_array_like)
    [[nodiscard]] constexpr auto operator[](U index) -> T& {
        // TODO: `if !consteval {` when using clangd 16.
        if (!__builtin_is_constant_evaluated()) {
            assert(index >= 0);
            assert(index < this->self().size());
        }

        return this->self_mut().data()[to_raw_arithmetic(index)];
    }

    template <is_integral U>
        requires(is_array_like)
    [[nodiscard]] constexpr auto operator[](U index) const -> T const& {
        // TODO: `if !consteval {` when using clangd 16.
        if (!__builtin_is_constant_evaluated()) {
            assert(index >= 0);
            assert(index < this->self().size());
        }

        return this->self().data()[to_raw_arithmetic(index)];
    }

    // `.begin()` and `.end()` can be automatically generated for contiguous
    // collections.
    [[nodiscard]] constexpr auto begin() requires(this->is_array_like) {
        return remove_const<decltype(unconst(this)->make_iterator())>{
            0, this->self_mut().data()};
    }

    [[nodiscard]] constexpr auto end() requires(this->is_array_like) {
        return remove_const<decltype(unconst(this)->make_iterator())>{
            this->self_mut().size(), this->self().data()};
    }

    // If this collection is not contiguous, get a non-`const` `.begin()` method
    // from `derived_type`.
    [[nodiscard]] constexpr auto begin() {
        return this->self_mut().begin();
    }

    // If this collection is not contiguous, get a non-`const` `.end()` method
    // from `derived_type`.
    [[nodiscard]] constexpr auto end() {
        return this->self_mut().end();
    }

    [[nodiscard]] constexpr auto begin() const {
        return unconst(this)->begin();
    }

    [[nodiscard]] constexpr auto end() const {
        return unconst(this)->end();
    }

    [[nodiscard]] constexpr auto cbegin() const {
        return this->begin();
    }

    [[nodiscard]] constexpr auto cend() const {
        return this->end();
    }

    [[nodiscard]] constexpr auto rbegin() requires(this->is_array_like) {
        return reversed_iterator_type<decltype(this->begin())>{
            this->self().size() - 1, this->self().data()};
    }

    [[nodiscard]] constexpr auto rend() requires(this->is_array_like) {
        return reversed_iterator_type<decltype(this->end())>(
            -1, this->self().data());
    }

    // If this collection is not contiguous, get a non-`const` `.rbegin()`
    // method from `derived_type`.
    [[nodiscard]] constexpr auto rbegin() requires(!this->is_array_like) {
        return this->self_mut().rbegin();
    }

    // If this collection is not contiguous, get a non-`const` `.rend()` method
    // from `derived_type`.
    [[nodiscard]] constexpr auto rend() requires(!this->is_array_like) {
        return this->self_mut().rbegin();
    }

    [[nodiscard]] constexpr auto rbegin() const {
        return unconst(this)->rbegin();
    }

    [[nodiscard]] constexpr auto rend() const {
        return unconst(this)->rend();
    }

    [[nodiscard]] constexpr auto crbegin() const {
        return this->rbegin();
    }

    [[nodiscard]] constexpr auto crend() const {
        return this->rend();
    }

    // Member-access syntax algorithms.

    template <is_collection Other>
    auto copy_to(Other const& destination) const {
        assert(destination.capacity() >= this->capacity());
        return cat::copy(this->begin(), this->end(), destination.begin());
    }

    template <is_collection Other>
    auto move_to(Other const& destination) const {
        assert(destination.capacity() >= this->capacity());
        return cat::move(this->begin(), this->end(), destination.begin());
    }

    template <is_collection Other>
    auto relocate_to(Other const& destination) const {
        assert(destination.capacity() >= this->capacity());
        return cat::relocate(this->begin(), this->end(), destination.begin());
    }

    // Implementation details for type reflection.
  private:
    constexpr auto self_mut() -> derived_type& {
        return static_cast<derived_type&>(*this);
    }

    constexpr auto self() -> derived_type& {
        return static_cast<derived_type&>(*this);
    }

    constexpr auto self() const -> derived_type const& {
        return static_cast<derived_type const&>(*this);
    }

    // If the collection does not define an iterator, then one should be
    // generated. This function only exists for the purpose of deducing the type
    // of an iterator as `decltype(make_iterator())`.

    // Contiguous collections can produce non-`const` bidirectional iterators.
    constexpr auto make_iterator() requires(this->is_array_like) {
        class iterator_type : public iterator_interface<iterator_type> {
          public:
            using collection_type [[maybe_unused]] = derived_type;

            constexpr iterator_type(iterator_type const&) = default;

            constexpr iterator_type(ssize index, T* p_in_array)
                : current_index(index), p_array(p_in_array) {
            }

            constexpr auto dereference() -> T& {
                return this->p_array[current_index.raw];
            }

            constexpr auto dereference() const -> T const& {
                return this->p_array[current_index.raw];
            }

            constexpr void advance(ssize offset) {
                this->current_index += offset;
            }

            constexpr auto distance_to(iterator_type const& other) const
                -> ssize {
                return other.current_index - current_index;
            }

          private:
            ssize current_index;
            T* p_array;
        };

        // Produce an iterator to have its type deduced later.
        return iterator_type(0, nullptr);
    }

    // Contiguous collections can produce `const` bidirectional iterators.
    constexpr auto make_iterator() const requires(this->is_array_like) {
        class iterator_type : public iterator_interface<iterator_type> {
          public:
            using collection_type [[maybe_unused]] = derived_type;

            constexpr iterator_type(iterator_type const&) = default;

            constexpr iterator_type(ssize index, T const* p_in_array)
                : current_index(index), p_array(p_in_array) {
            }

            constexpr auto dereference() const -> T const& {
                return this->p_array[current_index.raw];
            }

            constexpr void advance(ssize offset) {
                this->current_index += offset;
            }

            constexpr auto distance(iterator_type const& other) const -> ssize {
                return other.current_index - current_index;
            }

          private:
            ssize current_index;
            T const* const p_array;
        };

        // Produce an iterator to have its type deduced later.
        return iterator_type(0, nullptr);
    }

    // If `derived_type` is not contiguous, use a provided iterator.
    static constexpr auto make_iterator() {
        // Produce an iterator to have its type deduced later.
        return typename derived_type::iterator_type();
    }
};

template <typename T>
struct collection_traits {
    using iterator_type = decltype(T().begin());
    using const_iterator_type = add_const<iterator_type>;
    using reversed_iterator_type = cat::reversed_iterator_type<iterator_type>;
    using const_reversed_iterator_type =
        cat::reversed_iterator_type<const_iterator_type>;

    static constexpr bool is_array_like =
        detail::is_contiguous_collection<T> && detail::is_bounded_collection<T>;
};

}  // namespace cat
