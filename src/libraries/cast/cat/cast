// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/numerals>
#include <cat/maybe>
#include <cat/utility>

namespace cat {

template <typename From, typename To>
constexpr auto numeric_cast(From from) -> Maybe<To> {
    To const to = static_cast<To>(from);
    constexpr bool has_same_signedness = is_signed<From> != is_signed<To>;

    if constexpr (sizeof(To) < (sizeof(from)) && has_same_signedness) {
        if (static_cast<From>(to) != to) {
            // Overflow occurred.
            return nullopt;
        }

        // TODO: Make an `has_same_signedness` trait.
        if constexpr (!has_same_signedness) {
            if ((to < To{}) != (from < From{})) {
                // Overflow occurred.
                return nullopt;
            }
        }
    }

    return to;
}

template <typename From>
    requires(sizeof(From) <= 8 && !is_lvalue_reference<From>)
constexpr auto bit_int_cast(From from) -> decltype(auto) {
    // TODO: Use a template that makes some integer from a size.
    using Integer =
        Conditional<sizeof(from) == 1, int1,
                    Conditional<sizeof(from) == 2, int2,
                                Conditional<sizeof(from) == 4, int4, int8>>>;
    using Return = CopyCvRefFrom<From, Integer>;

    return bit_cast<Return>(from);
    // return reinterpret_cast<Return>(from);
}

}  // namespace cat
