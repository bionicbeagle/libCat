// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/iterator>

#include "cat/numerals"

namespace cat {

// TODO: Explicit output type is ambiguous when given 2 function arguments.

template <typename T>
constexpr auto min(T const& value) -> T const& {
    return value;
}

// Implicit output type `min()`.
template <typename T, typename... Remaining>
constexpr auto min(T const& value_1, T const& value_2, Remaining&&... remaining)
    -> T const& {
    // Recurse through the list of variadic arguments, discarding the larger
    // element each time.
    return (value_1 < value_2) ? min(value_1, forward<Remaining>(remaining)...)
                               : min(value_2, forward<Remaining>(remaining)...);
}

constexpr auto min(iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator < maximum ? *iterator : maximum;
    }
    return maximum;
}

template <typename T>
constexpr auto min(iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator < maximum ? *iterator : maximum;
    }
    return static_cast<T>(maximum);
}

template <typename T>
constexpr auto max(T const& value) -> T const& {
    return value;
}

// Implicit output type `max()`.
template <typename T, typename... Remaining>
constexpr auto max(T const& value_1, T const& value_2, Remaining&&... remaining)
    -> T const& {
    // Recurse through the list of variadic arguments, discarding the larger
    // element each time.
    return (value_1 > value_2) ? max(value_1, forward<Remaining>(remaining)...)
                               : max(value_2, forward<Remaining>(remaining)...);
}

// TODO: If an `iterable` has `<` and `>` operators, this has unclear intent.

constexpr auto max(iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator > maximum ? *iterator : maximum;
    }
    return maximum;
}

template <typename T>
constexpr auto max(iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator > maximum ? *iterator : maximum;
    }
    return static_cast<T>(maximum);
}

// TODO: Use an `arithmetic` concept or something, but support safe numerals.
constexpr auto abs(auto const& value) {
    // TODO: Check if the builtin `abs()` function family is optimized better.
    return value < 0 ? value * -1 : value;
}

namespace detail {
    // TODO: Use an optimized algorithm instead.
    template <integral T, typename U>
    constexpr auto pow_integral(T base, U exponent) -> T {
        if (0 == exponent) {
            return 1;
        }
        T z = base;
        T y = 1;
        while (true) {
            if (exponent & 1) {
                y *= z;
            }
            exponent /= 2;
            if (exponent == 0) {
                break;
            }
            z *= z;
        }
        return y;
    }
}  // namespace detail

template <arithmetic T>
constexpr auto pow(T base, T exponent) {
    // Level `Numeral` into primitive types.
    auto raw_base = to_raw_numeral(base);
    using Raw = decltype(raw_base);

    if constexpr (integral<Raw>) {
        return detail::pow_integral(raw_base, exponent);
    } else if constexpr (is_same<Raw, float>) {
        return __builtin_powf(raw_base, exponent);
    } else if constexpr (is_same<Raw, double>) {
        return __builtin_pow(raw_base, exponent);
    } else if constexpr (is_same<Raw, long double>) {
        return __builtin_powl(raw_base, exponent);
    }
}

}  // namespace cat
