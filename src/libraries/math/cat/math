// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/iterator>

namespace cat {

// TODO: Explicit output type is ambiguous when given 2 function arguments.

template <typename T>
constexpr auto min(T const& value) -> T const& {
    return value;
}

// Implicit output type `min()`.
template <typename T, typename... Remaining>
constexpr auto min(T const& value_1, T const& value_2, Remaining&&... remaining)
    -> T const& {
    // Recurse through the list of variadic arguments, discarding the larger
    // element each time.
    return (value_1 < value_2) ? min(value_1, forward<Remaining>(remaining)...)
                               : min(value_2, forward<Remaining>(remaining)...);
}

constexpr auto min(iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator < maximum ? *iterator : maximum;
    }
    return maximum;
}

template <typename T>
constexpr auto min(iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator < maximum ? *iterator : maximum;
    }
    return static_cast<T>(maximum);
}

template <typename T>
constexpr auto max(T const& value) -> T const& {
    return value;
}

// Implicit output type `max()`.
template <typename T, typename... Remaining>
constexpr auto max(T const& value_1, T const& value_2, Remaining&&... remaining)
    -> T const& {
    // Recurse through the list of variadic arguments, discarding the larger
    // element each time.
    return (value_1 > value_2) ? max(value_1, forward<Remaining>(remaining)...)
                               : max(value_2, forward<Remaining>(remaining)...);
}

// TODO: If an `iterable` has `<` and `>` operators, this has unclear intent.

constexpr auto max(iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator > maximum ? *iterator : maximum;
    }
    return maximum;
}

template <typename T>
constexpr auto max(iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator > maximum ? *iterator : maximum;
    }
    return static_cast<T>(maximum);
}

// TODO: Use an `arithmetic` concept or something, but support safe numerals.
constexpr auto abs(auto const& value) {
    // TODO: Check if the builtin `abs()` function family is optimized better.
    return value < 0 ? value * -1 : value;
}

}  // namespace cat
