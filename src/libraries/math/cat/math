// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/arithmetic>
#include <cat/iterator>

// TODO: Write tests for math functions.

namespace cat {

// TODO: Explicit output type is ambiguous when given 2 function arguments.

template <typename T>
constexpr auto min(T const& value) -> T const& {
    return value;
}

// Implicit output type `min()`.
template <typename T, typename... Remaining>
constexpr auto min(T const& value_1, T const& value_2, Remaining&&... remaining)
    -> T const& {
    // Recurse through the list of variadic arguments, discarding the larger
    // element each time.
    return (value_1 < value_2) ? min(value_1, forward<Remaining>(remaining)...)
                               : min(value_2, forward<Remaining>(remaining)...);
}

constexpr auto min(is_iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator < maximum ? *iterator : maximum;
    }
    return maximum;
}

template <typename T>
constexpr auto min(is_iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator < maximum ? *iterator : maximum;
    }
    return static_cast<T>(maximum);
}

template <typename T>
constexpr auto max(T const& value) -> T const& {
    return value;
}

// Implicit output type `max()`.
template <typename T, typename... Remaining>
constexpr auto max(T const& value_1, T const& value_2, Remaining&&... remaining)
    -> T const& {
    // Recurse through the list of variadic arguments, discarding the larger
    // element each time.
    return (value_1 > value_2) ? max(value_1, forward<Remaining>(remaining)...)
                               : max(value_2, forward<Remaining>(remaining)...);
}

// TODO: If an `iterable` has `<` and `>` operators, this has unclear intent.

constexpr auto max(is_iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator > maximum ? *iterator : maximum;
    }
    return maximum;
}

template <typename T>
constexpr auto max(is_iterable auto&& iterable) {
    auto iterator = iterable.begin();
    auto maximum = *iterator;
    ++iterator;

    for (; iterator != iterable.end(); ++iterator) {
        maximum = *iterator > maximum ? *iterator : maximum;
    }
    return static_cast<T>(maximum);
}

// TODO: Use an `is_arithmetic` concept or something, but support safe numerals.
constexpr auto abs(auto const& value) {
    // TODO: Check if the builtin `abs()` function family is optimized better.
    return value < 0 ? value * -1 : value;
}

namespace detail {
    // TODO: Consider a jump-table implementation, or
    template <is_integral T, typename U>
    constexpr auto pow_integral(T base, U exponent) -> T {
        if (exponent < 0) {
            // A negative exponent should always make this floor to 0.
            return 0;
        }

        if constexpr (is_signed<T>) {
            base = abs(base);
        }

        // "Exponentation by squaring" algorithm.
        int result = 1;
        while (exponent) {
            if (exponent & 1) {
                result *= base;
            }
            // Since this is guaranteed positive, it can bitshift.
            exponent >>= 1;
            base *= base;
        }

        return result;
    }
}  // namespace detail

template <is_arithmetic T, is_integral U>
constexpr auto pow(T base, U exponent) -> T {
    // Type-erase `Arithmetic`s to prevent redundant code gen.
    using Raw = ToRawArithmetic<T>;
    Raw raw_base = to_raw_numeral(base);
    Raw raw_exponent = to_raw_numeral(exponent);

    if constexpr (is_integral<Raw>) {
        return detail::pow_integral(raw_base, raw_exponent);
        // TODO: Support float and double `pow()` functions.
    } else if constexpr (is_same<Raw, float>) {
        // return __builtin_powf(raw_base, raw_exponent);
    } else if constexpr (is_same<Raw, double>) {
        // return __builtin_pow(raw_base, raw_exponent);
    }
}

template <is_arithmetic T>
constexpr auto is_power_of_two(T value) -> bool {
    return (value & (value - T(1))) == T(0);
}

template <is_arithmetic T>
auto clamp(T value, T min, T max) -> T {
    T lower_bound = value < min ? min : value;
    return lower_bound > max ? max : lower_bound;
}

}  // namespace cat
