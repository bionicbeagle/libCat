// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/meta>

namespace cat {

// TODO: See if moving `bit_cast()` into `std::` improves debuggability without
// breaking anything.

template <typename T, typename U>
[[gnu::warning("This function is intended to be inlined and constant-folded \
out."),
  gnu::always_inline]] constexpr inline auto
bit_cast(U& from_value) -> T;

template <typename T, typename U>
[[gnu::warning("This function is intended to be inlined and constant-folded \
out."),
  gnu::always_inline]] constexpr inline auto
bit_cast(U const& from_value) -> T;

template <typename T>
constexpr auto unconst(T const& value) -> T& {
    return const_cast<T&>(value);
}

template <typename T>
constexpr auto unconst(T const* p_value) -> T* {
    return const_cast<T*>(p_value);
}

// Infer the length of a parameter pack from a function argument.
template <typename... Ts>
constexpr auto ssizeof_pack(Ts...) -> ssize {
    return make_signed(sizeof...(Ts));
}

// Specify the length of a parameter pack in a template argument.
template <typename... Ts>
constexpr auto ssizeof_pack() -> ssize {
    return make_signed(sizeof...(Ts));
}

constexpr auto salignof(auto const& anything) -> ssize {
    // `alignof` cannot be given an expression `anything` in ISO C++, so it must
    // take the type `decltype(anything)`.
    return ssize{alignof(decltype(anything))};
}

template <typename T>
constexpr auto salignof() -> ssize {
    return ssize{alignof(T)};
}

namespace detail {
    template <typename T, ssize index, ssize current, T value, T... values>
    constexpr auto get_value_list_at() -> T {
        if constexpr (current == index) {
            return value;
        } else {
            return get_value_list_at<T, index, current + 1, values...>();
        }
    }
}  // namespace detail

template <typename T, T... values>
    requires(is_integral<T>)
struct value_type_list {
    using value_type = T;

    static constexpr ssize size = ssizeof_pack(values...);

    template <ssize index>
    static constexpr auto get() -> T {
        return detail::get_value_list_at<T, index, 0, values...>();
    }
};

namespace detail {
    template <ssize count, typename T, T value, T... integers>
    constexpr auto make_value_list() {
        if constexpr (count > 0) {
            // Recurse, appending `value` to `integers`.
            return make_value_list<count - 1, T, value, value, integers...>();
        } else {
            return value_type_list<T, integers...>();
        }
    }

    // TODO: Look into `__integer_pack()`.
    template <ssize count, typename T, T value, T... integers>
    constexpr auto make_integer_sequence() {
        if constexpr (count > 0) {
            // Recurse, appending `count - 1` to `integers`.
            return make_integer_sequence<count - 1, T, T(count.raw - 1),
                                         T(count.raw - 1), integers...>();
        } else {
            return value_type_list<T, integers...>();
        }
    }
}  // namespace detail

template <typename T, T value, ssize count>
constexpr auto value_list = detail::make_value_list<count, T, value>();

template <typename T, T value, ssize count>
using make_value_type_list = decltype(value_list<T, value, count>);

template <is_integral T, ssize count>
constexpr auto integer_sequence =
    detail::make_integer_sequence<count, T, T(count.raw)>();

template <is_integral T, ssize count>
constexpr auto zeros_list = value_list<T, T(0), count>;

template <is_integral T, ssize count>
constexpr auto ones_list = value_list<T, T(1), count>;

template <is_integral T, ssize count>
using make_integer_sequence =
    remove_cv<decltype(integer_sequence<ssize, count>)>;

// TODO: What is this?
template <ssize... indices>
using index_list_type = value_type_list<ssize, indices...>;

template <ssize value, ssize count>
constexpr auto index_list = value_list<ssize, value, count>;

template <ssize value, ssize count>
using make_index_list = make_value_type_list<ssize, value, count>;

template <ssize count>
constexpr auto index_sequence = integer_sequence<ssize, count>;

template <ssize count>
using make_index_sequence = make_integer_sequence<ssize, count>;

template <typename... Ts>
// `ssizeof_pack()` here produces an internal compiler error in GCC 12.
using index_sequence_for = make_index_sequence<ssize{sizeof...(Ts)}>;

template <typename T>
    requires(is_enum<T>)
constexpr auto to_underlying(T any_enum) {
    return static_cast<underlying_type<T>>(any_enum);
}

namespace detail {
    template <typename Closure>
    struct DeferWrapper {
        Closure invocable;
        DeferWrapper(Closure&& closure) : invocable(closure) {
        }
        ~DeferWrapper() {
            this->invocable();
        }
    };
}  // namespace detail

// This must be split into two macros, because the `##` is otherwise evaluated
// at the wrong time.
#define LIBCAT_CONCAT2(x, y) x##y
#define LIBCAT_CONCAT(x, y) LIBCAT_CONCAT2(x, y)

// `defer()` is a macro that instantiates a scoped object which executes some
// arbitrary closure in its destructor.
// For example:
//     void* p_mem1 = allocator.alloc();
//     void* p_mem2 = allocator.alloc();
//     defer(allocator.free(p_mem1);
//           allocator.free(p_mem2);)

// `__COUNTER__` is defined by GCC, and it expands to a monotonically increasing
// digit every time it is expanded. This guarantees that every instance of
// `DeferWrapper` has a unique name.

#define defer(deferred_code)                    \
    auto LIBCAT_CONCAT(_defer__, __COUNTER__) = \
        cat::detail::DeferWrapper([&]() {       \
            deferred_code                       \
        });

// TODO: Support `cat::ref`, to enable `variant` and `tuple` to hold references
// more easily.

}  // namespace cat

// These symbols must be declared in `std::` to enable some useful GCC
// features, such as move-semantics warnings, and preventing GDB from stepping
// into the functions.
namespace std {

template <typename T>
[[nodiscard]] constexpr auto as_const(T& value) -> cat::add_const<T>& {
    return value;
}

template <typename T>
void as_const(const T&&) = delete;

// NOLINTBEGIN(readability-redundant-declaration)
// The following functions are forward-declared in `<cat/meta>`, but they
// belong to the `<cat/utility>` library.

/*
template <typename T>
constexpr auto move(T&& input) -> cat::remove_reference<T>&&;

template <typename T>
constexpr auto forward(cat::remove_reference<T>& input) -> T&&;

template <typename T>
requires(!cat::is_lvalue_reference<T>)
constexpr auto std::forward(cat::remove_reference<T>&& input) -> T&&;
*/

// NOLINTEND(readability-redundant-declaration)

}  // namespace std

// `forward()` and `move()` should be usable from within a libCat namespace.
// This apparently does not prevent the aformentioned GCC features from working.
namespace cat {
using std::as_const;
using std::forward;
using std::move;
}  // namespace cat

#include "./implementations/bit_cast.tpp"
#include "./implementations/forward.tpp"
#include "./implementations/move.tpp"
